================================================= test session starts =================================================
platform win32 -- Python 3.11.9, pytest-8.4.2, pluggy-1.6.0 -- C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api
configfile: pytest_full.ini
plugins: anyio-4.12.0, Faker-30.10.0, asyncio-0.26.0, cov-5.0.0, mock-3.15.1
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
collecting ... collected 273 items

tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_action_list_lifecycle FAILED     [  0%]
tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_validation_errors PASSED         [  0%]
tests/integration/api/test_endpoints.py::TestHealthEndpoint::test_health_check FAILED                            [  1%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_success FAILED                      [  1%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_get_task_success FAILED                         [  1%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_get_task_not_found PASSED                       [  2%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_update_task_success FAILED                      [  2%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_delete_task_success FAILED                      [  2%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_list_tasks FAILED                               [  3%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_validation_error PASSED             [  3%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_conflict FAILED                     [  4%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_create_project_success PASSED                [  4%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_get_project_success PASSED                   [  4%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_list_projects FAILED                         [  5%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_success FAILED                [  5%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_not_found FAILED              [  5%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_delete_project_success PASSED                [  6%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_delete_project_not_found PASSED              [  6%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_create_project_validation_error PASSED       [  6%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_create_project_conflict PASSED               [  7%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_success FAILED                  [  7%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_get_sprint_success FAILED                     [  8%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_list_sprints FAILED                           [  8%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_success FAILED                  [  8%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_not_found FAILED                [  9%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_delete_sprint_success FAILED                  [  9%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_delete_sprint_not_found PASSED                [  9%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_validation_error PASSED         [ 10%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_conflict FAILED                 [ 10%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_success FAILED         [ 10%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_get_action_list_success FAILED            [ 11%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_list_action_lists FAILED                  [ 11%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_success FAILED         [ 12%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_not_found FAILED       [ 12%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_delete_action_list_success FAILED         [ 12%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_delete_action_list_not_found PASSED       [ 13%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_validation_error PASSED [ 13%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_conflict FAILED        [ 13%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_limit FAILED              [ 14%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_offset FAILED             [ 14%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_empty_result FAILED         [ 15%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_with_pagination FAILED       [ 15%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_action_lists_limit_boundary FAILED   [ 15%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_zero_offset FAILED             [ 16%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_large_limit FAILED          [ 16%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_default_pagination FAILED    [ 16%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_status FAILED         [ 17%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_priority FAILED       [ 17%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_owner FAILED          [ 17%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_status FAILED      [ 18%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_owner FAILED       [ 18%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_status FAILED       [ 19%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_project FAILED      [ 19%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_filter_by_status FAILED  [ 19%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_multiple_filters FAILED         [ 20%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_no_filters FAILED            [ 20%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_invalid_filter_ignored FAILED [ 20%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_empty_filter_value FAILED [ 21%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_task_max_title_length FAILED       [ 21%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_task_title_exceeds_max_length PASSED [ 21%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_task_invalid_status PASSED         [ 22%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_task_invalid_priority PASSED       [ 22%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_project_max_name_length PASSED     [ 23%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_project_invalid_status PASSED      [ 23%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_sprint_invalid_date_format PASSED  [ 23%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_sprint_invalid_cadence PASSED      [ 24%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_action_list_missing_required_field PASSED [ 24%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_action_list_invalid_status FAILED  [ 24%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_crud_lifecycle PASSED           [ 25%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_validation_errors PASSED        [ 25%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_metrics_endpoint PASSED         [ 26%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_duplicate_project_id PASSED             [ 26%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_management PASSED                  [ 26%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_validation_errors PASSED           [ 27%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_velocity_calculation PASSED        [ 27%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_create_task_full_lifecycle PASSED             [ 27%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_task_validation_errors PASSED                 [ 28%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_list_tasks_pagination_and_filtering PASSED    [ 28%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_duplicate_task_id PASSED                      [ 28%]
tests/integration/services/test_cross_service_ops.py::test_full_workflow_simulation PASSED                       [ 29%]
tests/integration/services/test_project_sprint_flow.py::test_project_sprint_task_hierarchy PASSED                [ 29%]
tests/integration/services/test_project_sprint_flow.py::test_orphan_prevention PASSED                            [ 30%]
tests/integration/services/test_task_sprint_flow.py::test_task_movement_between_sprints PASSED                   [ 30%]
tests/integration/services/test_task_sprint_flow.py::test_sprint_closure_logic PASSED                            [ 30%]
tests/integration/services/test_task_validation.py::test_create_task_with_invalid_project PASSED                 [ 31%]
tests/integration/services/test_task_validation.py::test_create_task_with_invalid_sprint PASSED                  [ 31%]
tests/integration/services/test_task_validation.py::test_update_task_with_invalid_foreign_keys PASSED            [ 31%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_success FAILED               [ 32%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_conflict FAILED              [ 32%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_success FAILED           [ 32%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_not_found FAILED         [ 33%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_success FAILED             [ 33%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_validation_limit_exceeded FAILED [ 34%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_success FAILED               [ 34%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_not_found FAILED             [ 34%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_success FAILED               [ 35%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_not_found FAILED             [ 35%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_true FAILED                  [ 35%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_false FAILED                 [ 36%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_count FAILED                        [ 36%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_exists PASSED        [ 36%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_get_by_owner PASSED  [ 37%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_search_filters_and_pagination PASSED [ 37%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_create_project_method PASSED [ 38%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_update_project_method PASSED [ 38%]
tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_by_status FAILED               [ 38%]
tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_active_projects FAILED         [ 39%]
tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_by_status FAILED                [ 39%]
tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_active_sprints FAILED           [ 39%]
tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_by_owner FAILED             [ 40%]
tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_orphaned FAILED             [ 40%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_exists PASSED          [ 41%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_get_by_project PASSED  [ 41%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_get_active_sprints PASSED [ 41%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_search_sprints PASSED  [ 42%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_create_and_update_sprint_helpers PASSED [ 42%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status FAILED               [ 42%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_priority FAILED             [ 43%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_owner FAILED                [ 43%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project FAILED              [ 43%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project_with_status_filter FAILED [ 44%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_sprint FAILED               [ 44%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status_and_priority FAILED  [ 45%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_blocked_tasks FAILED           [ 45%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_high_priority_tasks FAILED     [ 45%]
tests/unit/db/test_connection_manager.py::test_init_creates_engines ERROR                                        [ 46%]
tests/unit/db/test_connection_manager.py::test_get_session_primary_success ERROR                                 [ 46%]
tests/unit/db/test_connection_manager.py::test_get_session_failover ERROR                                        [ 46%]
tests/unit/db/test_connection_manager.py::test_health_check_reporting ERROR                                      [ 47%]
tests/unit/db/test_connection_manager.py::test_health_check_primary_down ERROR                                   [ 47%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_create_request_valid FAILED                 [ 47%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_id_pattern_validation PASSED                [ 48%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_update_request_partial PASSED               [ 48%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_response_serialization PASSED               [ 49%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_create_request_valid FAILED                   [ 49%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_id_pattern_validation PASSED                  [ 49%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_velocity_points_non_negative PASSED           [ 50%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_update_request_partial PASSED                 [ 50%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_response_with_metrics FAILED                  [ 50%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_create_request_valid PASSED          [ 51%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_with_associations PASSED             [ 51%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_soft_delete_fields FAILED            [ 52%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_update_request_partial PASSED        [ 52%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_response_with_metadata PASSED        [ 52%]
tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_strict_type_validation FAILED              [ 53%]
tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_from_attributes_orm_mode FAILED            [ 53%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_valid_task_create_request PASSED            [ 53%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_success PASSED   [ 54%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_failure FAILED   [ 54%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_required_fields_validation FAILED           [ 54%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_title_max_length_validation PASSED          [ 55%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_estimate_points_non_negative PASSED         [ 55%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_business_value_score_range FAILED           [ 56%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_enum_field_validation FAILED                [ 56%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_default_values PASSED                       [ 56%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_partial_update_all_fields_optional PASSED   [ 57%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_update_with_multiple_fields PASSED          [ 57%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_update_validation_rules_still_apply PASSED  [ 57%]
tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_from_orm_model FAILED                   [ 58%]
tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_serialization FAILED                    [ 58%]
tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_success FAILED                      [ 58%]
tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_conflict_error FAILED               [ 59%]
tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_success FAILED                            [ 59%]
tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_not_found FAILED                          [ 60%]
tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_success FAILED                      [ 60%]
tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_not_found FAILED                    [ 60%]
tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_success FAILED                      [ 61%]
tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_not_found FAILED                    [ 61%]
tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_success FAILED                          [ 61%]
tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_empty_result FAILED                     [ 62%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_true FAILED                        [ 62%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_false FAILED                       [ 63%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_count_success FAILED                      [ 63%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_minimum_fields ERROR [ 63%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_all_fields ERROR [ 64%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_partial_single_field ERROR [ 64%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_empty_mission ERROR [ 64%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_success ERROR [ 65%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_project_not_found ERROR [ 65%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_sprint_to_project ERROR [ 65%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_duplicate_sprint_idempotent ERROR [ 66%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_remove_sprint_from_project ERROR [ 66%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_no_tasks ERROR [ 67%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_project_not_found ERROR [ 67%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_status_no_results ERROR [ 67%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_owner_no_results ERROR [ 68%]
tests/unit/services/test_services.py::TestProjectService::test_get_metrics_success ERROR                         [ 68%]
tests/unit/services/test_services.py::TestProjectService::test_add_sprint ERROR                                  [ 68%]
tests/unit/services/test_services.py::TestProjectService::test_remove_sprint ERROR                               [ 69%]
tests/unit/services/test_services.py::TestProjectService::test_change_status ERROR                               [ 69%]
tests/unit/services/test_services.py::TestProjectService::test_get_by_status ERROR                               [ 69%]
tests/unit/services/test_services.py::TestProjectService::test_get_by_owner ERROR                                [ 70%]
tests/unit/services/test_services.py::TestSprintService::test_calculate_velocity ERROR                           [ 70%]
tests/unit/services/test_services.py::TestSprintService::test_get_burndown ERROR                                 [ 71%]
tests/unit/services/test_services.py::TestSprintService::test_change_status ERROR                                [ 71%]
tests/unit/services/test_services.py::TestSprintService::test_get_current_sprints ERROR                          [ 71%]
tests/unit/services/test_services.py::TestSprintService::test_get_by_project ERROR                               [ 72%]
tests/unit/services/test_services.py::TestSprintService::test_update_metrics ERROR                               [ 72%]
tests/unit/services/test_services.py::TestActionListService::test_reorder_items_success ERROR                    [ 72%]
tests/unit/services/test_services.py::TestActionListService::test_reorder_items_invalid_length ERROR             [ 73%]
tests/unit/services/test_services.py::TestActionListService::test_mark_complete ERROR                            [ 73%]
tests/unit/services/test_services.py::TestActionListService::test_add_item ERROR                                 [ 73%]
tests/unit/services/test_services.py::TestActionListService::test_remove_item ERROR                              [ 74%]
tests/unit/services/test_services.py::TestActionListService::test_get_orphaned ERROR                             [ 74%]
tests/unit/services/test_services.py::TestActionListService::test_get_soft_deleted ERROR                         [ 75%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_calculate_velocity_mixed_tasks ERROR [ 75%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_get_burndown_calculations ERROR [ 75%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceSerialization::test_deserialize_maps_primary_project PASSED [ 76%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_valid_transition FAILED [ 76%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_invalid_transition FAILED [ 76%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_not_found FAILED  [ 77%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_new_to_ready PASSED [ 77%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_ready_to_in_progress PASSED [ 78%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_done_to_any_is_invalid PASSED [ 78%]
tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_sprint FAILED                [ 78%]
tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_project FAILED               [ 79%]
tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_success FAILED         [ 79%]
tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_fails_fast FAILED      [ 79%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status FAILED                    [ 80%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status_and_priority FAILED       [ 80%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_high_priority_tasks FAILED             [ 80%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_blocked_tasks FAILED                   [ 81%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_new_to_ready FAILED [ 81%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_blocked FAILED [ 82%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_done FAILED [ 82%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_new FAILED [ 82%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_in_progress FAILED [ 83%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_dropped_to_ready FAILED [ 83%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_new_to_done FAILED [ 83%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_ready_to_blocked FAILED [ 84%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_partial_failure_fails_fast FAILED [ 84%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_empty_list PASSED [ 84%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_sprint FAILED [ 85%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_project FAILED [ 85%]
tests/unit/test_config.py::TestDatabaseConfig::test_valid_database_config PASSED                                 [ 86%]
tests/unit/test_config.py::TestDatabaseConfig::test_connection_string_generation PASSED                          [ 86%]
tests/unit/test_config.py::TestDatabaseConfig::test_async_connection_string_generation PASSED                    [ 86%]
tests/unit/test_config.py::TestDatabaseConfig::test_invalid_port_too_low PASSED                                  [ 87%]
tests/unit/test_config.py::TestDatabaseConfig::test_invalid_port_too_high PASSED                                 [ 87%]
tests/unit/test_config.py::TestDatabaseConfig::test_empty_user_rejected PASSED                                   [ 87%]
tests/unit/test_config.py::TestDatabaseConfig::test_default_values PASSED                                        [ 88%]
tests/unit/test_config.py::TestRedisConfig::test_valid_redis_config PASSED                                       [ 88%]
tests/unit/test_config.py::TestRedisConfig::test_default_values PASSED                                           [ 89%]
tests/unit/test_config.py::TestRedisConfig::test_invalid_url_pattern PASSED                                      [ 89%]
tests/unit/test_config.py::TestRedisConfig::test_timeout_validation PASSED                                       [ 89%]
tests/unit/test_config.py::TestRedisConfig::test_db_number_validation PASSED                                     [ 90%]
tests/unit/test_config.py::TestSettings::test_valid_settings_development FAILED                                  [ 90%]
tests/unit/test_config.py::TestSettings::test_valid_settings_production FAILED                                   [ 90%]
tests/unit/test_config.py::TestSettings::test_production_rejects_insecure_secret_key PASSED                      [ 91%]
tests/unit/test_config.py::TestSettings::test_production_rejects_insecure_jwt_secret PASSED                      [ 91%]
tests/unit/test_config.py::TestSettings::test_development_allows_insecure_secrets FAILED                         [ 91%]
tests/unit/test_config.py::TestSettings::test_secret_key_min_length_32 PASSED                                    [ 92%]
tests/unit/test_config.py::TestSettings::test_optional_redis_config FAILED                                       [ 92%]
tests/unit/test_config.py::TestSettings::test_with_redis_config FAILED                                           [ 93%]
tests/unit/test_config.py::TestSettings::test_invalid_environment PASSED                                         [ 93%]
tests/unit/test_config.py::TestSettings::test_extra_fields_rejected PASSED                                       [ 93%]
tests/unit/test_config.py::TestSettings::test_environment_helpers FAILED                                         [ 94%]
tests/unit/test_config.py::TestGetSettings::test_settings_cached FAILED                                          [ 94%]
tests/unit/test_config.py::TestGetSettings::test_cache_clear FAILED                                              [ 94%]
tests/unit/test_fixtures.py::TestDatabaseConfigFixture::test_fixture_provides_isolated_config PASSED             [ 95%]
tests/unit/test_fixtures.py::TestDatabaseConfigFixture::test_fixture_connection_string PASSED                    [ 95%]
tests/unit/test_fixtures.py::TestRedisConfigFixture::test_fixture_provides_isolated_config PASSED                [ 95%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_provides_complete_settings ERROR                  [ 96%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_database ERROR                           [ 96%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_redis ERROR                              [ 97%]
tests/unit/test_fixtures.py::TestMinimalSettingsFixture::test_fixture_provides_minimal_config ERROR              [ 97%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_simulates_production ERROR                  [ 97%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_database ERROR               [ 98%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_redis ERROR                  [ 98%]
tests/unit/test_fixtures.py::TestCacheClearFixture::test_cache_cleared_between_tests_1 PASSED                    [ 98%]
tests/unit/test_fixtures.py::TestCacheClearFixture::test_cache_cleared_between_tests_2 PASSED                    [ 99%]
tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_environment_set_to_testing PASSED                    [ 99%]
tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_settings_default_to_testing ERROR                    [100%]

======================================================= ERRORS ========================================================
_____________________________________ ERROR at setup of test_init_creates_engines _____________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\pkgutil.py:715: AttributeError
_________________________________ ERROR at setup of test_get_session_primary_success __________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\pkgutil.py:715: AttributeError
_____________________________________ ERROR at setup of test_get_session_failover _____________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\pkgutil.py:715: AttributeError
____________________________________ ERROR at setup of test_health_check_reporting ____________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\pkgutil.py:715: AttributeError
__________________________________ ERROR at setup of test_health_check_primary_down ___________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\pkgutil.py:715: AttributeError
___________ ERROR at setup of TestProjectServiceBoundaryConditions.test_create_project_with_minimum_fields ____________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________ ERROR at setup of TestProjectServiceBoundaryConditions.test_create_project_with_all_fields ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________ ERROR at setup of TestProjectServiceBoundaryConditions.test_update_project_partial_single_field ___________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________ ERROR at setup of TestProjectServiceBoundaryConditions.test_update_project_empty_mission _______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__________________ ERROR at setup of TestProjectServiceStatusTransitions.test_change_status_success ___________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________ ERROR at setup of TestProjectServiceStatusTransitions.test_change_status_project_not_found ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestProjectServiceSprintManagement.test_add_sprint_to_project ___________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________ ERROR at setup of TestProjectServiceSprintManagement.test_add_duplicate_sprint_idempotent ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________ ERROR at setup of TestProjectServiceSprintManagement.test_remove_sprint_from_project _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________ ERROR at setup of TestProjectServiceMetrics.test_get_metrics_no_tasks ________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestProjectServiceMetrics.test_get_metrics_project_not_found ____________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________ ERROR at setup of TestProjectServiceSearchAndFiltering.test_get_by_status_no_results _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________ ERROR at setup of TestProjectServiceSearchAndFiltering.test_get_by_owner_no_results _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestProjectService.test_get_metrics_success ____________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestProjectService.test_add_sprint _________________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_remove_sprint _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_change_status _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_get_by_status _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_get_by_owner ________________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ ERROR at setup of TestSprintService.test_calculate_velocity _____________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestSprintService.test_get_burndown ________________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_change_status ________________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestSprintService.test_get_current_sprints _____________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_get_by_project _______________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_update_metrics _______________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________________ ERROR at setup of TestActionListService.test_reorder_items_success __________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________ ERROR at setup of TestActionListService.test_reorder_items_invalid_length ______________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ ERROR at setup of TestActionListService.test_mark_complete ______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestActionListService.test_add_item ________________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________ ERROR at setup of TestActionListService.test_remove_item _______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________ ERROR at setup of TestActionListService.test_get_orphaned ______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestActionListService.test_get_soft_deleted ____________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestSprintServiceMetrics.test_calculate_velocity_mixed_tasks ____________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________ ERROR at setup of TestSprintServiceMetrics.test_get_burndown_calculations ______________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________ ERROR at setup of TestSettingsFixture.test_fixture_provides_complete_settings ____________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a9eb70>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________ ERROR at setup of TestSettingsFixture.test_fixture_includes_database _________________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a9cbe0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________________ ERROR at setup of TestSettingsFixture.test_fixture_includes_redis __________________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a09b30>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________ ERROR at setup of TestMinimalSettingsFixture.test_fixture_provides_minimal_config __________________

    @pytest.fixture
    def minimal_test_settings() -> Settings:
        """
        Provide minimal test settings without Redis.
    
        Useful for tests that don't require caching.
    
        Returns:
            Settings with only required configuration
    
        Example:
            >>> def test_no_cache(minimal_test_settings):
            ...     assert minimal_test_settings.redis is None
        """
>       return Settings(
            environment="testing",
            database=DatabaseConfig(
                host="localhost",
                port=5433,
                user="taskman_test",
                password=SecretStr("test_password"),
                database="taskman_test",
            ),
            redis=None,  # No Redis for minimal tests
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a9c690>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ord@localhost:5433/taskman_test'), 'environment': 'testing', 'jwt_secret': SecretStr('**********'), 'redis': None, ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestProductionLikeFixture.test_fixture_simulates_production ____________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a09fe0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________ ERROR at setup of TestProductionLikeFixture.test_fixture_has_production_database ___________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a0a0d0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestProductionLikeFixture.test_fixture_has_production_redis ____________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a9f980>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________ ERROR at setup of TestEnvironmentIsolation.test_settings_default_to_testing _____________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910adbf20>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
====================================================== FAILURES =======================================================
________________________________ TestActionListIntegration.test_action_list_lifecycle _________________________________

self = <test_action_lists_api.TestActionListIntegration object at 0x000001F90DC29F90>
client = <httpx.AsyncClient object at 0x000001F90F12B8D0>

    async def test_action_list_lifecycle(self, client: AsyncClient):
        """Test complete action list lifecycle: Create -> Get -> Update -> Delete."""
        # 1. Create
        create_payload = {
            "id": "AL-INT-001",
            "title": "Integration Test List",
            "description": "Test Description",
            "status": "active",
            "items": [{"id": "Task-1", "text": "Task 1"}, {"id": "Task-2", "text": "Task 2"}],
        }
        create_res = await client.post("/api/v1/action-lists", json=create_payload)
        # If schema mismatch, we get 422.
        if create_res.status_code != status.HTTP_201_CREATED:
            pytest.fail(f"Create failed: {create_res.text}")
    
        assert create_res.status_code == status.HTTP_201_CREATED
        created_data = create_res.json()
        list_id = created_data["id"]
        # Service overwrites ID with AL-xxxx format, so it won't be AL-INT-001
        assert list_id.startswith("AL-")
        assert created_data["title"] == "Integration Test List"
        # task_ids in response might be just IDs or full items depending on response schema mapping from entity
        # Entity has task_ids=[dict, dict]. Response has items=[dict, dict].
>       assert len(created_data["items"]) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests\integration\api\test_action_lists_api.py:35: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "924a5a14-1de5-47ef-a706-e1b61cc95e53", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:43.830801Z", "level": "info"}
{"list_id": "AL-0001", "event": "action_list_created", "timestamp": "2025-12-29T00:00:43.869730Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 39.95, "correlation_id": "924a5a14-1de5-47ef-a706-e1b61cc95e53", "event": "http_response", "timestamp": "2025-12-29T00:00:43.870730Z", "level": "info"}
________________________________________ TestHealthEndpoint.test_health_check _________________________________________
  + Exception Group Traceback (most recent call last):
  |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "c:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\anyio\_backends\_asyncio.py", line 783, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\runner.py", line 344, in from_call
    |     result: TResult | None = func()
    |                              ^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\runner.py", line 246, in <lambda>
    |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\logging.py", line 850, in pytest_runtest_call
    |     yield
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\capture.py", line 900, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\skipping.py", line 263, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\runner.py", line 178, in pytest_runtest_call
    |     item.runtest()
    |   File "c:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pytest_asyncio\plugin.py", line 549, in runtest
    |     super().runtest()
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\python.py", line 1671, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\_pytest\python.py", line 157, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "c:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pytest_asyncio\plugin.py", line 1069, in inner
    |     _loop.run_until_complete(task)
    |   File "C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\asyncio\base_events.py", line 654, in run_until_complete
    |     return future.result()
    |            ^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\tests\integration\api\test_endpoints.py", line 14, in test_health_check
    |     response = await client.get("/health")
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1814, in get
    |     return await self.request(
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1585, in request
    |     return await self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1674, in send
    |     response = await self._send_handling_auth(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1702, in _send_handling_auth
    |     response = await self._send_handling_redirects(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1739, in _send_handling_redirects
    |     response = await self._send_single_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1776, in _send_single_request
    |     response = await transport.handle_async_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_transports\asgi.py", line 157, in handle_async_request
    |     await self.app(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\applications.py", line 112, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\errors.py", line 187, in __call__
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\contextlib.py", line 158, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\middleware\logging_middleware.py", line 223, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 73, in app
    |     response = await f(request)
    |                ^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\fastapi\routing.py", line 301, in app
    |     raw_response = await run_endpoint_function(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\fastapi\routing.py", line 212, in run_endpoint_function
    |     return await dependant.call(**values)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\main.py", line 258, in health_check
    |     if "@" in settings.database.connection_string
    |               ^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pydantic\main.py", line 1026, in __getattr__
    |     raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
    | AttributeError: 'Settings' object has no attribute 'database'
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\tests\integration\api\test_endpoints.py", line 14, in test_health_check
    response = await client.get("/health")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1814, in get
    return await self.request(
           ^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1585, in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1674, in send
    response = await self._send_handling_auth(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1702, in _send_handling_auth
    response = await self._send_handling_redirects(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1739, in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_client.py", line 1776, in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\httpx\_transports\asgi.py", line 157, in handle_async_request
    await self.app(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\errors.py", line 187, in __call__
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\contextlib.py", line 158, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\middleware\logging_middleware.py", line 223, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\starlette\routing.py", line 73, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\fastapi\routing.py", line 301, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\fastapi\routing.py", line 212, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\main.py", line 258, in health_check
    if "@" in settings.database.connection_string
              ^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Lib\site-packages\pydantic\main.py", line 1026, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
AttributeError: 'Settings' object has no attribute 'database'

During handling of the above exception, another exception occurred:

self = <test_endpoints.TestHealthEndpoint object at 0x000001F90F24AC50>
client = <httpx.AsyncClient object at 0x000001F90DB7D790>

    async def test_health_check(self, client):
        """Test health check returns 200."""
>       response = await client.get("/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\api\test_endpoints.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\httpx\_client.py:1814: in get
    return await self.request(
.venv\Lib\site-packages\httpx\_client.py:1585: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\httpx\_client.py:1674: in send
    response = await self._send_handling_auth(
.venv\Lib\site-packages\httpx\_client.py:1702: in _send_handling_auth
    response = await self._send_handling_redirects(
.venv\Lib\site-packages\httpx\_client.py:1739: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\httpx\_client.py:1776: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\httpx\_transports\asgi.py:157: in handle_async_request
    await self.app(scope, receive, send)
.venv\Lib\site-packages\fastapi\applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
.venv\Lib\site-packages\starlette\applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
.venv\Lib\site-packages\starlette\middleware\errors.py:187: in __call__
    raise exc
.venv\Lib\site-packages\starlette\middleware\errors.py:165: in __call__
    await self.app(scope, receive, _send)
.venv\Lib\site-packages\starlette\middleware\base.py:176: in __call__
    with recv_stream, send_stream, collapse_excgroups():
C:\Users\James\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
.venv\Lib\site-packages\starlette\_utils.py:82: in collapse_excgroups
    raise exc
.venv\Lib\site-packages\starlette\middleware\base.py:178: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\middleware\logging_middleware.py:223: in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\starlette\middleware\base.py:156: in call_next
    raise app_exc
.venv\Lib\site-packages\starlette\middleware\base.py:141: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
.venv\Lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
.venv\Lib\site-packages\starlette\middleware\exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
.venv\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
.venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv\Lib\site-packages\starlette\routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
.venv\Lib\site-packages\starlette\routing.py:734: in app
    await route.handle(scope, receive, send)
.venv\Lib\site-packages\starlette\routing.py:288: in handle
    await self.app(scope, receive, send)
.venv\Lib\site-packages\starlette\routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
.venv\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
.venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
.venv\Lib\site-packages\starlette\routing.py:73: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\fastapi\routing.py:301: in app
    raw_response = await run_endpoint_function(
.venv\Lib\site-packages\fastapi\routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\main.py:258: in health_check
    if "@" in settings.database.connection_string
              ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(api_host='0.0.0.0', api_port=3001, environment='development', database_url='postgresql://contextforge:contextforge@localhost:5434/taskman_v2', log_level='DEBUG')
item = 'database'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra and item in pydantic_extra:
                return pydantic_extra[item]
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'database'

.venv\Lib\site-packages\pydantic\main.py:1026: AttributeError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/health", "correlation_id": "b6f1f7bc-bf41-411e-a181-78d839a36950", "duration_ms": 111.64, "error": "'Settings' object has no attribute 'database'", "error_type": "AttributeError", "event": "http_request_error", "timestamp": "2025-12-29T00:00:44.149535Z", "level": "error"}
{"error": "'Settings' object has no attribute 'database'", "path": "/health", "event": "unhandled_exception", "timestamp": "2025-12-29T00:00:44.149535Z", "level": "error"}
_____________________________________ TestTaskEndpoints.test_create_task_success ______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000001F90F24AA50>
client = <httpx.AsyncClient object at 0x000001F9103DCB90>

    async def test_create_task_success(self, client):
        """Test successful task creation."""
        task_data = {
            "id": "T-TEST-001",
            "title": "Test Task",
            "summary": "Test summary",
            "description": "Test description",
            "owner": "test.owner",
            "priority": "p1",  # Fixed: was "high", now uses proper enum value
            "primary_project": "P-TEST-001",
            "primary_sprint": "S-TEST-001",
        }
    
        response = await client.post("/api/v1/tasks", json=task_data)
    
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:40: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "f9c9a745-a6ac-4807-b87a-6a43817f9ab2", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.686509Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 21.29, "correlation_id": "f9c9a745-a6ac-4807-b87a-6a43817f9ab2", "event": "http_response", "timestamp": "2025-12-29T00:00:44.708192Z", "level": "warning"}
_______________________________________ TestTaskEndpoints.test_get_task_success _______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000001F90F24BE10>
client = <httpx.AsyncClient object at 0x000001F90F954C90>

    async def test_get_task_success(self, client):
        """Test getting task by ID."""
        # Create task first
        task_data = {
            "id": "T-GET-001",
            "title": "Get Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",  # Fixed: was "medium", now uses proper enum value
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Get task
        response = await client.get("/api/v1/tasks/T-GET-001")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:63: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "256bb5d9-56d8-4001-9a18-131f49411f2f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.747900Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.63, "correlation_id": "256bb5d9-56d8-4001-9a18-131f49411f2f", "event": "http_response", "timestamp": "2025-12-29T00:00:44.753970Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks/T-GET-001", "query": null, "correlation_id": "9b1a2320-6d1d-4c20-828b-83b76c954fbf", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.754970Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks/T-GET-001", "status_code": 404, "duration_ms": 6.42, "correlation_id": "9b1a2320-6d1d-4c20-828b-83b76c954fbf", "event": "http_response", "timestamp": "2025-12-29T00:00:44.760970Z", "level": "warning"}
_____________________________________ TestTaskEndpoints.test_update_task_success ______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000001F90F2493D0>
client = <httpx.AsyncClient object at 0x000001F90EEFC3D0>

    async def test_update_task_success(self, client):
        """Test updating task."""
        # Create task
        task_data = {
            "id": "T-UPDATE-001",
            "title": "Original Title",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p3",  # Fixed: was "low", now uses proper enum value
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        create_response = await client.post("/api/v1/tasks", json=task_data)
>       assert create_response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:87: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "edbab747-cd96-4cdc-a2fc-c8c69e66b3d7", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.829558Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.87, "correlation_id": "edbab747-cd96-4cdc-a2fc-c8c69e66b3d7", "event": "http_response", "timestamp": "2025-12-29T00:00:44.835628Z", "level": "warning"}
_____________________________________ TestTaskEndpoints.test_delete_task_success ______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000001F90F249B50>
client = <httpx.AsyncClient object at 0x000001F90FCEAE50>

    async def test_delete_task_success(self, client):
        """Test deleting task."""
        # Create task
        task_data = {
            "id": "T-DELETE-001",
            "title": "Delete Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p3",  # Fixed: was "low", now uses proper enum value
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Delete task
        response = await client.delete("/api/v1/tasks/T-DELETE-001")
    
>       assert response.status_code == status.HTTP_204_NO_CONTENT
E       assert 404 == 204
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   204 = status.HTTP_204_NO_CONTENT

tests\integration\api\test_endpoints.py:115: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "5481675a-18bf-4efd-8a26-861f1e1478c1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.873649Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.87, "correlation_id": "5481675a-18bf-4efd-8a26-861f1e1478c1", "event": "http_response", "timestamp": "2025-12-29T00:00:44.879647Z", "level": "warning"}
{"method": "DELETE", "path": "/api/v1/tasks/T-DELETE-001", "query": null, "correlation_id": "0013d6c2-3b67-4fa3-9b77-7a043b34bfa6", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.879647Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/tasks/T-DELETE-001", "status_code": 404, "duration_ms": 4.36, "correlation_id": "0013d6c2-3b67-4fa3-9b77-7a043b34bfa6", "event": "http_response", "timestamp": "2025-12-29T00:00:44.884157Z", "level": "warning"}
__________________________________________ TestTaskEndpoints.test_list_tasks __________________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000001F90F23A690>
client = <httpx.AsyncClient object at 0x000001F90FF98890>

    async def test_list_tasks(self, client):
        """Test listing tasks with pagination."""
        # Create multiple tasks
        for i in range(5):
            task_data = {
                "id": f"T-LIST-{i:03d}",
                "title": f"Task {i}",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": "p2",  # Fixed: was "medium", now uses proper enum value
                "primary_project": "P-001",
                "primary_sprint": "S-001",
            }
            await client.post("/api/v1/tasks", json=task_data)
    
        # List tasks
        response = await client.get("/api/v1/tasks?limit=10&offset=0")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:142: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "12fd8ad0-12f2-4034-986a-e59d5527bd85", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.924851Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.33, "correlation_id": "12fd8ad0-12f2-4034-986a-e59d5527bd85", "event": "http_response", "timestamp": "2025-12-29T00:00:44.929557Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "318227e7-bbe4-478d-a863-5fbc52d8cb57", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.931100Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.25, "correlation_id": "318227e7-bbe4-478d-a863-5fbc52d8cb57", "event": "http_response", "timestamp": "2025-12-29T00:00:44.934116Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "1b88a1c6-d4c3-45f8-b85a-90d0cac24cd9", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.935115Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.86, "correlation_id": "1b88a1c6-d4c3-45f8-b85a-90d0cac24cd9", "event": "http_response", "timestamp": "2025-12-29T00:00:44.938116Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "49204ce8-3f65-4f6d-a4f3-9c6118e34b75", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.938116Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.94, "correlation_id": "49204ce8-3f65-4f6d-a4f3-9c6118e34b75", "event": "http_response", "timestamp": "2025-12-29T00:00:44.941115Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "cbbfbc14-afb3-4382-93a7-5f0739d927b1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.942115Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.43, "correlation_id": "cbbfbc14-afb3-4382-93a7-5f0739d927b1", "event": "http_response", "timestamp": "2025-12-29T00:00:44.945116Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "limit=10&offset=0", "correlation_id": "c729f10f-c61a-450c-a848-a086e3e99796", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:44.945116Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:44.953116Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 8.14, "correlation_id": "c729f10f-c61a-450c-a848-a086e3e99796", "event": "http_response", "timestamp": "2025-12-29T00:00:44.953116Z", "level": "info"}
_____________________________________ TestTaskEndpoints.test_create_task_conflict _____________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000001F90F23A890>
client = <httpx.AsyncClient object at 0x000001F90EE93F90>

    async def test_create_task_conflict(self, client):
        """Test duplicate task ID returns 409."""
        task_data = {
            "id": "T-CONFLICT-001",
            "title": "Conflict Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
    
        # Create first task
        first_response = await client.post("/api/v1/tasks", json=task_data)
>       assert first_response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:177: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "db73fb2a-72aa-4714-aff8-0bb1973f5541", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.032902Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.81, "correlation_id": "db73fb2a-72aa-4714-aff8-0bb1973f5541", "event": "http_response", "timestamp": "2025-12-29T00:00:45.038410Z", "level": "warning"}
_______________________________________ TestProjectEndpoints.test_list_projects _______________________________________

self = <test_endpoints.TestProjectEndpoints object at 0x000001F90F23B5D0>
client = <httpx.AsyncClient object at 0x000001F90EF23B50>

    async def test_list_projects(self, client):
        """Test listing projects."""
        # Create projects
        for i in range(3):
            project_data = {
                "id": f"P-LIST-{i:03d}",
                "name": f"Project {i}",
                "mission": "Mission",
                "status": "active",
                "start_date": "2025-01-01",
                "owner": "owner",
            }
            await client.post("/api/v1/projects", json=project_data)
    
        # List projects
        response = await client.get("/api/v1/projects")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)

tests\integration\api\test_endpoints.py:245: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "0935953c-a155-4b6b-8542-feb80fdbe2d1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.251690Z", "level": "info"}
{"project_id": "P-LIST-000", "name": "Project 0", "event": "project_created", "timestamp": "2025-12-29T00:00:45.259202Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 8.8, "correlation_id": "0935953c-a155-4b6b-8542-feb80fdbe2d1", "event": "http_response", "timestamp": "2025-12-29T00:00:45.260202Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "ab6e604a-5887-475d-99d7-9e9c3a02518a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.261203Z", "level": "info"}
{"project_id": "P-LIST-001", "name": "Project 1", "event": "project_created", "timestamp": "2025-12-29T00:00:45.266204Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 4.95, "correlation_id": "ab6e604a-5887-475d-99d7-9e9c3a02518a", "event": "http_response", "timestamp": "2025-12-29T00:00:45.266204Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "ef5aa952-4bcd-46b6-a337-a7d19ed8ba9f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.267202Z", "level": "info"}
{"project_id": "P-LIST-002", "name": "Project 2", "event": "project_created", "timestamp": "2025-12-29T00:00:45.271714Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 4.84, "correlation_id": "ef5aa952-4bcd-46b6-a337-a7d19ed8ba9f", "event": "http_response", "timestamp": "2025-12-29T00:00:45.271714Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "query": null, "correlation_id": "79c52b31-d461-4d2a-b8bd-b70dbf3115f2", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.273715Z", "level": "info"}
{"count": 3, "total": 3, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:45.281716Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 9.24, "correlation_id": "79c52b31-d461-4d2a-b8bd-b70dbf3115f2", "event": "http_response", "timestamp": "2025-12-29T00:00:45.282714Z", "level": "info"}
__________________________________ TestProjectEndpoints.test_update_project_success ___________________________________

self = <test_endpoints.TestProjectEndpoints object at 0x000001F90F23A4D0>
client = <httpx.AsyncClient object at 0x000001F90F9DE7D0>

    async def test_update_project_success(self, client):
        """Test updating project returns 200."""
        # Create project
        project_data = {
            "id": "P-UPDATE-001",
            "name": "Original Name",
            "mission": "Mission",
            "status": "active",
            "start_date": "2025-01-01",
            "owner": "owner",
        }
        create_response = await client.post("/api/v1/projects", json=project_data)
        assert create_response.status_code == status.HTTP_201_CREATED
    
        # Update project
        update_data = {"name": "Updated Name"}
        response = await client.patch("/api/v1/projects/P-UPDATE-001", json=update_data)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:266: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "167e485d-612c-42fb-b765-1b3a1aaa1019", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.330773Z", "level": "info"}
{"project_id": "P-UPDATE-001", "name": "Original Name", "event": "project_created", "timestamp": "2025-12-29T00:00:45.337771Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 9.06, "correlation_id": "167e485d-612c-42fb-b765-1b3a1aaa1019", "event": "http_response", "timestamp": "2025-12-29T00:00:45.339775Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/projects/P-UPDATE-001", "query": null, "correlation_id": "8ab8294b-f70d-4a8e-8f1b-d318daedabec", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.340771Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/projects/P-UPDATE-001", "status_code": 405, "duration_ms": 0.68, "correlation_id": "8ab8294b-f70d-4a8e-8f1b-d318daedabec", "event": "http_response", "timestamp": "2025-12-29T00:00:45.341771Z", "level": "warning"}
_________________________________ TestProjectEndpoints.test_update_project_not_found __________________________________

self = <test_endpoints.TestProjectEndpoints object at 0x000001F90F23B910>
client = <httpx.AsyncClient object at 0x000001F90F9BF990>

    async def test_update_project_not_found(self, client):
        """Test updating non-existent project returns 404."""
        update_data = {"name": "Updated Name"}
        response = await client.patch("/api/v1/projects/P-NONEXISTENT", json=update_data)
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 405 == 404
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests\integration\api\test_endpoints.py:275: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "PATCH", "path": "/api/v1/projects/P-NONEXISTENT", "query": null, "correlation_id": "87524908-87db-4da3-ae10-f016230ef96d", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.379922Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/projects/P-NONEXISTENT", "status_code": 405, "duration_ms": 0.54, "correlation_id": "87524908-87db-4da3-ae10-f016230ef96d", "event": "http_response", "timestamp": "2025-12-29T00:00:45.379922Z", "level": "warning"}
___________________________________ TestSprintEndpoints.test_create_sprint_success ____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F22A150>
client = <httpx.AsyncClient object at 0x000001F90FD0FA10>

    async def test_create_sprint_success(self, client):
        """Test successful sprint creation."""
        sprint_data = {
            "id": "S-TEST-001",
            "name": "Sprint 1",
            "goal": "Sprint goal",
            "cadence": "biweekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-14",
            "status": "active",
            "owner": "scrum.master",
            "primary_project": "P-001",
        }
    
        response = await client.post("/api/v1/sprints", json=sprint_data)
    
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:360: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "cd181218-f7e4-4715-818c-4c1c3e3abeb6", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.543828Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 14.99, "correlation_id": "cd181218-f7e4-4715-818c-4c1c3e3abeb6", "event": "http_response", "timestamp": "2025-12-29T00:00:45.558651Z", "level": "warning"}
_____________________________________ TestSprintEndpoints.test_get_sprint_success _____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F22B810>
client = <httpx.AsyncClient object at 0x000001F90FCF6D50>

    async def test_get_sprint_success(self, client):
        """Test getting sprint by ID."""
        # Create sprint
        sprint_data = {
            "id": "S-GET-001",
            "name": "Get Test Sprint",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Get sprint
        response = await client.get("/api/v1/sprints/S-GET-001")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:384: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "ccdd46c1-82bb-4c63-9e9f-09c055d3d6b8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.602711Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 8.53, "correlation_id": "ccdd46c1-82bb-4c63-9e9f-09c055d3d6b8", "event": "http_response", "timestamp": "2025-12-29T00:00:45.611225Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints/S-GET-001", "query": null, "correlation_id": "4ea59b1d-73f7-4a01-a01b-dfdb2598badd", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.612223Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints/S-GET-001", "status_code": 404, "duration_ms": 6.95, "correlation_id": "4ea59b1d-73f7-4a01-a01b-dfdb2598badd", "event": "http_response", "timestamp": "2025-12-29T00:00:45.619224Z", "level": "warning"}
________________________________________ TestSprintEndpoints.test_list_sprints ________________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F228F90>
client = <httpx.AsyncClient object at 0x000001F90FD0F310>

    async def test_list_sprints(self, client):
        """Test listing sprints."""
        # Create sprints
        for i in range(3):
            sprint_data = {
                "id": f"S-LIST-{i:03d}",
                "name": f"Sprint {i}",
                "goal": "Goal",
                "cadence": "biweekly",
                "start_date": "2025-01-01",
                "end_date": "2025-01-14",
                "status": "active",
                "owner": "owner",
                "primary_project": "P-001",
            }
            await client.post("/api/v1/sprints", json=sprint_data)
    
        # List sprints
        response = await client.get("/api/v1/sprints")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:410: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "893b54b0-3693-4158-9f3a-eadd1e773283", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.677648Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 9.56, "correlation_id": "893b54b0-3693-4158-9f3a-eadd1e773283", "event": "http_response", "timestamp": "2025-12-29T00:00:45.687682Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "b72c2ed7-b6f0-46a0-8903-984bb29a9b10", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.688681Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 5.8, "correlation_id": "b72c2ed7-b6f0-46a0-8903-984bb29a9b10", "event": "http_response", "timestamp": "2025-12-29T00:00:45.694683Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "0d88dce8-53e5-4a04-a70e-ee5fd0882764", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.695685Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 3.81, "correlation_id": "0d88dce8-53e5-4a04-a70e-ee5fd0882764", "event": "http_response", "timestamp": "2025-12-29T00:00:45.699682Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": null, "correlation_id": "9c596e63-84f2-4a3c-9c8b-c45a2fb78487", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.700682Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:45.710685Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 11.67, "correlation_id": "9c596e63-84f2-4a3c-9c8b-c45a2fb78487", "event": "http_response", "timestamp": "2025-12-29T00:00:45.711682Z", "level": "info"}
___________________________________ TestSprintEndpoints.test_update_sprint_success ____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F228A10>
client = <httpx.AsyncClient object at 0x000001F9102B5B90>

    async def test_update_sprint_success(self, client):
        """Test updating sprint returns 200."""
        # Create sprint
        sprint_data = {
            "id": "S-UPDATE-001",
            "name": "Original Sprint",
            "goal": "Original Goal",
            "cadence": "biweekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-14",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        create_response = await client.post("/api/v1/sprints", json=sprint_data)
>       assert create_response.status_code == status.HTTP_201_CREATED
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:428: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "9164c290-c51d-4436-b51d-c56ffef1f621", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.776682Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 8.72, "correlation_id": "9164c290-c51d-4436-b51d-c56ffef1f621", "event": "http_response", "timestamp": "2025-12-29T00:00:45.785683Z", "level": "warning"}
__________________________________ TestSprintEndpoints.test_update_sprint_not_found ___________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F229450>
client = <httpx.AsyncClient object at 0x000001F90F9D4310>

    async def test_update_sprint_not_found(self, client):
        """Test updating non-existent sprint returns 404."""
        update_data = {"name": "Updated Sprint"}
        response = await client.patch("/api/v1/sprints/S-NONEXISTENT", json=update_data)
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 405 == 404
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests\integration\api\test_endpoints.py:444: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "PATCH", "path": "/api/v1/sprints/S-NONEXISTENT", "query": null, "correlation_id": "83990859-877b-4814-a9e7-1746ef6f2a12", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.863130Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/sprints/S-NONEXISTENT", "status_code": 405, "duration_ms": 0.81, "correlation_id": "83990859-877b-4814-a9e7-1746ef6f2a12", "event": "http_response", "timestamp": "2025-12-29T00:00:45.864129Z", "level": "warning"}
___________________________________ TestSprintEndpoints.test_delete_sprint_success ____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F223B50>
client = <httpx.AsyncClient object at 0x000001F90F95A5D0>

    async def test_delete_sprint_success(self, client):
        """Test deleting sprint returns 204."""
        # Create sprint
        sprint_data = {
            "id": "S-DELETE-001",
            "name": "Delete Test",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Delete sprint
        response = await client.delete("/api/v1/sprints/S-DELETE-001")
    
>       assert response.status_code == status.HTTP_204_NO_CONTENT
E       assert 404 == 204
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   204 = status.HTTP_204_NO_CONTENT

tests\integration\api\test_endpoints.py:465: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "072cdb3a-295f-461c-833a-3ad0e3743ab1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.932145Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 12.07, "correlation_id": "072cdb3a-295f-461c-833a-3ad0e3743ab1", "event": "http_response", "timestamp": "2025-12-29T00:00:45.944145Z", "level": "warning"}
{"method": "DELETE", "path": "/api/v1/sprints/S-DELETE-001", "query": null, "correlation_id": "3f7b055f-25f0-41c0-a498-b6222b5fe0e5", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:45.946141Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/sprints/S-DELETE-001", "status_code": 404, "duration_ms": 7.53, "correlation_id": "3f7b055f-25f0-41c0-a498-b6222b5fe0e5", "event": "http_response", "timestamp": "2025-12-29T00:00:45.953142Z", "level": "warning"}
___________________________________ TestSprintEndpoints.test_create_sprint_conflict ___________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000001F90F22B950>
client = <httpx.AsyncClient object at 0x000001F90EF52F50>

    async def test_create_sprint_conflict(self, client):
        """Test duplicate sprint ID returns 409."""
        sprint_data = {
            "id": "S-CONFLICT-001",
            "name": "Conflict Test",
            "goal": "Goal",
            "cadence": "biweekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-14",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
    
        # Create first sprint
        first_response = await client.post("/api/v1/sprints", json=sprint_data)
>       assert first_response.status_code == status.HTTP_201_CREATED
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:511: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "c92edc01-9cb7-446c-8f51-a6ac6fffd4b0", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.086612Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 6.91, "correlation_id": "c92edc01-9cb7-446c-8f51-a6ac6fffd4b0", "event": "http_response", "timestamp": "2025-12-29T00:00:46.093613Z", "level": "warning"}
_______________________________ TestActionListEndpoints.test_create_action_list_success _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F239210>
client = <httpx.AsyncClient object at 0x000001F90EE99050>

    async def test_create_action_list_success(self, client):
        """Test successful action list creation."""
        action_list_data = {
            "id": "AL-TEST-001",
            "title": "Test Action List",
            "description": "Test description",
            "status": "active",
            "owner": "list.owner",
        }
    
        response = await client.post("/api/v1/action-lists", json=action_list_data)
    
        assert response.status_code == status.HTTP_201_CREATED
        data = response.json()
>       assert data["id"] == "AL-TEST-001"
E       AssertionError: assert 'AL-0003' == 'AL-TEST-001'
E         
E         - AL-TEST-001
E         + AL-0003

tests\integration\api\test_endpoints.py:536: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "3899873e-916f-4b5f-882d-44b5dbc61141", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.191772Z", "level": "info"}
{"list_id": "AL-0003", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.198284Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 7.17, "correlation_id": "3899873e-916f-4b5f-882d-44b5dbc61141", "event": "http_response", "timestamp": "2025-12-29T00:00:46.199909Z", "level": "info"}
________________________________ TestActionListEndpoints.test_get_action_list_success _________________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F223AD0>
client = <httpx.AsyncClient object at 0x000001F90EF22D90>

    async def test_get_action_list_success(self, client):
        """Test getting action list by ID."""
        # Create action list
        action_list_data = {
            "id": "AL-GET-001",
            "title": "Get Test List",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Get action list
        response = await client.get("/api/v1/action-lists/AL-GET-001")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:554: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "8c63afff-fce2-4ffc-acda-a03b77543057", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.256193Z", "level": "info"}
{"list_id": "AL-0004", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.299912Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 46.16, "correlation_id": "8c63afff-fce2-4ffc-acda-a03b77543057", "event": "http_response", "timestamp": "2025-12-29T00:00:46.301914Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists/AL-GET-001", "query": null, "correlation_id": "6c3d5071-0250-4434-a3fe-ccec93186ef0", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.303919Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists/AL-GET-001", "status_code": 404, "duration_ms": 13.24, "correlation_id": "6c3d5071-0250-4434-a3fe-ccec93186ef0", "event": "http_response", "timestamp": "2025-12-29T00:00:46.316779Z", "level": "warning"}
___________________________________ TestActionListEndpoints.test_list_action_lists ____________________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F220E90>
client = <httpx.AsyncClient object at 0x000001F90EE992D0>

    async def test_list_action_lists(self, client):
        """Test listing action lists."""
        # Create action lists
        for i in range(3):
            action_list_data = {
                "id": f"AL-LIST-{i:03d}",
                "title": f"List {i}",
                "description": "Description",
                "status": "active",
                "owner": "owner",
            }
            await client.post("/api/v1/action-lists", json=action_list_data)
    
        # List action lists
        response = await client.get("/api/v1/action-lists")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:46', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:46', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:46', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:576: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "d80f3d4c-dd12-41ae-8dbb-8f04c148661e", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.399969Z", "level": "info"}
{"list_id": "AL-0005", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.410972Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 11.54, "correlation_id": "d80f3d4c-dd12-41ae-8dbb-8f04c148661e", "event": "http_response", "timestamp": "2025-12-29T00:00:46.411970Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "b581a380-4402-44c1-800d-da92434d9dc6", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.412969Z", "level": "info"}
{"list_id": "AL-0006", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.417969Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 5.88, "correlation_id": "b581a380-4402-44c1-800d-da92434d9dc6", "event": "http_response", "timestamp": "2025-12-29T00:00:46.418969Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "03dfe680-a87e-4137-8354-6f816c7a33fa", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.419968Z", "level": "info"}
{"list_id": "AL-0007", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.424970Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 6.35, "correlation_id": "03dfe680-a87e-4137-8354-6f816c7a33fa", "event": "http_response", "timestamp": "2025-12-29T00:00:46.425968Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "query": null, "correlation_id": "dced677c-98a7-4ebd-b91c-f8f66952ec2b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.426970Z", "level": "info"}
{"count": 3, "total": 3, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:46.433970Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 7.96, "correlation_id": "dced677c-98a7-4ebd-b91c-f8f66952ec2b", "event": "http_response", "timestamp": "2025-12-29T00:00:46.434970Z", "level": "info"}
_______________________________ TestActionListEndpoints.test_update_action_list_success _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F221550>
client = <httpx.AsyncClient object at 0x000001F91020D610>

    async def test_update_action_list_success(self, client):
        """Test updating action list returns 200."""
        # Create action list
        action_list_data = {
            "id": "AL-UPDATE-001",
            "title": "Original Title",
            "description": "Original Description",
            "status": "active",
            "owner": "owner",
        }
        create_response = await client.post("/api/v1/action-lists", json=action_list_data)
        assert create_response.status_code == status.HTTP_201_CREATED
    
        # Update action list
        update_data = {"title": "Updated Title", "description": "Updated Description"}
        response = await client.patch("/api/v1/action-lists/AL-UPDATE-001", json=update_data)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:596: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "e45b6113-bb28-4bc6-8e2b-85d289fe0e37", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.488501Z", "level": "info"}
{"list_id": "AL-0008", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.499315Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 12.14, "correlation_id": "e45b6113-bb28-4bc6-8e2b-85d289fe0e37", "event": "http_response", "timestamp": "2025-12-29T00:00:46.500873Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-UPDATE-001", "query": null, "correlation_id": "63879b37-4689-4b8c-a12b-fc1c20da132a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.502466Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-UPDATE-001", "status_code": 405, "duration_ms": 0.93, "correlation_id": "63879b37-4689-4b8c-a12b-fc1c20da132a", "event": "http_response", "timestamp": "2025-12-29T00:00:46.502999Z", "level": "warning"}
______________________________ TestActionListEndpoints.test_update_action_list_not_found ______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F221D50>
client = <httpx.AsyncClient object at 0x000001F90FD1DA10>

    async def test_update_action_list_not_found(self, client):
        """Test updating non-existent action list returns 404."""
        update_data = {"title": "Updated Title"}
        response = await client.patch("/api/v1/action-lists/AL-NONEXISTENT", json=update_data)
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 405 == 404
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests\integration\api\test_endpoints.py:606: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "PATCH", "path": "/api/v1/action-lists/AL-NONEXISTENT", "query": null, "correlation_id": "2a9f7397-5085-428d-b985-b29ec6b378d4", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.570587Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-NONEXISTENT", "status_code": 405, "duration_ms": 0.76, "correlation_id": "2a9f7397-5085-428d-b985-b29ec6b378d4", "event": "http_response", "timestamp": "2025-12-29T00:00:46.571586Z", "level": "warning"}
_______________________________ TestActionListEndpoints.test_delete_action_list_success _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F222310>
client = <httpx.AsyncClient object at 0x000001F90FD80FD0>

    async def test_delete_action_list_success(self, client):
        """Test deleting action list returns 204."""
        # Create action list
        action_list_data = {
            "id": "AL-DELETE-001",
            "title": "Delete Test",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Delete action list
        response = await client.delete("/api/v1/action-lists/AL-DELETE-001")
    
>       assert response.status_code == status.HTTP_204_NO_CONTENT
E       assert 404 == 204
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   204 = status.HTTP_204_NO_CONTENT

tests\integration\api\test_endpoints.py:623: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "ba6bd370-532f-4e88-8a49-2a889536f46f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.632265Z", "level": "info"}
{"list_id": "AL-0009", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.638851Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 7.46, "correlation_id": "ba6bd370-532f-4e88-8a49-2a889536f46f", "event": "http_response", "timestamp": "2025-12-29T00:00:46.639974Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/action-lists/AL-DELETE-001", "query": null, "correlation_id": "80041da5-92c6-485f-a84a-7e35035474b4", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.641491Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/action-lists/AL-DELETE-001", "status_code": 404, "duration_ms": 5.58, "correlation_id": "80041da5-92c6-485f-a84a-7e35035474b4", "event": "http_response", "timestamp": "2025-12-29T00:00:46.646490Z", "level": "warning"}
______________________________ TestActionListEndpoints.test_create_action_list_conflict _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000001F90F20E910>
client = <httpx.AsyncClient object at 0x000001F90FDF7F10>

    async def test_create_action_list_conflict(self, client):
        """Test duplicate action list ID returns 409."""
        action_list_data = {
            "id": "AL-CONFLICT-001",
            "title": "Conflict Test",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
    
        # Create first action list
        first_response = await client.post("/api/v1/action-lists", json=action_list_data)
        assert first_response.status_code == status.HTTP_201_CREATED
    
        # Attempt to create duplicate
        duplicate_response = await client.post("/api/v1/action-lists", json=action_list_data)
    
>       assert duplicate_response.status_code == status.HTTP_409_CONFLICT
E       assert 201 == 409
E        +  where 201 = <Response [201 Created]>.status_code
E        +  and   409 = status.HTTP_409_CONFLICT

tests\integration\api\test_endpoints.py:666: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "64f65997-acde-4da0-8d10-66a88004f8dc", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.788077Z", "level": "info"}
{"list_id": "AL-0010", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.800078Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 12.64, "correlation_id": "64f65997-acde-4da0-8d10-66a88004f8dc", "event": "http_response", "timestamp": "2025-12-29T00:00:46.801079Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "a8516f33-bd79-41d8-b55d-0f9c799d66b7", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.802080Z", "level": "info"}
{"list_id": "AL-0011", "event": "action_list_created", "timestamp": "2025-12-29T00:00:46.810079Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 9.54, "correlation_id": "a8516f33-bd79-41d8-b55d-0f9c799d66b7", "event": "http_response", "timestamp": "2025-12-29T00:00:46.812078Z", "level": "info"}
_________________________________ TestPaginationEdgeCases.test_list_tasks_with_limit __________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F20F310>
client = <httpx.AsyncClient object at 0x000001F910235290>

    async def test_list_tasks_with_limit(self, client):
        """Test tasks list respects limit parameter."""
        # Create multiple tasks
        for i in range(5):
            task_data = {
                "id": f"T-LIMIT-{i:03d}",
                "title": f"Task {i}",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": "p2",
                "primary_project": "P-001",
                "primary_sprint": "S-001",
            }
            await client.post("/api/v1/tasks", json=task_data)
    
        # Test limit parameter
        response = await client.get("/api/v1/tasks?limit=3")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:693: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "923c85c3-ae64-4f32-b678-8133f65ebf71", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.865390Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 8.12, "correlation_id": "923c85c3-ae64-4f32-b678-8133f65ebf71", "event": "http_response", "timestamp": "2025-12-29T00:00:46.872931Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "522ba24f-1b40-417d-86f0-9187fa54090b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.874929Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 4.7, "correlation_id": "522ba24f-1b40-417d-86f0-9187fa54090b", "event": "http_response", "timestamp": "2025-12-29T00:00:46.878811Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "ef26a113-6419-46ce-8a25-bb1109f2ecd7", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.880837Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 4.52, "correlation_id": "ef26a113-6419-46ce-8a25-bb1109f2ecd7", "event": "http_response", "timestamp": "2025-12-29T00:00:46.884559Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "63bc97f8-fc70-47e8-a41d-1f09d64a2868", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.886556Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 7.17, "correlation_id": "63bc97f8-fc70-47e8-a41d-1f09d64a2868", "event": "http_response", "timestamp": "2025-12-29T00:00:46.893557Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "019708ea-da5c-4873-9bc2-537db18a114c", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.895558Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 4.78, "correlation_id": "019708ea-da5c-4873-9bc2-537db18a114c", "event": "http_response", "timestamp": "2025-12-29T00:00:46.900186Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "limit=3", "correlation_id": "56670675-358f-445a-93a9-c2900677c3d6", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.901191Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:46.910792Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 10.72, "correlation_id": "56670675-358f-445a-93a9-c2900677c3d6", "event": "http_response", "timestamp": "2025-12-29T00:00:46.911820Z", "level": "info"}
_________________________________ TestPaginationEdgeCases.test_list_tasks_with_offset _________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F222A90>
client = <httpx.AsyncClient object at 0x000001F910234D10>

    async def test_list_tasks_with_offset(self, client):
        """Test tasks list respects offset parameter."""
        # Create tasks
        for i in range(5):
            task_data = {
                "id": f"T-OFFSET-{i:03d}",
                "title": f"Task {i}",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": "p2",
                "primary_project": "P-001",
                "primary_sprint": "S-001",
            }
            await client.post("/api/v1/tasks", json=task_data)
    
        # Test offset parameter
        response = await client.get("/api/v1/tasks?offset=2&limit=10")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:717: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "e4241c3a-55e7-4ecd-bc2a-9c30df0c6a35", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.974528Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 8.05, "correlation_id": "e4241c3a-55e7-4ecd-bc2a-9c30df0c6a35", "event": "http_response", "timestamp": "2025-12-29T00:00:46.982530Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "47e9b328-3e5f-4d7c-95c1-68fcc0903f78", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.983611Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 4.01, "correlation_id": "47e9b328-3e5f-4d7c-95c1-68fcc0903f78", "event": "http_response", "timestamp": "2025-12-29T00:00:46.987606Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "9f1d130e-3269-4401-a2bc-03539a457815", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.988607Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.54, "correlation_id": "9f1d130e-3269-4401-a2bc-03539a457815", "event": "http_response", "timestamp": "2025-12-29T00:00:46.994609Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "d61ad39e-5274-4ea9-9924-29340810d493", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:46.995608Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.86, "correlation_id": "d61ad39e-5274-4ea9-9924-29340810d493", "event": "http_response", "timestamp": "2025-12-29T00:00:46.999606Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "76fb58ba-a686-404b-abfb-b47b7dba6141", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.000606Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.09, "correlation_id": "76fb58ba-a686-404b-abfb-b47b7dba6141", "event": "http_response", "timestamp": "2025-12-29T00:00:47.003606Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "offset=2&limit=10", "correlation_id": "7ff13385-1e07-4721-8df0-382be236b4aa", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.004608Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:47.014609Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 11.47, "correlation_id": "7ff13385-1e07-4721-8df0-382be236b4aa", "event": "http_response", "timestamp": "2025-12-29T00:00:47.016190Z", "level": "info"}
_______________________________ TestPaginationEdgeCases.test_list_projects_empty_result _______________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F222AD0>
client = <httpx.AsyncClient object at 0x000001F910235CD0>

    async def test_list_projects_empty_result(self, client):
        """Test projects list returns empty array when no projects exist."""
        response = await client.get("/api/v1/projects?limit=10&offset=1000")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)

tests\integration\api\test_endpoints.py:725: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/projects", "query": "limit=10&offset=1000", "correlation_id": "2ee705d5-be4b-4019-ae43-241920ee5648", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.068568Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:47.080602Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 14.04, "correlation_id": "2ee705d5-be4b-4019-ae43-241920ee5648", "event": "http_response", "timestamp": "2025-12-29T00:00:47.082602Z", "level": "info"}
______________________________ TestPaginationEdgeCases.test_list_sprints_with_pagination ______________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F249890>
client = <httpx.AsyncClient object at 0x000001F90EE74BD0>

    async def test_list_sprints_with_pagination(self, client):
        """Test sprints list pagination works correctly."""
        # Create multiple sprints
        for i in range(5):
            sprint_data = {
                "id": f"S-PAGE-{i:03d}",
                "name": f"Sprint {i}",
                "goal": "Goal",
                "cadence": "weekly",
                "start_date": "2025-01-01",
                "end_date": "2025-01-07",
                "status": "active",
                "owner": "owner",
                "primary_project": "P-001",
            }
            await client.post("/api/v1/sprints", json=sprint_data)
    
        # Test pagination
        page1 = await client.get("/api/v1/sprints?limit=2&offset=0")
        page2 = await client.get("/api/v1/sprints?limit=2&offset=2")
    
        assert page1.status_code == status.HTTP_200_OK
        assert page2.status_code == status.HTTP_200_OK
    
        data1 = page1.json()
        data2 = page2.json()
>       assert isinstance(data1, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:754: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "6bf1965b-3745-491f-b078-87392c03b60c", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.135707Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 7.13, "correlation_id": "6bf1965b-3745-491f-b078-87392c03b60c", "event": "http_response", "timestamp": "2025-12-29T00:00:47.142711Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "c8df20a6-fbf9-4910-860d-c6f6afaf58d2", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.143709Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 3.41, "correlation_id": "c8df20a6-fbf9-4910-860d-c6f6afaf58d2", "event": "http_response", "timestamp": "2025-12-29T00:00:47.147710Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "c7d7ac2c-ce92-4bbc-9162-ce43bc01a673", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.148709Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 3.03, "correlation_id": "c7d7ac2c-ce92-4bbc-9162-ce43bc01a673", "event": "http_response", "timestamp": "2025-12-29T00:00:47.151707Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "4303ce16-5e62-4423-8c6d-391de4e0d18b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.151707Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 2.93, "correlation_id": "4303ce16-5e62-4423-8c6d-391de4e0d18b", "event": "http_response", "timestamp": "2025-12-29T00:00:47.154707Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "c5f08f9d-7a2e-4360-a426-12e595aa476c", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.155707Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 3.16, "correlation_id": "c5f08f9d-7a2e-4360-a426-12e595aa476c", "event": "http_response", "timestamp": "2025-12-29T00:00:47.158708Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": "limit=2&offset=0", "correlation_id": "b7f10441-2f46-4518-867c-92596887c704", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.160247Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:47.166829Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 7.46, "correlation_id": "b7f10441-2f46-4518-867c-92596887c704", "event": "http_response", "timestamp": "2025-12-29T00:00:47.167829Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "query": "limit=2&offset=2", "correlation_id": "856cfb3f-b620-47c7-8303-d8dc9fb7e2a5", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.167829Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:47.171830Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 4.52, "correlation_id": "856cfb3f-b620-47c7-8303-d8dc9fb7e2a5", "event": "http_response", "timestamp": "2025-12-29T00:00:47.172831Z", "level": "info"}
____________________________ TestPaginationEdgeCases.test_list_action_lists_limit_boundary ____________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F229410>
client = <httpx.AsyncClient object at 0x000001F90FE9AF90>

    async def test_list_action_lists_limit_boundary(self, client):
        """Test action lists list with boundary limit value."""
        response = await client.get("/api/v1/action-lists?limit=1")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:763: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/action-lists", "query": "limit=1", "correlation_id": "ec1a3650-149f-4a6b-bcbd-6102eb848a04", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.273248Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:47.280250Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 7.49, "correlation_id": "ec1a3650-149f-4a6b-bcbd-6102eb848a04", "event": "http_response", "timestamp": "2025-12-29T00:00:47.281251Z", "level": "info"}
_________________________________ TestPaginationEdgeCases.test_list_tasks_zero_offset _________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F20E9D0>
client = <httpx.AsyncClient object at 0x000001F90EF53890>

    async def test_list_tasks_zero_offset(self, client):
        """Test tasks list with explicit zero offset."""
        response = await client.get("/api/v1/tasks?offset=0&limit=10")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:772: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/tasks", "query": "offset=0&limit=10", "correlation_id": "12a5fa37-6c1a-4ec6-ae71-24c9307f4ee6", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.323000Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:47.332000Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 9.78, "correlation_id": "12a5fa37-6c1a-4ec6-ae71-24c9307f4ee6", "event": "http_response", "timestamp": "2025-12-29T00:00:47.333001Z", "level": "info"}
_______________________________ TestPaginationEdgeCases.test_list_projects_large_limit ________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F20FAD0>
client = <httpx.AsyncClient object at 0x000001F90FC04FD0>

    async def test_list_projects_large_limit(self, client):
        """Test projects list with large limit value."""
        response = await client.get("/api/v1/projects?limit=100")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)

tests\integration\api\test_endpoints.py:780: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/projects", "query": "limit=100", "correlation_id": "c67ac062-8347-4366-a084-dcce7b9b8afd", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.412921Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:47.428130Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 16.51, "correlation_id": "c67ac062-8347-4366-a084-dcce7b9b8afd", "event": "http_response", "timestamp": "2025-12-29T00:00:47.430131Z", "level": "info"}
____________________________ TestPaginationEdgeCases.test_list_sprints_default_pagination _____________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000001F90F20C790>
client = <httpx.AsyncClient object at 0x000001F90FC63110>

    async def test_list_sprints_default_pagination(self, client):
        """Test sprints list uses default pagination when not specified."""
        response = await client.get("/api/v1/sprints")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:788: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/sprints", "query": null, "correlation_id": "0478fc90-e5e0-4088-8eba-5b4053b73d98", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.502923Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:47.511436Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 9.74, "correlation_id": "0478fc90-e5e0-4088-8eba-5b4053b73d98", "event": "http_response", "timestamp": "2025-12-29T00:00:47.512436Z", "level": "info"}
_______________________________ TestFilteringEdgeCases.test_list_tasks_filter_by_status _______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F20D450>
client = <httpx.AsyncClient object at 0x000001F90FE31E10>

    async def test_list_tasks_filter_by_status(self, client):
        """Test filtering tasks by status."""
        # Create tasks with different statuses
        task_new = {
            "id": "T-FILTER-NEW",
            "title": "New Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_new)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/tasks?status=new")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:814: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "c66e6bf5-d9cf-40b1-91fc-c9816e350ee2", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.572101Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 7.84, "correlation_id": "c66e6bf5-d9cf-40b1-91fc-c9816e350ee2", "event": "http_response", "timestamp": "2025-12-29T00:00:47.579786Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "status=new", "correlation_id": "e3ba18d0-47f2-452d-9356-766a529baa69", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.580757Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:47.587812Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 7.85, "correlation_id": "e3ba18d0-47f2-452d-9356-766a529baa69", "event": "http_response", "timestamp": "2025-12-29T00:00:47.588812Z", "level": "info"}
______________________________ TestFilteringEdgeCases.test_list_tasks_filter_by_priority ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F46D0>
client = <httpx.AsyncClient object at 0x000001F90FE9E9D0>

    async def test_list_tasks_filter_by_priority(self, client):
        """Test filtering tasks by priority."""
        # Create tasks with different priorities
        task_p1 = {
            "id": "T-FILTER-P1",
            "title": "High Priority Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p1",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_p1)
    
        # Note: API may not have priority filter implemented yet
        response = await client.get("/api/v1/tasks?priority=p1")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:836: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "3a4831b0-469d-4a4f-999a-4f39cb6bd279", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.633123Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.13, "correlation_id": "3a4831b0-469d-4a4f-999a-4f39cb6bd279", "event": "http_response", "timestamp": "2025-12-29T00:00:47.637643Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "priority=p1", "correlation_id": "4f3d77f0-2c72-439a-8305-eb7818560699", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.638642Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:47.646593Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 8.1, "correlation_id": "4f3d77f0-2c72-439a-8305-eb7818560699", "event": "http_response", "timestamp": "2025-12-29T00:00:47.646593Z", "level": "info"}
_______________________________ TestFilteringEdgeCases.test_list_tasks_filter_by_owner ________________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F42D0>
client = <httpx.AsyncClient object at 0x000001F90F729C50>

    async def test_list_tasks_filter_by_owner(self, client):
        """Test filtering tasks by owner."""
        task_data = {
            "id": "T-FILTER-OWNER",
            "title": "Owned Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "test.owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Note: API may not have owner filter implemented yet
        response = await client.get("/api/v1/tasks?owner=test.owner")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:857: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "c0a0d549-113f-4f6b-953f-8cdd20b34151", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.686110Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.69, "correlation_id": "c0a0d549-113f-4f6b-953f-8cdd20b34151", "event": "http_response", "timestamp": "2025-12-29T00:00:47.692084Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "owner=test.owner", "correlation_id": "f3239722-8e44-4bf8-88b8-13e843cb5962", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.693254Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:47.700220Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 8.09, "correlation_id": "f3239722-8e44-4bf8-88b8-13e843cb5962", "event": "http_response", "timestamp": "2025-12-29T00:00:47.701220Z", "level": "info"}
_____________________________ TestFilteringEdgeCases.test_list_projects_filter_by_status ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F6250>
client = <httpx.AsyncClient object at 0x000001F90F7DA750>

    async def test_list_projects_filter_by_status(self, client):
        """Test filtering projects by status."""
        project_data = {
            "id": "P-FILTER-STATUS",
            "name": "Active Project",
            "mission": "Mission",
            "status": "active",
            "start_date": "2025-01-01",
            "owner": "owner",
        }
        await client.post("/api/v1/projects", json=project_data)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/projects?status=active")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)

tests\integration\api\test_endpoints.py:876: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "31235534-1cc3-4950-bcea-170ad04792b8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.746431Z", "level": "info"}
{"project_id": "P-FILTER-STATUS", "name": "Active Project", "event": "project_created", "timestamp": "2025-12-29T00:00:47.753130Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 7.78, "correlation_id": "31235534-1cc3-4950-bcea-170ad04792b8", "event": "http_response", "timestamp": "2025-12-29T00:00:47.754162Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "query": "status=active", "correlation_id": "8923dc6a-f8d7-44cf-8f39-b640dd012b03", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.754670Z", "level": "info"}
{"count": 1, "total": 1, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:47.761974Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 7.87, "correlation_id": "8923dc6a-f8d7-44cf-8f39-b640dd012b03", "event": "http_response", "timestamp": "2025-12-29T00:00:47.762890Z", "level": "info"}
______________________________ TestFilteringEdgeCases.test_list_projects_filter_by_owner ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F6010>
client = <httpx.AsyncClient object at 0x000001F90FE89E10>

    async def test_list_projects_filter_by_owner(self, client):
        """Test filtering projects by owner."""
        project_data = {
            "id": "P-FILTER-OWNER",
            "name": "My Project",
            "mission": "Mission",
            "status": "active",
            "start_date": "2025-01-01",
            "owner": "project.owner",
        }
        await client.post("/api/v1/projects", json=project_data)
    
        # Note: API may not have owner filter implemented yet
        response = await client.get("/api/v1/projects?owner=project.owner")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)

tests\integration\api\test_endpoints.py:895: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "59e7fb6f-8b2e-42ab-9d50-1ac84b77c78c", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.802947Z", "level": "info"}
{"project_id": "P-FILTER-OWNER", "name": "My Project", "event": "project_created", "timestamp": "2025-12-29T00:00:47.813905Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 12.52, "correlation_id": "59e7fb6f-8b2e-42ab-9d50-1ac84b77c78c", "event": "http_response", "timestamp": "2025-12-29T00:00:47.814905Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "query": "owner=project.owner", "correlation_id": "bf16b12f-f4cf-4e32-9d04-215c699a754b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.815904Z", "level": "info"}
{"count": 1, "total": 1, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:47.824132Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 8.69, "correlation_id": "bf16b12f-f4cf-4e32-9d04-215c699a754b", "event": "http_response", "timestamp": "2025-12-29T00:00:47.825175Z", "level": "info"}
______________________________ TestFilteringEdgeCases.test_list_sprints_filter_by_status ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F6510>
client = <httpx.AsyncClient object at 0x000001F91033D010>

    async def test_list_sprints_filter_by_status(self, client):
        """Test filtering sprints by status."""
        sprint_data = {
            "id": "S-FILTER-STATUS",
            "name": "Active Sprint",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/sprints?status=active")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:917: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "d1e51977-6693-4e68-8e14-119e3c6e9cc8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.919795Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 7.34, "correlation_id": "d1e51977-6693-4e68-8e14-119e3c6e9cc8", "event": "http_response", "timestamp": "2025-12-29T00:00:47.927797Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": "status=active", "correlation_id": "3c44304f-d408-46bf-a2ad-8c7c63d3e096", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:47.928797Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:47.965322Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 37.49, "correlation_id": "3c44304f-d408-46bf-a2ad-8c7c63d3e096", "event": "http_response", "timestamp": "2025-12-29T00:00:47.966319Z", "level": "info"}
_____________________________ TestFilteringEdgeCases.test_list_sprints_filter_by_project ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F20C710>
client = <httpx.AsyncClient object at 0x000001F90FC37BD0>

    async def test_list_sprints_filter_by_project(self, client):
        """Test filtering sprints by project."""
        sprint_data = {
            "id": "S-FILTER-PROJ",
            "name": "Project Sprint",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Note: API may not have project filter implemented yet
        response = await client.get("/api/v1/sprints?project=P-001")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:939: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "34523b1e-10cb-4aa9-acd9-e64a4f60fa0a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.053228Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 12.93, "correlation_id": "34523b1e-10cb-4aa9-acd9-e64a4f60fa0a", "event": "http_response", "timestamp": "2025-12-29T00:00:48.066237Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": "project=P-001", "correlation_id": "db2b555b-f523-4fd3-9852-c6cf501e6418", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.068353Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:48.079394Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 12.67, "correlation_id": "db2b555b-f523-4fd3-9852-c6cf501e6418", "event": "http_response", "timestamp": "2025-12-29T00:00:48.080393Z", "level": "info"}
___________________________ TestFilteringEdgeCases.test_list_action_lists_filter_by_status ____________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F221810>
client = <httpx.AsyncClient object at 0x000001F91035A2D0>

    async def test_list_action_lists_filter_by_status(self, client):
        """Test filtering action lists by status."""
        action_list_data = {
            "id": "AL-FILTER-STATUS",
            "title": "Active List",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/action-lists?status=active")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:48', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:957: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "8726c123-ee88-4ba3-aba4-49e1f34c61cb", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.131575Z", "level": "info"}
{"list_id": "AL-0012", "event": "action_list_created", "timestamp": "2025-12-29T00:00:48.138091Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 7.13, "correlation_id": "8726c123-ee88-4ba3-aba4-49e1f34c61cb", "event": "http_response", "timestamp": "2025-12-29T00:00:48.139092Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "query": "status=active", "correlation_id": "3e12a0c8-1b5d-4012-a355-d54645f9a604", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.140130Z", "level": "info"}
{"count": 1, "total": 1, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:48.146644Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 7.59, "correlation_id": "3e12a0c8-1b5d-4012-a355-d54645f9a604", "event": "http_response", "timestamp": "2025-12-29T00:00:48.147645Z", "level": "info"}
_______________________________ TestFilteringEdgeCases.test_list_tasks_multiple_filters _______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F5D50>
client = <httpx.AsyncClient object at 0x000001F90FBC6390>

    async def test_list_tasks_multiple_filters(self, client):
        """Test combining multiple filters."""
        task_data = {
            "id": "T-MULTI-FILTER",
            "title": "Multi Filter Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "filter.owner",
            "priority": "p1",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Note: API may not have multiple filter support yet
        response = await client.get("/api/v1/tasks?priority=p1&owner=filter.owner")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:978: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "35654c94-0671-474e-b4bb-ab264f8ac7c8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.189034Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.29, "correlation_id": "35654c94-0671-474e-b4bb-ab264f8ac7c8", "event": "http_response", "timestamp": "2025-12-29T00:00:48.195033Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "priority=p1&owner=filter.owner", "correlation_id": "987563eb-255d-49b0-93f9-0c7cbc093a63", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.196034Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:48.204848Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 9.33, "correlation_id": "987563eb-255d-49b0-93f9-0c7cbc093a63", "event": "http_response", "timestamp": "2025-12-29T00:00:48.205845Z", "level": "info"}
________________________________ TestFilteringEdgeCases.test_list_projects_no_filters _________________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F60D0>
client = <httpx.AsyncClient object at 0x000001F90FBB1A50>

    async def test_list_projects_no_filters(self, client):
        """Test projects list without any filters returns all projects."""
        response = await client.get("/api/v1/projects")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)

tests\integration\api\test_endpoints.py:986: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/projects", "query": null, "correlation_id": "dfab6846-675c-4c32-a37d-01caaf961705", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.255238Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:48.263239Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 9.1, "correlation_id": "dfab6846-675c-4c32-a37d-01caaf961705", "event": "http_response", "timestamp": "2025-12-29T00:00:48.264754Z", "level": "info"}
___________________________ TestFilteringEdgeCases.test_list_sprints_invalid_filter_ignored ___________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F4790>
client = <httpx.AsyncClient object at 0x000001F90FAE7F10>

    async def test_list_sprints_invalid_filter_ignored(self, client):
        """Test invalid filter parameter is ignored."""
        response = await client.get("/api/v1/sprints?invalid_param=value")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:994: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/sprints", "query": "invalid_param=value", "correlation_id": "4712f6ce-c372-4483-88fa-3f332e314614", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.310779Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:48.317780Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 7.2, "correlation_id": "4712f6ce-c372-4483-88fa-3f332e314614", "event": "http_response", "timestamp": "2025-12-29T00:00:48.317780Z", "level": "info"}
__________________________ TestFilteringEdgeCases.test_list_action_lists_empty_filter_value ___________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000001F90F1F6ED0>
client = <httpx.AsyncClient object at 0x000001F90FB06E50>

    async def test_list_action_lists_empty_filter_value(self, client):
        """Test empty filter value."""
        response = await client.get("/api/v1/action-lists?status=")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:1002: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/action-lists", "query": "status=", "correlation_id": "7ffc6368-3ec8-4069-901d-9c2262bcced4", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.364514Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:48.375214Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 12.26, "correlation_id": "7ffc6368-3ec8-4069-901d-9c2262bcced4", "event": "http_response", "timestamp": "2025-12-29T00:00:48.376639Z", "level": "info"}
______________________________ TestValidationEdgeCases.test_create_task_max_title_length ______________________________

self = <test_endpoints.TestValidationEdgeCases object at 0x000001F90F1F7D10>
client = <httpx.AsyncClient object at 0x000001F90FB2D590>

    async def test_create_task_max_title_length(self, client):
        """Test task creation with maximum title length (500 chars)."""
        task_data = {
            "id": "T-MAX-TITLE",
            "title": "x" * 500,  # Max allowed length
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
    
        response = await client.post("/api/v1/tasks", json=task_data)
    
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:1023: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "b9525314-d308-40ae-950d-162d359237cb", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.422706Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.82, "correlation_id": "b9525314-d308-40ae-950d-162d359237cb", "event": "http_response", "timestamp": "2025-12-29T00:00:48.429218Z", "level": "warning"}
___________________________ TestValidationEdgeCases.test_update_action_list_invalid_status ____________________________

self = <test_endpoints.TestValidationEdgeCases object at 0x000001F90F1FEB90>
client = <httpx.AsyncClient object at 0x000001F90FB643D0>

    async def test_update_action_list_invalid_status(self, client):
        """Test action list update with invalid status enum.
    
        Note: API currently accepts invalid status values in PATCH requests
        due to lenient Pydantic validation. This test verifies endpoint accepts
        the update gracefully (200 OK) rather than strictly validating (422).
        """
        # Create action list first
        action_list_data = {
            "id": "AL-INVALID-STATUS",
            "title": "List",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Update with invalid status (API accepts this currently)
        update_data = {"status": "invalid_status"}
        response = await client.patch("/api/v1/action-lists/AL-INVALID-STATUS", json=update_data)
    
        # API accepts the update (lenient validation in PATCH)
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:1190: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "e47aef15-653d-457a-8b25-5890d43c80fa", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.760985Z", "level": "info"}
{"list_id": "AL-0013", "event": "action_list_created", "timestamp": "2025-12-29T00:00:48.767984Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 7.28, "correlation_id": "e47aef15-653d-457a-8b25-5890d43c80fa", "event": "http_response", "timestamp": "2025-12-29T00:00:48.769072Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-INVALID-STATUS", "query": null, "correlation_id": "d2a7b652-3de7-4f23-85b7-ed9eaf48e16e", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:48.769584Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-INVALID-STATUS", "status_code": 405, "duration_ms": 0.42, "correlation_id": "d2a7b652-3de7-4f23-85b7-ed9eaf48e16e", "event": "http_response", "timestamp": "2025-12-29T00:00:48.769584Z", "level": "warning"}
_______________________________________ TestBaseRepository.test_create_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BEB50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91016F850>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_create_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity creation."""
        # Arrange
        await async_session.commit()  # Ensure clean state
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:29: TypeError
_______________________________________ TestBaseRepository.test_create_conflict _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BF1D0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91017FE90>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_create_conflict(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test create with duplicate ID returns ConflictError."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:54: TypeError
_____________________________________ TestBaseRepository.test_find_by_id_success ______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BCE90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F9101B8C10>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_id_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful find by ID."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:110: TypeError
____________________________________ TestBaseRepository.test_find_by_id_not_found _____________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BDB50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F9101B8190>

    async def test_find_by_id_not_found(self, async_session: AsyncSession):
        """Test find by ID returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:128: TypeError
______________________________________ TestBaseRepository.test_find_all_success _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BDED0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F9100723D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_all_success(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test find all with pagination."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:149: TypeError
_____________________________ TestBaseRepository.test_find_all_validation_limit_exceeded ______________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BF910>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F90F172590>

    async def test_find_all_validation_limit_exceeded(self, async_session: AsyncSession):
        """Test find all with limit > 1000 returns ValidationError."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:199: TypeError
_______________________________________ TestBaseRepository.test_update_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BC850>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F9101B8F10>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_update_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity update."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:218: TypeError
______________________________________ TestBaseRepository.test_update_not_found _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BC1D0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91018C610>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_update_not_found(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test update returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:243: TypeError
_______________________________________ TestBaseRepository.test_delete_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F0BC890>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91019CBD0>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_delete_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity deletion."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:295: TypeError
______________________________________ TestBaseRepository.test_delete_not_found _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F099150>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91010B3D0>

    async def test_delete_not_found(self, async_session: AsyncSession):
        """Test delete returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:315: TypeError
_________________________________________ TestBaseRepository.test_exists_true _________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F099250>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910136D50>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_exists_true(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test exists returns True when entity exists."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:334: TypeError
________________________________________ TestBaseRepository.test_exists_false _________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F099590>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910160CD0>

    async def test_exists_false(self, async_session: AsyncSession):
        """Test exists returns False when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:350: TypeError
____________________________________________ TestBaseRepository.test_count ____________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001F90F09A4D0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F90F7ADB90>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_count(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test count returns correct number of entities."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:367: TypeError
______________________________________ TestProjectRepository.test_find_by_status ______________________________________

self = <test_repositories.TestProjectRepository object at 0x000001F90F20CDD0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F9101B39D0>

    async def test_find_by_status(self, async_session: AsyncSession):
        """Test finding projects by status."""
        from taskman_api.models.project import Project
    
        repo = ProjectRepository(async_session)
    
        # Create projects with different statuses
        for i, status in enumerate([ProjectStatus.ACTIVE, ProjectStatus.PAUSED, ProjectStatus.ACTIVE]):
>           project = Project(
                id=f"P-TEST-{i:03d}",
                name=f"Project {i}",
                mission=f"Mission {i}",
                status=status,
                start_date=date(2025, 1, 1),
                owner="owner",
                sponsors=[],
                stakeholders=[],
                repositories=[],
                comms_channels=[],
                okrs=[],
                kpis=[],
                roadmap=[],
                risks=[],
                assumptions=[],
                constraints=[],
                dependencies_external=[],
                sprints=[],
                related_projects=[],
                shared_components=[],
                compliance_requirements=[],
                governance={},
                success_metrics=[],
                mpv_policy={},
                observability={},
            )

tests\unit\db\repositories\test_repositories.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-000', name='Project 0', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________________________ TestProjectRepository.test_find_active_projects ___________________________________

self = <test_repositories.TestProjectRepository object at 0x000001F90F20D650>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910335BD0>

    async def test_find_active_projects(self, async_session: AsyncSession):
        """Test finding all active projects."""
        from taskman_api.models.project import Project
    
        repo = ProjectRepository(async_session)
    
>       project = Project(
            id="P-ACTIVE-001",
            name="Active Project",
            mission="Mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            owner="owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=[],
            related_projects=[],
            shared_components=[],
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            observability={},
        )

tests\unit\db\repositories\test_repositories.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-ACTIVE-001', name='Active Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________________ TestSprintRepository.test_find_by_status _______________________________________

self = <test_repositories.TestSprintRepository object at 0x000001F90F1DBF90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F90F87BED0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>

    async def test_find_by_status(self, async_session: AsyncSession, sample_project):
        """Test finding sprints by status."""
        from taskman_api.core.enums import SprintCadence
        from taskman_api.models.sprint import Sprint
    
        async_session.add(sample_project)
        await async_session.commit()
    
        repo = SprintRepository(async_session)
    
        # Create sprints with different statuses
        for i, status in enumerate([SprintStatus.ACTIVE, SprintStatus.PLANNED, SprintStatus.ACTIVE]):
>           sprint = Sprint(
                id=f"S-TEST-{i:03d}",
                name=f"Sprint {i}",
                goal=f"Goal {i}",
                cadence=SprintCadence.BIWEEKLY,
                start_date=date(2025, 1, 1),
                end_date=date(2025, 1, 14),
                status=status,
                owner="owner",
                primary_project=sample_project.id,
                tasks=[],
                imported_tasks=[],
                related_projects=[],
                definition_of_done=[],
                dependencies={},
                scope_changes=[],
                risks=[],
                ceremonies={},
                metrics={},
                observability={},
            )

tests\unit\db\repositories\test_repositories.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-000', name='Sprint 0', status='SprintStatus.ACTIVE')>
kwargs = {'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'ceremonies': {}, 'definition_of_done': [], 'dependencies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________________ TestSprintRepository.test_find_active_sprints ____________________________________

self = <test_repositories.TestSprintRepository object at 0x000001F90F1DA410>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F90FA385D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>

    async def test_find_active_sprints(self, async_session: AsyncSession, sample_project):
        """Test finding all active sprints."""
        from taskman_api.core.enums import SprintCadence
        from taskman_api.models.sprint import Sprint
    
        async_session.add(sample_project)
        await async_session.commit()
    
        repo = SprintRepository(async_session)
    
>       sprint = Sprint(
            id="S-ACTIVE-001",
            name="Active Sprint",
            goal="Goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="owner",
            primary_project=sample_project.id,
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            observability={},
        )

tests\unit\db\repositories\test_repositories.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-ACTIVE-001', name='Active Sprint', status='SprintStatus.ACTIVE')>
kwargs = {'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'ceremonies': {}, 'definition_of_done': [], 'dependencies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________________ TestActionListRepository.test_find_by_owner _____________________________________

self = <test_repositories.TestActionListRepository object at 0x000001F90F1D9450>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F90FBC02D0>

    async def test_find_by_owner(self, async_session: AsyncSession):
        """Test finding action lists by owner."""
        from taskman_api.models.action_list import ActionList
    
        repo = ActionListRepository(async_session)
    
        # Create action lists with different owners
        for i, owner in enumerate(["alice", "bob", "alice"]):
>           action_list = ActionList(
                id=f"AL-TEST-{i:03d}",
                title=f"List {i}",
                status="active",
                owner=owner,
                items=[],
                tags=[],
                evidence_refs=[],
                extra_metadata={},
                parent_deletion_note={},
            )

tests\unit\db\repositories\test_repositories.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-000', name=None, status=None)>
kwargs = {'evidence_refs': [], 'extra_metadata': {}, 'id': 'AL-TEST-000', 'items': [], ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________________ TestActionListRepository.test_find_orphaned _____________________________________

self = <test_repositories.TestActionListRepository object at 0x000001F90F1DB910>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F90F863C50>

    async def test_find_orphaned(self, async_session: AsyncSession):
        """Test finding orphaned action lists."""
        from taskman_api.models.action_list import ActionList
    
        repo = ActionListRepository(async_session)
    
        # Create orphaned action list
>       orphaned = ActionList(
            id="AL-ORPHAN-001",
            title="Orphaned List",
            status="active",
            items=[],
            tags=[],
            evidence_refs=[],
            extra_metadata={},
            parent_deletion_note={},
        )

tests\unit\db\repositories\test_repositories.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-ORPHAN-001', name=None, status=None)>
kwargs = {'evidence_refs': [], 'extra_metadata': {}, 'id': 'AL-ORPHAN-001', 'items': [], ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________________ TestTaskRepository.test_find_by_status ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F07BE50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91033ABD0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_status(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by status."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.NEW, TaskStatus.IN_PROGRESS, TaskStatus.NEW]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_status(TaskStatus.NEW)
                       ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_status'

tests\unit\db\repositories\test_task_repository.py:65: AttributeError
______________________________________ TestTaskRepository.test_find_by_priority _______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F078A10>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F9101627D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_priority(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by priority."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different priorities
        for i, priority in enumerate([Priority.P0, Priority.P1, Priority.P0]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_priority(Priority.P0)
                       ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_priority'

tests\unit\db\repositories\test_task_repository.py:119: AttributeError
________________________________________ TestTaskRepository.test_find_by_owner ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F078D90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910089610>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_owner(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by owner."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different owners
        for i, owner in enumerate(["alice", "bob", "alice"]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner=owner,
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_owner("alice")
                       ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_owner'

tests\unit\db\repositories\test_task_repository.py:173: AttributeError
_______________________________________ TestTaskRepository.test_find_by_project _______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F07AC10>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91033B990>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_project(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by project."""
        # Arrange
        repo = TaskRepository(async_session)
    
        # Create second project
        from datetime import date
    
        from taskman_api.core.enums import ProjectStatus
        from taskman_api.models.project import Project
    
>       project2 = Project(
            id="P-TEST-002",
            name="Project 2",
            mission="Mission 2",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            owner="owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=[],
            related_projects=[],
            shared_components=[],
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            observability={},
        )

tests\unit\db\repositories\test_task_repository.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-002', name='Project 2', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ TestTaskRepository.test_find_by_project_with_status_filter ______________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F079250>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910691E50>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_project_with_status_filter(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by project with status filter."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.NEW, TaskStatus.IN_PROGRESS, TaskStatus.NEW]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_project(sample_project.id, status=TaskStatus.NEW)
                       ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_project'

tests\unit\db\repositories\test_task_repository.py:317: AttributeError
_______________________________________ TestTaskRepository.test_find_by_sprint ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F079510>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910677D50>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_sprint(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by sprint."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks
        for i in range(3):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_sprint(sample_sprint.id)
                       ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_sprint'

tests\unit\db\repositories\test_task_repository.py:371: AttributeError
_________________________________ TestTaskRepository.test_find_by_status_and_priority _________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F07ADD0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F910596A50>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_status_and_priority(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by status and priority (composite index)."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with various combinations
        combos = [
            (TaskStatus.NEW, Priority.P0),
            (TaskStatus.NEW, Priority.P1),
            (TaskStatus.IN_PROGRESS, Priority.P0),
            (TaskStatus.NEW, Priority.P0),
        ]
    
        for i, (status, priority) in enumerate(combos):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_status_and_priority(TaskStatus.NEW, Priority.P0)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_status_and_priority'

tests\unit\db\repositories\test_task_repository.py:431: AttributeError
_____________________________________ TestTaskRepository.test_find_blocked_tasks ______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F078210>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91056F890>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_blocked_tasks(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding all blocked tasks."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.BLOCKED, TaskStatus.NEW, TaskStatus.BLOCKED]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_blocked_tasks()
                       ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_blocked_tasks'

tests\unit\db\repositories\test_task_repository.py:485: AttributeError
__________________________________ TestTaskRepository.test_find_high_priority_tasks ___________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001F90F061450>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001F91061D0D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_high_priority_tasks(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding P0 and P1 (critical/high priority) tasks."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different priorities
        for i, priority in enumerate([Priority.P0, Priority.P1, Priority.P2, Priority.P0]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_high_priority_tasks()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_high_priority_tasks'

tests\unit\db\repositories\test_task_repository.py:539: AttributeError
________________________________ TestProjectSchemas.test_project_create_request_valid _________________________________

self = <test_schemas.TestProjectSchemas object at 0x000001F90ED78910>

    def test_project_create_request_valid(self):
        """Test creating a valid project create request."""
        data = {
            "id": "P-TEST-001",
            "name": "Test Project",
            "mission": "Test mission",
            "start_date": date(2025, 1, 1),
            "owner": "test.owner",
        }
    
        request = ProjectCreateRequest(**data)
        assert request.id == "P-TEST-001"
>       assert request.status == ProjectStatus.DISCOVERY  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <ProjectStatu...G: 'planning'> == <ProjectStatu...: 'discovery'>
E         
E         - discovery
E         + planning

tests\unit\schemas\test_schemas.py:36: AssertionError
_________________________________ TestSprintSchemas.test_sprint_create_request_valid __________________________________

self = <test_schemas.TestSprintSchemas object at 0x000001F90ED78310>

    def test_sprint_create_request_valid(self):
        """Test creating a valid sprint create request."""
        data = {
            "id": "S-2025-01",
            "name": "Sprint 1",
            "goal": "Sprint goal",
            "cadence": SprintCadence.BIWEEKLY,
            "start_date": date(2025, 1, 1),
            "end_date": date(2025, 1, 14),
            "owner": "scrum.master",
            "primary_project": "P-TEST",
        }
    
        request = SprintCreateRequest(**data)
        assert request.id == "S-2025-01"
>       assert request.status == SprintStatus.PLANNED  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <SprintStatus...G: 'planning'> == <SprintStatus...ED: 'planned'>
E         
E         - planned
E         + planning

tests\unit\schemas\test_schemas.py:134: AssertionError
_________________________________ TestSprintSchemas.test_sprint_response_with_metrics _________________________________

self = <test_schemas.TestSprintSchemas object at 0x000001F90F1FD150>

    def test_sprint_response_with_metrics(self):
        """Test sprint response with metrics."""
        data = {
            "id": "S-TEST",
            "name": "Sprint",
            "goal": "Goal",
            "cadence": SprintCadence.BIWEEKLY,
            "start_date": date(2025, 1, 1),
            "end_date": date(2025, 1, 14),
            "status": SprintStatus.ACTIVE,
            "owner": "owner",
            "primary_project": "P-TEST",
            "tasks": [],
            "imported_tasks": [],
            "related_projects": [],
            "velocity_target_points": 20.0,
            "committed_points": 18.0,
            "actual_points": 16.0,
            "carried_over_points": 2.0,
            "definition_of_done": [],
            "dependencies": {},
            "scope_changes": [],
            "risks": [],
            "ceremonies": {},
            "metrics": {"throughput": 16, "predictability_pct": 88.9},
            "timezone": "America/New_York",
            "observability": {},
            "created_at": datetime(2025, 1, 1),
            "updated_at": datetime(2025, 1, 1),
        }
    
>       response = SprintResponse(**data)
                   ^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for SprintResponse
E       dependencies
E         Input should be a valid list [type=list_type, input_value={}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.12/v/list_type

tests\unit\schemas\test_schemas.py:236: ValidationError
______________________________ TestActionListSchemas.test_action_list_soft_delete_fields ______________________________

self = <test_schemas.TestActionListSchemas object at 0x000001F90ED86A10>

    def test_action_list_soft_delete_fields(self):
        """Test action list soft delete fields."""
        data = {
            "id": "AL-TEST",
            "title": "Action List",
            "status": "deleted",
            "parent_deleted_at": datetime(2025, 1, 1, 12, 0, 0),
            "parent_deletion_note": {"reason": "Project closed"},
            "items": [],
        }
    
>       request = ActionListCreateRequest(**data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ActionListCreate
E       status
E         Input should be 'active' or 'archived' [type=enum, input_value='deleted', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/enum

tests\unit\schemas\test_schemas.py:284: ValidationError
_______________________________ TestBaseSchemaConfiguration.test_strict_type_validation _______________________________

self = <test_schemas.TestBaseSchemaConfiguration object at 0x000001F90ED845D0>

    def test_strict_type_validation(self):
        """Test that type coercion is enabled (strict=False)."""
>       from taskman_api.schemas.base import BaseSchema
E       ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)

tests\unit\schemas\test_schemas.py:336: ImportError
______________________________ TestBaseSchemaConfiguration.test_from_attributes_orm_mode ______________________________

self = <test_schemas.TestBaseSchemaConfiguration object at 0x000001F90ED84790>

    def test_from_attributes_orm_mode(self):
        """Test ORM mode (from_attributes) is enabled."""
>       from taskman_api.schemas.base import BaseSchema
E       ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)

tests\unit\schemas\test_schemas.py:348: ImportError
____________________________ TestTaskCreateRequest.test_task_id_pattern_validation_failure ____________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001F90F194DD0>

    def test_task_id_pattern_validation_failure(self):
        """Test task ID pattern validation with invalid patterns."""
        # Test pattern validation errors
        pattern_invalid_ids = [
            "TASK-001",  # Wrong prefix
            "T001",  # Missing hyphen
            "T-",  # No ID part
            "T-@invalid",  # Invalid character
        ]
    
        for task_id in pattern_invalid_ids:
            data = {
                "id": task_id,
                "title": "Test",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": Priority.P2,
                "primary_project": "P-TEST",
                "primary_sprint": "S-TEST",
            }
    
            with pytest.raises(ValidationError) as exc_info:
                TaskCreateRequest(**data)
    
            errors = exc_info.value.errors()
            assert any("pattern" in str(err).lower() for err in errors)
    
        # Test min_length validation (empty string)
        data = {
            "id": "",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P2,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
        }
        with pytest.raises(ValidationError) as exc_info:
            TaskCreateRequest(**data)
        errors = exc_info.value.errors()
>       assert any("at least 1 character" in str(err).lower() for err in errors)
E       assert False
E        +  where False = any(<generator object TestTaskCreateRequest.test_task_id_pattern_validation_failure.<locals>.<genexpr> at 0x000001F9105A5EE0>)

tests\unit\schemas\test_task_schemas.py:104: AssertionError
________________________________ TestTaskCreateRequest.test_required_fields_validation ________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001F90F195610>

    def test_required_fields_validation(self):
        """Test that required fields are validated."""
        # Missing required fields
        data = {
            "id": "T-TEST-001",
        }
    
        with pytest.raises(ValidationError) as exc_info:
            TaskCreateRequest(**data)
    
        errors = exc_info.value.errors()
        required_fields = {"title", "summary", "description", "owner", "priority", "primary_project", "primary_sprint"}
        error_fields = {err["loc"][0] for err in errors}
    
>       assert required_fields.issubset(error_fields)
E       AssertionError: assert False
E        +  where False = <built-in method issubset of set object at 0x000001F90F8A9540>({'description', 'owner', 'primary_project', 'primary_sprint', 'summary', 'title'})
E        +    where <built-in method issubset of set object at 0x000001F90F8A9540> = {'description', 'owner', 'primary_project', 'primary_sprint', 'priority', 'summary', ...}.issubset

tests\unit\schemas\test_task_schemas.py:120: AssertionError
________________________________ TestTaskCreateRequest.test_business_value_score_range ________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001F90F195350>

    def test_business_value_score_range(self):
        """Test business_value_score must be 0-10."""
        # Test below range
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P2,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "business_value_score": -1,
        }
    
        with pytest.raises(ValidationError):
            TaskCreateRequest(**data)
    
        # Test above range
        data["business_value_score"] = 11
    
>       with pytest.raises(ValidationError):
E       Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>

tests\unit\schemas\test_task_schemas.py:182: Failed
__________________________________ TestTaskCreateRequest.test_enum_field_validation ___________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001F90F195E50>

    def test_enum_field_validation(self):
        """Test enum field validation."""
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P1,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "status": TaskStatus.IN_PROGRESS,
            "severity": Severity.SEV2,
            "shape": GeometryShape.CIRCLE,
        }
    
>       request = TaskCreateRequest(**data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskCreate
E       severity
E         Input should be 'critical', 'high', 'medium' or 'low' [type=enum, input_value=<Severity.SEV2: 'sev2'>, input_type=Severity]
E           For further information visit https://errors.pydantic.dev/2.12/v/enum

tests\unit\schemas\test_task_schemas.py:206: ValidationError
____________________________________ TestTaskResponse.test_response_from_orm_model ____________________________________

self = <test_task_schemas.TestTaskResponse object at 0x000001F90F158A90>

    def test_response_from_orm_model(self):
        """Test creating response from ORM model."""
        from taskman_api.models.task import Task
    
        # Create mock ORM task
        task = Task(
            id="T-TEST-001",
            title="Test Task",
            summary="Summary",
            description="Description",
            status=TaskStatus.NEW,
            owner="owner",
            assignees=[],
            priority=Priority.P1,
            primary_project="P-TEST",
            primary_sprint="S-TEST",
            related_projects=[],
            related_sprints=[],
            parents=[],
            depends_on=[],
            blocks=[],
            blockers=[],
            acceptance_criteria=[],
            definition_of_done=[],
            quality_gates={},
            verification={},
            actions_taken=[],
            labels=[],
            related_links=[],
            risks=[],
            observability={},
        )
    
        # Set timestamps manually (normally set by TimestampMixin)
        task.created_at = datetime(2025, 1, 1, 12, 0, 0)
        task.updated_at = datetime(2025, 1, 1, 12, 0, 0)
    
        # Create response from ORM model
>       response = TaskResponse.model_validate(task)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E       automation_candidate
E         Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/bool_type

tests\unit\schemas\test_task_schemas.py:313: ValidationError
____________________________________ TestTaskResponse.test_response_serialization _____________________________________

self = <test_task_schemas.TestTaskResponse object at 0x000001F90F060210>

    def test_response_serialization(self):
        """Test response can be serialized to dict/JSON."""
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "status": TaskStatus.NEW,
            "owner": "owner",
            "assignees": [],
            "priority": Priority.P1,
            "severity": None,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "related_projects": [],
            "related_sprints": [],
            "estimate_points": None,
            "actual_time_hours": None,
            "due_at": None,
            "parents": [],
            "depends_on": [],
            "blocks": [],
            "blockers": [],
            "acceptance_criteria": [],
            "definition_of_done": [],
            "quality_gates": {},
            "verification": {},
            "actions_taken": [],
            "labels": [],
            "related_links": [],
            "shape": None,
            "stage": None,
            "work_type": None,
            "work_stream": None,
            "business_value_score": None,
            "cost_of_delay_score": None,
            "automation_candidate": None,
            "cycle_time_days": None,
            "risks": [],
            "observability": {},
            "created_at": datetime(2025, 1, 1, 12, 0, 0),
            "updated_at": datetime(2025, 1, 1, 12, 0, 0),
        }
    
>       response = TaskResponse(**data)
                   ^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E       automation_candidate
E         Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/bool_type

tests\unit\schemas\test_task_schemas.py:364: ValidationError
______________________________________ TestBaseServiceCreate.test_create_success ______________________________________

self = <test_base_service.TestBaseServiceCreate object at 0x000001F90F182990>
mock_task_repository = <Mock id='2169233113936'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_create_success(self, mock_task_repository, sample_task):
        """Test successful entity creation."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        request = TaskCreateRequest(
            id="T-TEST-001",
            title="Test Task",
            summary="Summary",
            description="Description",
            owner="test.owner",
            priority=Priority.P1,
            primary_project="P-TEST-001",
            primary_sprint="S-TEST-001",
        )
    
        # Act
        result = await service.create(request)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910734210>, Ok)

tests\unit\services\test_base_service.py:41: AssertionError
__________________________________ TestBaseServiceCreate.test_create_conflict_error ___________________________________

self = <test_base_service.TestBaseServiceCreate object at 0x000001F90F180090>
mock_task_repository = <Mock id='2169234478928'>

    @pytest.mark.asyncio
    async def test_create_conflict_error(self, mock_task_repository):
        """Test creation with duplicate ID returns ConflictError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        request = TaskCreateRequest(
            id="T-DUPLICATE",
            title="Task",
            summary="Summary",
            description="Description",
            owner="owner",
            priority=Priority.P1,
            primary_project="P-001",
            primary_sprint="S-001",
        )
    
        # Mock repository to return ConflictError
        mock_task_repository.create = AsyncMock(
            return_value=Err(
                ConflictError(
                    message="Entity already exists",
                    entity_type="Task",
                    entity_id="T-DUPLICATE",
                )
            )
        )
    
        # Act
        result = await service.create(request)
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, ConflictError)
E       assert False
E        +  where False = isinstance(AppError("9 validation errors for TaskResponse\nid\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ntitle\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nsummary\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ndescription\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nstatus\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nowner\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\npriority\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_project\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_sprint\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing"), ConflictError)

tests\unit\services\test_base_service.py:80: AssertionError
_________________________________________ TestBaseServiceGet.test_get_success _________________________________________

self = <test_base_service.TestBaseServiceGet object at 0x000001F90F183710>
mock_task_repository = <Mock id='2169234284688'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_success(self, mock_task_repository, sample_task):
        """Test successful entity retrieval."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.get("T-TEST-001")
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91078A890>, Ok)

tests\unit\services\test_base_service.py:97: AssertionError
________________________________________ TestBaseServiceGet.test_get_not_found ________________________________________

self = <test_base_service.TestBaseServiceGet object at 0x000001F90EDA4310>
mock_task_repository = <Mock id='2169234282256'>

    @pytest.mark.asyncio
    async def test_get_not_found(self, mock_task_repository):
        """Test get with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return NotFoundError
        mock_task_repository.find_by_id = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.get("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:126: AssertionError
______________________________________ TestBaseServiceUpdate.test_update_success ______________________________________

self = <test_base_service.TestBaseServiceUpdate object at 0x000001F90EDA5450>
mock_task_repository = <Mock id='2169234170640'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_update_success(self, mock_task_repository, sample_task):
        """Test successful entity update."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        update_request = TaskUpdateRequest(title="Updated Title")
    
        # Act
        result = await service.update("T-TEST-001", update_request)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91078ECD0>, Ok)

tests\unit\services\test_base_service.py:144: AssertionError
_____________________________________ TestBaseServiceUpdate.test_update_not_found _____________________________________

self = <test_base_service.TestBaseServiceUpdate object at 0x000001F90EDA6F90>
mock_task_repository = <Mock id='2169234634000'>

    @pytest.mark.asyncio
    async def test_update_not_found(self, mock_task_repository):
        """Test update with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        update_request = TaskUpdateRequest(title="Updated")
    
        # Mock repository to return NotFoundError
        mock_task_repository.find_by_id = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.update("T-NONEXISTENT", update_request)
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:174: AssertionError
______________________________________ TestBaseServiceDelete.test_delete_success ______________________________________

self = <test_base_service.TestBaseServiceDelete object at 0x000001F90EDA4790>
mock_task_repository = <Mock id='2169234930448'>

    @pytest.mark.asyncio
    async def test_delete_success(self, mock_task_repository):
        """Test successful entity deletion."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.delete("T-TEST-001")
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910798050>, Ok)

tests\unit\services\test_base_service.py:191: AssertionError
_____________________________________ TestBaseServiceDelete.test_delete_not_found _____________________________________

self = <test_base_service.TestBaseServiceDelete object at 0x000001F90F16B890>
mock_task_repository = <Mock id='2169234865744'>

    @pytest.mark.asyncio
    async def test_delete_not_found(self, mock_task_repository):
        """Test delete with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return NotFoundError
        mock_task_repository.delete = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.delete("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:218: AssertionError
________________________________________ TestBaseServiceList.test_list_success ________________________________________

self = <test_base_service.TestBaseServiceList object at 0x000001F90F16A850>
mock_task_repository = <Mock id='2169234686544'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_list_success(self, mock_task_repository, sample_task):
        """Test successful entity listing with pagination."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.list(limit=50, offset=0)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91076F9D0>, Ok)

tests\unit\services\test_base_service.py:234: AssertionError
_____________________________________ TestBaseServiceList.test_list_empty_result ______________________________________

self = <test_base_service.TestBaseServiceList object at 0x000001F90F169050>
mock_task_repository = <Mock id='2169234716368'>

    @pytest.mark.asyncio
    async def test_list_empty_result(self, mock_task_repository):
        """Test list with no results returns empty list."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return empty list
        mock_task_repository.find_all = AsyncMock(return_value=Ok([]))
    
        # Act
        result = await service.list()
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91076FC90>, Ok)

tests\unit\services\test_base_service.py:254: AssertionError
_______________________________________ TestBaseServiceUtility.test_exists_true _______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000001F90EDA6D10>
mock_task_repository = <Mock id='2169236844880'>

    @pytest.mark.asyncio
    async def test_exists_true(self, mock_task_repository):
        """Test exists returns True for existing entity."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.exists("T-TEST-001")
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() is True
E       assert <taskman_api.core.result.Ok object at 0x000001F90FF19C90> is True
E        +  where <taskman_api.core.result.Ok object at 0x000001F90FF19C90> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000001F91076B950>.ok

tests\unit\services\test_base_service.py:274: AssertionError
______________________________________ TestBaseServiceUtility.test_exists_false _______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000001F90F180B90>
mock_task_repository = <Mock id='2169235117904'>

    @pytest.mark.asyncio
    async def test_exists_false(self, mock_task_repository):
        """Test exists returns False for non-existent entity."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return False
        mock_task_repository.exists = AsyncMock(return_value=Ok(False))
    
        # Act
        result = await service.exists("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() is False
E       assert <taskman_api.core.result.Ok object at 0x000001F9108FCC90> is False
E        +  where <taskman_api.core.result.Ok object at 0x000001F9108FCC90> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000001F9108FE810>.ok

tests\unit\services\test_base_service.py:291: AssertionError
______________________________________ TestBaseServiceUtility.test_count_success ______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000001F90F168250>
mock_task_repository = <Mock id='2169236648464'>

    @pytest.mark.asyncio
    async def test_count_success(self, mock_task_repository):
        """Test count returns total entity count."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return count
        mock_task_repository.count = AsyncMock(return_value=Ok(42))
    
        # Act
        result = await service.count()
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() == 42
E       assert <taskman_api.core.result.Ok object at 0x000001F91091EA50> == 42
E        +  where <taskman_api.core.result.Ok object at 0x000001F91091EA50> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000001F9108FF490>.ok

tests\unit\services\test_base_service.py:307: AssertionError
________________________ TestTaskServiceStatusTransitions.test_change_status_valid_transition _________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000001F90EDE0210>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B1FB90>
mock_task_repository = <Mock name='TaskRepository()' id='2169238584016'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_change_status_valid_transition(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid status transition (NEW  READY)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Create independent copies to avoid fixture mutation
            task_with_new_status = copy.deepcopy(sample_task)
            task_with_new_status.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_with_new_status))
    
            # Mock update with independent task copy
            task_with_ready_status = copy.deepcopy(sample_task)
            task_with_ready_status.status = TaskStatus.READY
            mock_task_repository.update = AsyncMock(return_value=Ok(task_with_ready_status))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F9101AA210>, Ok)

tests\unit\services\test_task_service.py:48: AssertionError
_______________________ TestTaskServiceStatusTransitions.test_change_status_invalid_transition ________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000001F90EDE0BD0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F90FBC0250>
mock_task_repository = <Mock name='TaskRepository()' id='2169227386768'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.DONE')>

    @pytest.mark.asyncio
    async def test_change_status_invalid_transition(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid status transition (DONE  IN_PROGRESS)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get() to return task with DONE status (terminal state)
            sample_task.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.IN_PROGRESS)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service.py:75: AssertionError
____________________________ TestTaskServiceStatusTransitions.test_change_status_not_found ____________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000001F90EDE1910>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F9106F2190>
mock_task_repository = <Mock name='TaskRepository()' id='2169222497424'>

    @pytest.mark.asyncio
    async def test_change_status_not_found(self, mocker, mock_task_repository):
        """Test change_status with non-existent task."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get() to return NotFoundError
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Err(
                    NotFoundError(
                        message="Task not found",
                        entity_type="Task",
                        entity_id="T-NONEXISTENT",
                    )
                )
            )
    
            # Act
            result = await service.change_status("T-NONEXISTENT", TaskStatus.READY)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service.py:106: AssertionError
___________________________________ TestTaskServiceAssignment.test_assign_to_sprint ___________________________________

self = <test_task_service.TestTaskServiceAssignment object at 0x000001F90F281CD0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F9102F03D0>
mock_task_repository = <Mock name='TaskRepository()' id='2169234983824'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_sprint(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to sprint."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            updated_task = sample_task
            updated_task.primary_sprint = "S-2025-01"
            mock_task_repository.update = AsyncMock(return_value=Ok(updated_task))
    
            # Act
>           result = await service.assign_to_sprint("T-TEST-001", "S-2025-01")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:249: in assign_to_sprint
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:115: in update
    sprint = await self.sprint_repo.get_by_id(update_data.primary_sprint)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.sprint_repository.SprintRepository object at 0x000001F910771B90>
entity_id = 'S-2025-01'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
__________________________________ TestTaskServiceAssignment.test_assign_to_project ___________________________________

self = <test_task_service.TestTaskServiceAssignment object at 0x000001F90F281690>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F9107B4A10>
mock_task_repository = <Mock name='TaskRepository()' id='2169235011536'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_project(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to project."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            updated_task = sample_task
            updated_task.primary_project = "P-TASKMAN"
            mock_task_repository.update = AsyncMock(return_value=Ok(updated_task))
    
            # Act
>           result = await service.assign_to_project("T-TEST-001", "P-TASKMAN")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:274: in assign_to_project
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:103: in update
    project = await self.project_repo.get_by_id(update_data.primary_project)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.project_repository.ProjectRepository object at 0x000001F910AF3E90>
entity_id = 'P-TASKMAN'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
_______________________________ TestTaskServiceBulkOperations.test_bulk_update_success ________________________________

self = <test_task_service.TestTaskServiceBulkOperations object at 0x000001F90F282590>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910759410>
mock_task_repository = <Mock name='TaskRepository()' id='2169234623120'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_success(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test successful bulk update of multiple tasks."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update for each task
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-002", "priority": "p1"},
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910AE2210>, Ok)

tests\unit\services\test_task_service.py:245: AssertionError
______________________________ TestTaskServiceBulkOperations.test_bulk_update_fails_fast ______________________________

self = <test_task_service.TestTaskServiceBulkOperations object at 0x000001F90F282550>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F91079BD50>
mock_task_repository = <Mock name='TaskRepository()' id='2169234173200'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_fails_fast(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test bulk update fails on first error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # First task succeeds, second task fails
            mock_task_repository.find_by_id = AsyncMock(
                side_effect=[
                    Ok(sample_task),  # First call succeeds
                    Err(
                        NotFoundError(
                            message="Task not found",
                            entity_type="Task",
                            entity_id="T-002",
                        )
                    ),  # Second call fails
                ]
            )
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-002", "status": "done"},  # This will fail
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service.py:289: AssertionError
_____________________________________ TestTaskServiceSearch.test_search_by_status _____________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001F90F2804D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910012B90>
mock_task_repository = <Mock name='TaskRepository()' id='2169226988048'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_search_by_status(self, mocker, mock_task_repository, sample_task):
        """Test search by status filter."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
            result = await service.search(status=TaskStatus.IN_PROGRESS, limit=50)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F9109339D0>, Ok)

tests\unit\services\test_task_service.py:310: AssertionError
______________________________ TestTaskServiceSearch.test_search_by_status_and_priority _______________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001F90ED84F50>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F9108EDE90>
mock_task_repository = <Mock name='TaskRepository()' id='2169236561680'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_search_by_status_and_priority(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test search with status and priority filters."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
            result = await service.search(
                status=TaskStatus.IN_PROGRESS, priority=Priority.P1
            )
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F9109AC110>, Ok)

tests\unit\services\test_task_service.py:336: AssertionError
_________________________________ TestTaskServiceSearch.test_get_high_priority_tasks __________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001F90F283E90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910983D10>
mock_task_repository = <Mock name='TaskRepository()' id='2169237203984'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_high_priority_tasks(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test get high priority tasks (P0, P1)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
>           result = await service.get_high_priority_tasks(limit=20)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:413: in get_high_priority_tasks
    responses = [
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001F910B83130>

    responses = [
>       self.response_class.model_validate(self._deserialize_json_fields(task))
        for task in tasks
    ]
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E   acceptance_criteria.0
E     Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
E       For further information visit https://errors.pydantic.dev/2.12/v/dict_type

src\taskman_api\services\task_service.py:414: ValidationError
____________________________________ TestTaskServiceSearch.test_get_blocked_tasks _____________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001F90F280210>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B4B510>
mock_task_repository = <Mock name='TaskRepository()' id='2169238758864'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_blocked_tasks(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test get blocked tasks."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
>           result = await service.get_blocked_tasks()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:448: in get_blocked_tasks
    responses = [
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001F90F8A4E50>

    responses = [
>       self.response_class.model_validate(task) for task in tasks
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ]
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E   acceptance_criteria.0
E     Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
E       For further information visit https://errors.pydantic.dev/2.12/v/dict_type

src\taskman_api\services\task_service.py:449: ValidationError
_____________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_new_to_ready _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E1790>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B90750>
mock_task_repository = <Mock name='TaskRepository()' id='2169239125968'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_new_to_ready(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from NEW to READY."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Create task in NEW status
            task_new = copy.deepcopy(sample_task)
            task_new.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_new))
    
            # Mock update to return task in READY status
            task_ready = copy.deepcopy(sample_task)
            task_ready.status = TaskStatus.READY
            mock_task_repository.update = AsyncMock(return_value=Ok(task_ready))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910BC1550>, Ok)

tests\unit\services\test_task_service_edge_cases.py:47: AssertionError
________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_in_progress_to_blocked ________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E37D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B9C650>
mock_task_repository = <Mock name='TaskRepository()' id='2169239095184'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_in_progress_to_blocked(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from IN_PROGRESS to BLOCKED."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in IN_PROGRESS status
            task_in_progress = copy.deepcopy(sample_task)
            task_in_progress.status = TaskStatus.IN_PROGRESS
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Ok(task_in_progress)
            )
    
            # Mock update to return BLOCKED task
            task_blocked = copy.deepcopy(sample_task)
            task_blocked.status = TaskStatus.BLOCKED
            mock_task_repository.update = AsyncMock(return_value=Ok(task_blocked))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.BLOCKED)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910B64A90>, Ok)

tests\unit\services\test_task_service_edge_cases.py:80: AssertionError
_________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_in_progress_to_done __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E3F50>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B3F490>
mock_task_repository = <Mock name='TaskRepository()' id='2169237622992'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_in_progress_to_done(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from IN_PROGRESS to DONE."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in IN_PROGRESS status
            task_in_progress = copy.deepcopy(sample_task)
            task_in_progress.status = TaskStatus.IN_PROGRESS
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Ok(task_in_progress)
            )
    
            # Mock update to return DONE task
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.update = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.DONE)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910B60710>, Ok)

tests\unit\services\test_task_service_edge_cases.py:113: AssertionError
____________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_done_to_new _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E0FD0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910A34050>
mock_task_repository = <Mock name='TaskRepository()' id='2169237630352'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_done_to_new(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DONE (terminal state) to NEW.
    
        DONE is a terminal state - no transitions allowed.
        """
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DONE status (terminal state)
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.NEW)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:144: AssertionError
________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_done_to_in_progress _________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E0DD0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910A35110>
mock_task_repository = <Mock name='TaskRepository()' id='2169238521168'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_done_to_in_progress(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DONE (terminal state) to IN_PROGRESS."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DONE status (terminal state)
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.IN_PROGRESS)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:172: AssertionError
__________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_dropped_to_ready __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E29D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B106D0>
mock_task_repository = <Mock name='TaskRepository()' id='2169238521616'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_dropped_to_ready(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DROPPED (terminal state) to READY."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DROPPED status (terminal state)
            task_dropped = copy.deepcopy(sample_task)
            task_dropped.status = TaskStatus.DROPPED
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_dropped))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:199: AssertionError
____________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_new_to_done _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F0E0F90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B12350>
mock_task_repository = <Mock name='TaskRepository()' id='2169239105424'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_new_to_done(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from NEW to DONE (skip intermediate states)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in NEW status
            task_new = copy.deepcopy(sample_task)
            task_new.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_new))
    
            # Act - attempt to jump directly to DONE
            result = await service.change_status("T-TEST-001", TaskStatus.DONE)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:226: AssertionError
__________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_ready_to_blocked __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001F90F255650>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910B66F10>
mock_task_repository = <Mock name='TaskRepository()' id='2169238220304'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_ready_to_blocked(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from READY to BLOCKED (must be IN_PROGRESS first)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in READY status
            task_ready = copy.deepcopy(sample_task)
            task_ready.status = TaskStatus.READY
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_ready))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.BLOCKED)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:253: AssertionError
__________________ TestTaskServiceBulkOperationEdgeCases.test_bulk_update_partial_failure_fails_fast __________________

self = <test_task_service_edge_cases.TestTaskServiceBulkOperationEdgeCases object at 0x000001F90F2544D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910A71310>
mock_task_repository = <Mock name='TaskRepository()' id='2169238199888'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_partial_failure_fails_fast(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test bulk update fails on first error and doesn't continue.
    
        Ensures fail-fast behavior: if task 2 fails, task 3 should not be processed.
        """
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # First task succeeds, second task fails (not found)
            mock_task_repository.find_by_id = AsyncMock(
                side_effect=[
                    Ok(sample_task),  # Task 1 found
                    Err(
                        NotFoundError(
                            message="Task not found",
                            entity_type="Task",
                            entity_id="T-NONEXISTENT",
                        )
                    ),  # Task 2 not found
                ]
            )
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-NONEXISTENT", "status": "done"},  # This will fail
                {"id": "T-003", "status": "blocked"},  # This should not be processed
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service_edge_cases.py:303: AssertionError
________________________ TestTaskServiceAssignmentEdgeCases.test_assign_to_nonexistent_sprint _________________________

self = <test_task_service_edge_cases.TestTaskServiceAssignmentEdgeCases object at 0x000001F90F11DE90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F9109EC790>
mock_task_repository = <Mock name='TaskRepository()' id='2169237332496'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_nonexistent_sprint(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to non-existent sprint propagates error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task exists
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Update fails (foreign key constraint)
            mock_task_repository.update = AsyncMock(
                return_value=Err(
                    ValidationError(
                        message="Sprint not found",
                        field="primary_sprint",
                        value="S-NONEXISTENT",
                    )
                )
            )
    
            # Act
>           result = await service.assign_to_sprint("T-TEST-001", "S-NONEXISTENT")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service_edge_cases.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:249: in assign_to_sprint
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:115: in update
    sprint = await self.sprint_repo.get_by_id(update_data.primary_sprint)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.sprint_repository.SprintRepository object at 0x000001F910A33AD0>
entity_id = 'S-NONEXISTENT'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
________________________ TestTaskServiceAssignmentEdgeCases.test_assign_to_nonexistent_project ________________________

self = <test_task_service_edge_cases.TestTaskServiceAssignmentEdgeCases object at 0x000001F90F11F2D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001F910A36490>
mock_task_repository = <Mock name='TaskRepository()' id='2169237629712'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_nonexistent_project(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to non-existent project propagates error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task exists
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Update fails (foreign key constraint)
            mock_task_repository.update = AsyncMock(
                return_value=Err(
                    ValidationError(
                        message="Project not found",
                        field="primary_project",
                        value="P-NONEXISTENT",
                    )
                )
            )
    
            # Act
>           result = await service.assign_to_project("T-TEST-001", "P-NONEXISTENT")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service_edge_cases.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:274: in assign_to_project
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:103: in update
    project = await self.project_repo.get_by_id(update_data.primary_project)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.project_repository.ProjectRepository object at 0x000001F910AD6750>
entity_id = 'P-NONEXISTENT'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
____________________________________ TestSettings.test_valid_settings_development _____________________________________

self = <test_config.TestSettings object at 0x000001F90F16D710>

    def test_valid_settings_development(self):
        """Test valid settings for development environment."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("dev_password"),
                database="taskman_dev",
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a9efd0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...kman_dev'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________________________ TestSettings.test_valid_settings_production _____________________________________

self = <test_config.TestSettings object at 0x000001F90F16DF10>

    def test_valid_settings_production(self):
        """Test valid settings for production environment."""
>       settings = Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("prod_secure_password_123"),
                database="taskman_production",
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\unit\test_config.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f9108bff70>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...roduction'), 'environment': 'production', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________ TestSettings.test_development_allows_insecure_secrets ________________________________

self = <test_config.TestSettings object at 0x000001F90F16F3D0>

    def test_development_allows_insecure_secrets(self):
        """Test that development environment allows test secrets."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            secret_key=SecretStr("INSECURE_DEV_KEY_32_CHARACTERS_MIN"),
            jwt_secret=SecretStr("test-key-for-development-32-chars"),
        )

tests\unit\test_config.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f90f882580>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...skman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_______________________________________ TestSettings.test_optional_redis_config _______________________________________

self = <test_config.TestSettings object at 0x000001F90F16F810>

    def test_optional_redis_config(self):
        """Test that Redis configuration is optional."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            redis=None,  # Optional
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f9108bd7c0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...d@localhost:5432/taskman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'redis': None, ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_________________________________________ TestSettings.test_with_redis_config _________________________________________

self = <test_config.TestSettings object at 0x000001F90F16D750>

    def test_with_redis_config(self):
        """Test settings with Redis configuration provided."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                db=1,
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f9108bec10>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=5, db=1), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________________ TestSettings.test_environment_helpers ________________________________________

self = <test_config.TestSettings object at 0x000001F90F275C50>

    def test_environment_helpers(self):
        """Test environment helper properties."""
        # Development
>       dev_settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f9108bccd0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...skman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________________ TestGetSettings.test_settings_cached _________________________________________

self = <test_config.TestGetSettings object at 0x000001F90F275FD0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001F9109E8110>

    def test_settings_cached(self, monkeypatch):
        """Test that settings are cached across calls."""
        # Set environment variables for this test
        monkeypatch.setenv("APP_ENVIRONMENT", "testing")
        monkeypatch.setenv("APP_DATABASE__HOST", "localhost")
        monkeypatch.setenv("APP_DATABASE__PORT", "5432")
        monkeypatch.setenv("APP_DATABASE__USER", "taskman")
        monkeypatch.setenv("APP_DATABASE__PASSWORD", "test_password")
        monkeypatch.setenv("APP_DATABASE__DATABASE", "taskman_test")
        monkeypatch.setenv("APP_SECRET_KEY", "test-secret-key-min-32-characters")
        monkeypatch.setenv("APP_JWT_SECRET", "test-jwt-secret-min-32-characters")
    
        # First call
>       settings1 = get_settings()
                    ^^^^^^^^^^^^^^

tests\unit\test_config.py:422: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\config.py:290: in get_settings
    return Settings()
           ^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f9108bfbb0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________________________________ TestGetSettings.test_cache_clear ___________________________________________

self = <test_config.TestGetSettings object at 0x000001F90F277090>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001F9109FC710>

    def test_cache_clear(self, monkeypatch):
        """Test that cache_clear forces reload."""
        # Set environment variables
        monkeypatch.setenv("APP_ENVIRONMENT", "testing")
        monkeypatch.setenv("APP_DATABASE__HOST", "localhost")
        monkeypatch.setenv("APP_DATABASE__PORT", "5432")
        monkeypatch.setenv("APP_DATABASE__USER", "taskman")
        monkeypatch.setenv("APP_DATABASE__PASSWORD", "test_password")
        monkeypatch.setenv("APP_DATABASE__DATABASE", "taskman_test")
        monkeypatch.setenv("APP_SECRET_KEY", "test-secret-key-min-32-characters")
        monkeypatch.setenv("APP_JWT_SECRET", "test-jwt-secret-min-32-characters")
    
        # First call
>       settings1 = get_settings()
                    ^^^^^^^^^^^^^^

tests\unit\test_config.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\config.py:290: in get_settings
    return Settings()
           ^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1f910a9cf00>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError

---------- coverage: platform win32, python 3.11.9-final-0 -----------
Name                                                     Stmts   Miss Branch BrPart   Cover   Missing
-----------------------------------------------------------------------------------------------------
src\taskman_api\__init__.py                                  0      0      0      0 100.00%
src\taskman_api\config.py                                   62      2      6      0  97.06%   255, 261
src\taskman_api\core\__init__.py                             4      0      0      0 100.00%
src\taskman_api\core\enums.py                               71      0      0      0 100.00%
src\taskman_api\core\errors.py                              78     31     36      6  53.51%   48-57, 107, 136, 138, 139->141, 141->143, 144, 169-177, 199-205, 226-230, 253-259
src\taskman_api\core\result.py                              37      6      0      0  83.78%   40, 50, 54, 66, 72, 76
src\taskman_api\db\__init__.py                               3      0      0      0 100.00%
src\taskman_api\db\base.py                                   6      1      0      0  83.33%   32
src\taskman_api\db\connection_manager.py                    91     52     10      2  40.59%   66-68, 97-101, 108-112, 117-121, 135-165, 170-183
src\taskman_api\db\session.py                               27      7      4      0  64.52%   48-50, 63-64, 73-75
src\taskman_api\dependencies.py                             43      8      0      0  81.40%   33-37, 47, 52, 57, 62
src\taskman_api\main.py                                    104     38     18      3  56.56%   54-77, 106-160, 242, 244, 246, 272, 295, 306
src\taskman_api\middleware\__init__.py                       2      0      0      0 100.00%
src\taskman_api\middleware\logging_middleware.py            85     15     32     10  73.50%   77, 98, 102, 123, 127, 133, 168, 193->197, 249-255, 258->272, 261
src\taskman_api\models\__init__.py                           5      0      0      0 100.00%
src\taskman_api\models\action_list.py                       39      5      6      3  82.22%   34, 40, 46, 83, 88
src\taskman_api\models\project.py                           45      1      0      0  97.78%   91
src\taskman_api\models\sprint.py                            51      2      0      0  96.08%   44, 101
src\taskman_api\models\task.py                              56      0      0      0 100.00%
src\taskman_api\repositories\__init__.py                     6      0      0      0 100.00%
src\taskman_api\repositories\action_list_repository.py      43     20     10      1  49.06%   27-32, 36-39, 61-64, 71-74, 77, 88-95, 99-101, 105-107, 111-112
src\taskman_api\repositories\base.py                        33      5      0      0  84.85%   41-44, 66-71
src\taskman_api\repositories\project_repository.py          46      4     12      4  86.21%   31-34, 107->109, 110, 111->113, 114
src\taskman_api\repositories\sprint_repository.py           51      5     14      5  84.62%   31-34, 119->121, 122, 123->125, 126, 128
src\taskman_api\repositories\task_repository.py             78     47     42      3  33.33%   26-29, 33-34, 38-41, 48, 52-55, 81, 83, 85, 92-95, 98, 142-180, 201-233
src\taskman_api\routers\__init__.py                          7      0      0      0 100.00%
src\taskman_api\routers\action_lists.py                    114     81     56      0  19.41%   50-62, 76-82, 92-105, 117-129, 139-148, 160-172, 182-194, 209-226, 236-247, 261-276
src\taskman_api\routers\agent.py                            30     15      6      0  41.67%   32-72
src\taskman_api\routers\diagnostic.py                       20     14      0      0  30.00%   16-40
src\taskman_api\routers\projects.py                         73     43     32      0  30.48%   42-43, 53-64, 74-86, 96-103, 115-126, 136-143
src\taskman_api\routers\sprints.py                         108     71     52      0  24.38%   48-49, 59-70, 80-94, 104-111, 121-128, 140-151, 161-168, 176-185, 193-202
src\taskman_api\routers\tasks.py                            94     56     42      0  30.88%   47-48, 57-58, 72-83, 93-105, 115-122, 133-144, 154-161, 170-183
src\taskman_api\schemas\__init__.py                          7      0      0      0 100.00%
src\taskman_api\schemas\action_list.py                      82      1      2      1  97.62%   102
src\taskman_api\schemas\base.py                             53      3      6      1  89.83%   25-28
src\taskman_api\schemas\enums.py                            62      0      0      0 100.00%
src\taskman_api\schemas\project.py                         108      1      2      1  98.18%   165
src\taskman_api\schemas\sprint.py                          109      2      4      2  96.46%   148, 155
src\taskman_api\schemas\task.py                            138      2      4      2  97.18%   218, 226
src\taskman_api\services\__init__.py                         6      0      0      0 100.00%
src\taskman_api\services\action_list_service.py             86     50     16      0  35.29%   63-65, 89-91, 97-107, 113-121, 125-136, 144-164
src\taskman_api\services\base.py                           110     18     24      3  81.34%   73-75, 102-104, 158, 196, 212->211, 241-242, 251, 273-278, 297-298, 309-310
src\taskman_api\services\project_service.py                 97     70     36      0  20.30%   83-85, 115-175, 198-212, 232-246, 265-266, 290-300, 321-331
src\taskman_api\services\sprint_service.py                 141     89     48      1  30.16%   94-96, 114-120, 127, 129, 134-157, 184->186, 209-229, 262-325, 344-345, 369-380, 401-410, 431-440, 462-470
src\taskman_api\services\task_service.py                    92     14     32      6  77.42%   104->114, 164-178, 317, 318->305, 384, 417-419, 451-453
-----------------------------------------------------------------------------------------------------
TOTAL                                                     2603    779    552     54  61.93%

FAIL Required test coverage of 70.0% not reached. Total coverage: 61.93%
=============================================== short test summary info ===============================================
FAILED tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_action_list_lifecycle - assert 0 == 2
 +  where 0 = len([])
FAILED tests/integration/api/test_endpoints.py::TestHealthEndpoint::test_health_check - AttributeError: 'Settings' object has no attribute 'database'
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_success - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_get_task_success - assert 404 == 200
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_update_task_success - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_delete_task_success - assert 404 == 204
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   204 = status.HTTP_204_NO_CONTENT
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_list_tasks - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_conflict - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_list_projects - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_success - assert 405 == 200
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_not_found - assert 405 == 404
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   404 = status.HTTP_404_NOT_FOUND
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_success - assert 404 == 201
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_get_sprint_success - assert 404 == 200
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_list_sprints - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_success - assert 404 == 201
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_not_found - assert 405 == 404
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   404 = status.HTTP_404_NOT_FOUND
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_delete_sprint_success - assert 404 == 204
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   204 = status.HTTP_204_NO_CONTENT
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_conflict - assert 404 == 201
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_success - AssertionError: assert 'AL-0003' == 'AL-TEST-001'
  
  - AL-TEST-001
  + AL-0003
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_get_action_list_success - assert 404 == 200
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_list_action_lists - AssertionError: assert False
 +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:46', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:46', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:46', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_success - assert 405 == 200
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_not_found - assert 405 == 404
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   404 = status.HTTP_404_NOT_FOUND
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_delete_action_list_success - assert 404 == 204
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   204 = status.HTTP_204_NO_CONTENT
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_conflict - assert 201 == 409
 +  where 201 = <Response [201 Created]>.status_code
 +  and   409 = status.HTTP_409_CONFLICT
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_limit - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_offset - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_empty_result - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_with_pagination - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_action_lists_limit_boundary - AssertionError: assert False
 +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_zero_offset - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_large_limit - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_default_pagination - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_priority - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_owner - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_owner - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_project - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:48', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_multiple_filters - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_no_filters - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_invalid_filter_ignored - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_empty_filter_value - AssertionError: assert False
 +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_task_max_title_length - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_action_list_invalid_status - assert 405 == 200
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_conflict - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_not_found - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_validation_limit_exceeded - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_not_found - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_not_found - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_true - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_false - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_count - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_by_status - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_active_projects - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_by_status - TypeError: 'tasks' is an invalid keyword argument for Sprint
FAILED tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_active_sprints - TypeError: 'tasks' is an invalid keyword argument for Sprint
FAILED tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_by_owner - TypeError: 'title' is an invalid keyword argument for ActionList
FAILED tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_orphaned - TypeError: 'title' is an invalid keyword argument for ActionList
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status - AttributeError: 'TaskRepository' object has no attribute 'find_by_status'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_priority - AttributeError: 'TaskRepository' object has no attribute 'find_by_priority'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_owner - AttributeError: 'TaskRepository' object has no attribute 'find_by_owner'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project_with_status_filter - AttributeError: 'TaskRepository' object has no attribute 'find_by_project'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_sprint - AttributeError: 'TaskRepository' object has no attribute 'find_by_sprint'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status_and_priority - AttributeError: 'TaskRepository' object has no attribute 'find_by_status_and_priority'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_blocked_tasks - AttributeError: 'TaskRepository' object has no attribute 'find_blocked_tasks'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_high_priority_tasks - AttributeError: 'TaskRepository' object has no attribute 'find_high_priority_tasks'
FAILED tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_create_request_valid - AssertionError: assert <ProjectStatu...G: 'planning'> == <ProjectStatu...: 'discovery'>
  
  - discovery
  + planning
FAILED tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_create_request_valid - AssertionError: assert <SprintStatus...G: 'planning'> == <SprintStatus...ED: 'planned'>
  
  - planned
  + planning
FAILED tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_response_with_metrics - pydantic_core._pydantic_core.ValidationError: 1 validation error for SprintResponse
dependencies
  Input should be a valid list [type=list_type, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.12/v/list_type
FAILED tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_soft_delete_fields - pydantic_core._pydantic_core.ValidationError: 1 validation error for ActionListCreate
status
  Input should be 'active' or 'archived' [type=enum, input_value='deleted', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/enum
FAILED tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_strict_type_validation - ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)
FAILED tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_from_attributes_orm_mode - ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_failure - assert False
 +  where False = any(<generator object TestTaskCreateRequest.test_task_id_pattern_validation_failure.<locals>.<genexpr> at 0x000001F9105A5EE0>)
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_required_fields_validation - AssertionError: assert False
 +  where False = <built-in method issubset of set object at 0x000001F90F8A9540>({'description', 'owner', 'primary_project', 'primary_sprint', 'summary', 'title'})
 +    where <built-in method issubset of set object at 0x000001F90F8A9540> = {'description', 'owner', 'primary_project', 'primary_sprint', 'priority', 'summary', ...}.issubset
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_business_value_score_range - Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_enum_field_validation - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskCreate
severity
  Input should be 'critical', 'high', 'medium' or 'low' [type=enum, input_value=<Severity.SEV2: 'sev2'>, input_type=Severity]
    For further information visit https://errors.pydantic.dev/2.12/v/enum
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_from_orm_model - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
automation_candidate
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.12/v/bool_type
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_serialization - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
automation_candidate
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.12/v/bool_type
FAILED tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910734210>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_conflict_error - assert False
 +  where False = isinstance(AppError("9 validation errors for TaskResponse\nid\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ntitle\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nsummary\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ndescription\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nstatus\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nowner\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\npriority\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_project\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_sprint\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing"), ConflictError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91078A890>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91078ECD0>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910798050>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91076F9D0>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_empty_result - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F91076FC90>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_true - assert <taskman_api.core.result.Ok object at 0x000001F90FF19C90> is True
 +  where <taskman_api.core.result.Ok object at 0x000001F90FF19C90> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000001F91076B950>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_false - assert <taskman_api.core.result.Ok object at 0x000001F9108FCC90> is False
 +  where <taskman_api.core.result.Ok object at 0x000001F9108FCC90> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000001F9108FE810>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_count_success - assert <taskman_api.core.result.Ok object at 0x000001F91091EA50> == 42
 +  where <taskman_api.core.result.Ok object at 0x000001F91091EA50> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000001F9108FF490>.ok
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_valid_transition - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F9101AA210>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_invalid_transition - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_sprint - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_project - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910AE2210>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_fails_fast - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F9109339D0>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status_and_priority - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F9109AC110>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_high_priority_tasks - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
acceptance_criteria.0
  Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/dict_type
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_blocked_tasks - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
acceptance_criteria.0
  Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/dict_type
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_new_to_ready - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910BC1550>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_blocked - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910B64A90>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_done - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001F910B60710>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_new - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_in_progress - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_dropped_to_ready - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_new_to_done - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_ready_to_blocked - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_partial_failure_fails_fast - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_sprint - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_project - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/test_config.py::TestSettings::test_valid_settings_development - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_valid_settings_production - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_development_allows_insecure_secrets - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_optional_redis_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_with_redis_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_environment_helpers - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestGetSettings::test_settings_cached - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestGetSettings::test_cache_clear - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/db/test_connection_manager.py::test_init_creates_engines - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_get_session_primary_success - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_get_session_failover - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_health_check_reporting - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_health_check_primary_down - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_minimum_fields - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_all_fields - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_partial_single_field - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_empty_mission - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_success - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_project_not_found - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_sprint_to_project - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_duplicate_sprint_idempotent - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_remove_sprint_from_project - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_no_tasks - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_project_not_found - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_status_no_results - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_owner_no_results - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_metrics_success - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_add_sprint - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_remove_sprint - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_change_status - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_by_status - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_by_owner - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestSprintService::test_calculate_velocity - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_burndown - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_change_status - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_current_sprints - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_by_project - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_update_metrics - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestActionListService::test_reorder_items_success - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_reorder_items_invalid_length - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_mark_complete - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_add_item - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_remove_item - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_get_orphaned - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_get_soft_deleted - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_calculate_velocity_mixed_tasks - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_get_burndown_calculations - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_provides_complete_settings - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_database - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_redis - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestMinimalSettingsFixture::test_fixture_provides_minimal_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_simulates_production - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_database - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_redis - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_settings_default_to_testing - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
===================================== 130 failed, 96 passed, 47 errors in 20.10s ======================================
