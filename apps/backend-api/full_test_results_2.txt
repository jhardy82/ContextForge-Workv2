================================================= test session starts =================================================
platform win32 -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 -- C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Scripts\python.exe
cachedir: .pytest_cache
hypothesis profile 'ci' -> database=None, deadline=None, print_blob=True, derandomize=True, suppress_health_check=(HealthCheck.too_slow,)
benchmark: 5.2.3 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
Using --randomly-seed=1251777991
rootdir: C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api
configfile: pytest_full.ini
plugins: anyio-4.10.0, Faker-39.0.0, hypothesis-6.138.3, asyncio-0.26.0, benchmark-5.2.3, console-scripts-1.4.1, cov-5.0.0, mock-3.15.1, randomly-3.16.0, timeout-2.4.0, xdist-3.8.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
collecting ... collected 273 items

tests/integration/services/test_task_validation.py::test_update_task_with_invalid_foreign_keys PASSED            [  0%]
tests/integration/services/test_task_validation.py::test_create_task_with_invalid_sprint PASSED                  [  0%]
tests/integration/services/test_task_validation.py::test_create_task_with_invalid_project PASSED                 [  1%]
tests/integration/services/test_task_sprint_flow.py::test_sprint_closure_logic PASSED                            [  1%]
tests/integration/services/test_task_sprint_flow.py::test_task_movement_between_sprints PASSED                   [  1%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_with_associations PASSED             [  2%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_response_with_metadata PASSED        [  2%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_create_request_valid PASSED          [  2%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_soft_delete_fields FAILED            [  3%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_update_request_partial PASSED        [  3%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_id_pattern_validation PASSED                [  4%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_create_request_valid FAILED                 [  4%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_response_serialization PASSED               [  4%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_update_request_partial PASSED               [  5%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_create_request_valid FAILED                   [  5%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_update_request_partial PASSED                 [  5%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_response_with_metrics FAILED                  [  6%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_velocity_points_non_negative PASSED           [  6%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_id_pattern_validation PASSED                  [  6%]
tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_strict_type_validation FAILED              [  7%]
tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_from_attributes_orm_mode FAILED            [  7%]
tests/integration/services/test_cross_service_ops.py::test_full_workflow_simulation PASSED                       [  8%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project_with_status_filter FAILED [  8%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_blocked_tasks FAILED           [  8%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status_and_priority FAILED  [  9%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_owner FAILED                [  9%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project FAILED              [  9%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_sprint FAILED               [ 10%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_high_priority_tasks FAILED     [ 10%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_priority FAILED             [ 10%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status FAILED               [ 11%]
tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_success FAILED                      [ 11%]
tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_not_found FAILED                    [ 12%]
tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_success FAILED                      [ 12%]
tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_not_found FAILED                    [ 12%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_true FAILED                        [ 13%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_count_success FAILED                      [ 13%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_false FAILED                       [ 13%]
tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_not_found FAILED                          [ 14%]
tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_success FAILED                            [ 14%]
tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_success FAILED                          [ 15%]
tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_empty_result FAILED                     [ 15%]
tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_conflict_error FAILED               [ 15%]
tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_success FAILED                      [ 16%]
tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_orphaned FAILED             [ 16%]
tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_by_owner FAILED             [ 16%]
tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_active_projects FAILED         [ 17%]
tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_by_status FAILED               [ 17%]
tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_active_sprints FAILED           [ 17%]
tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_by_status FAILED                [ 18%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_get_burndown_calculations ERROR [ 18%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_calculate_velocity_mixed_tasks ERROR [ 19%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceSerialization::test_deserialize_maps_primary_project PASSED [ 19%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_get_active_sprints PASSED [ 19%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_create_and_update_sprint_helpers PASSED [ 20%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_exists PASSED          [ 20%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_get_by_project PASSED  [ 20%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_search_sprints PASSED  [ 21%]
tests/integration/services/test_project_sprint_flow.py::test_orphan_prevention PASSED                            [ 21%]
tests/integration/services/test_project_sprint_flow.py::test_project_sprint_task_hierarchy PASSED                [ 21%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_project_not_found ERROR [ 22%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_no_tasks ERROR [ 22%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_partial_single_field ERROR [ 23%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_empty_mission ERROR [ 23%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_all_fields ERROR [ 23%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_minimum_fields ERROR [ 24%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_status_no_results ERROR [ 24%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_owner_no_results ERROR [ 24%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_success ERROR [ 25%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_project_not_found ERROR [ 25%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_remove_sprint_from_project ERROR [ 26%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_duplicate_sprint_idempotent ERROR [ 26%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_sprint_to_project ERROR [ 26%]
tests/unit/test_fixtures.py::TestMinimalSettingsFixture::test_fixture_provides_minimal_config ERROR              [ 27%]
tests/unit/test_fixtures.py::TestRedisConfigFixture::test_fixture_provides_isolated_config PASSED                [ 27%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_database ERROR               [ 27%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_redis ERROR                  [ 28%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_simulates_production ERROR                  [ 28%]
tests/unit/test_fixtures.py::TestDatabaseConfigFixture::test_fixture_provides_isolated_config PASSED             [ 28%]
tests/unit/test_fixtures.py::TestDatabaseConfigFixture::test_fixture_connection_string PASSED                    [ 29%]
tests/unit/test_fixtures.py::TestCacheClearFixture::test_cache_cleared_between_tests_2 PASSED                    [ 29%]
tests/unit/test_fixtures.py::TestCacheClearFixture::test_cache_cleared_between_tests_1 PASSED                    [ 30%]
tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_settings_default_to_testing ERROR                    [ 30%]
tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_environment_set_to_testing PASSED                    [ 30%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_redis ERROR                              [ 31%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_database ERROR                           [ 31%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_provides_complete_settings ERROR                  [ 31%]
tests/unit/test_config.py::TestRedisConfig::test_default_values PASSED                                           [ 32%]
tests/unit/test_config.py::TestRedisConfig::test_timeout_validation PASSED                                       [ 32%]
tests/unit/test_config.py::TestRedisConfig::test_db_number_validation PASSED                                     [ 32%]
tests/unit/test_config.py::TestRedisConfig::test_valid_redis_config PASSED                                       [ 33%]
tests/unit/test_config.py::TestRedisConfig::test_invalid_url_pattern PASSED                                      [ 33%]
tests/unit/test_config.py::TestSettings::test_with_redis_config FAILED                                           [ 34%]
tests/unit/test_config.py::TestSettings::test_extra_fields_rejected PASSED                                       [ 34%]
tests/unit/test_config.py::TestSettings::test_valid_settings_development FAILED                                  [ 34%]
tests/unit/test_config.py::TestSettings::test_secret_key_min_length_32 PASSED                                    [ 35%]
tests/unit/test_config.py::TestSettings::test_optional_redis_config FAILED                                       [ 35%]
tests/unit/test_config.py::TestSettings::test_development_allows_insecure_secrets FAILED                         [ 35%]
tests/unit/test_config.py::TestSettings::test_valid_settings_production FAILED                                   [ 36%]
tests/unit/test_config.py::TestSettings::test_production_rejects_insecure_jwt_secret PASSED                      [ 36%]
tests/unit/test_config.py::TestSettings::test_environment_helpers FAILED                                         [ 36%]
tests/unit/test_config.py::TestSettings::test_production_rejects_insecure_secret_key PASSED                      [ 37%]
tests/unit/test_config.py::TestSettings::test_invalid_environment PASSED                                         [ 37%]
tests/unit/test_config.py::TestDatabaseConfig::test_invalid_port_too_high PASSED                                 [ 38%]
tests/unit/test_config.py::TestDatabaseConfig::test_empty_user_rejected PASSED                                   [ 38%]
tests/unit/test_config.py::TestDatabaseConfig::test_valid_database_config PASSED                                 [ 38%]
tests/unit/test_config.py::TestDatabaseConfig::test_default_values PASSED                                        [ 39%]
tests/unit/test_config.py::TestDatabaseConfig::test_async_connection_string_generation PASSED                    [ 39%]
tests/unit/test_config.py::TestDatabaseConfig::test_invalid_port_too_low PASSED                                  [ 39%]
tests/unit/test_config.py::TestDatabaseConfig::test_connection_string_generation PASSED                          [ 40%]
tests/unit/test_config.py::TestGetSettings::test_cache_clear FAILED                                              [ 40%]
tests/unit/test_config.py::TestGetSettings::test_settings_cached FAILED                                          [ 41%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_empty_list PASSED [ 41%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_partial_failure_fails_fast FAILED [ 41%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_project FAILED [ 42%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_sprint FAILED [ 42%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_new_to_ready FAILED [ 42%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_new_to_done FAILED [ 43%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_done FAILED [ 43%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_new FAILED [ 43%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_dropped_to_ready FAILED [ 44%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_in_progress FAILED [ 44%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_ready_to_blocked FAILED [ 45%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_blocked FAILED [ 45%]
tests/unit/db/test_connection_manager.py::test_init_creates_engines ERROR                                        [ 45%]
tests/unit/db/test_connection_manager.py::test_get_session_failover ERROR                                        [ 46%]
tests/unit/db/test_connection_manager.py::test_get_session_primary_success ERROR                                 [ 46%]
tests/unit/db/test_connection_manager.py::test_health_check_reporting ERROR                                      [ 46%]
tests/unit/db/test_connection_manager.py::test_health_check_primary_down ERROR                                   [ 47%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_conflict FAILED        [ 47%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_success FAILED         [ 47%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_validation_error PASSED [ 48%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_get_action_list_success FAILED            [ 48%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_success FAILED         [ 49%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_delete_action_list_not_found PASSED       [ 49%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_list_action_lists FAILED                  [ 49%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_not_found FAILED       [ 50%]
tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_delete_action_list_success FAILED         [ 50%]
tests/integration/api/test_endpoints.py::TestHealthEndpoint::test_health_check FAILED                            [ 50%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_success FAILED                [ 51%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_create_project_conflict PASSED               [ 51%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_list_projects FAILED                         [ 52%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_not_found FAILED              [ 52%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_delete_project_success PASSED                [ 52%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_get_project_success PASSED                   [ 53%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_create_project_success PASSED                [ 53%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_create_project_validation_error PASSED       [ 53%]
tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_delete_project_not_found PASSED              [ 54%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_action_lists_limit_boundary FAILED   [ 54%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_large_limit FAILED          [ 54%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_offset FAILED             [ 55%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_empty_result FAILED         [ 55%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_zero_offset FAILED             [ 56%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_default_pagination FAILED    [ 56%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_with_pagination FAILED       [ 56%]
tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_limit FAILED              [ 57%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_delete_sprint_success FAILED                  [ 57%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_get_sprint_success FAILED                     [ 57%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_not_found FAILED                [ 58%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_success FAILED                  [ 58%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_delete_sprint_not_found PASSED                [ 58%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_conflict FAILED                 [ 59%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_validation_error PASSED         [ 59%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_success FAILED                  [ 60%]
tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_list_sprints FAILED                           [ 60%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_status FAILED         [ 60%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_project FAILED      [ 61%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_owner FAILED          [ 61%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_empty_filter_value FAILED [ 61%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_status FAILED      [ 62%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_invalid_filter_ignored FAILED [ 62%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_priority FAILED       [ 63%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_owner FAILED       [ 63%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_multiple_filters FAILED         [ 63%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_filter_by_status FAILED  [ 64%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_no_filters FAILED            [ 64%]
tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_status FAILED       [ 64%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_get_task_not_found PASSED                       [ 65%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_list_tasks FAILED                               [ 65%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_get_task_success FAILED                         [ 65%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_delete_task_success FAILED                      [ 66%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_update_task_success FAILED                      [ 66%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_success FAILED                      [ 67%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_conflict FAILED                     [ 67%]
tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_validation_error PASSED             [ 67%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_action_list_missing_required_field PASSED [ 68%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_action_list_invalid_status FAILED  [ 68%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_sprint_invalid_date_format PASSED  [ 68%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_task_invalid_priority PASSED       [ 69%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_task_title_exceeds_max_length PASSED [ 69%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_sprint_invalid_cadence PASSED      [ 69%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_task_invalid_status PASSED         [ 70%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_project_max_name_length PASSED     [ 70%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_project_invalid_status PASSED      [ 71%]
tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_task_max_title_length FAILED       [ 71%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_high_priority_tasks FAILED             [ 71%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status_and_priority FAILED       [ 72%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status FAILED                    [ 72%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_blocked_tasks FAILED                   [ 72%]
tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_project FAILED               [ 73%]
tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_sprint FAILED                [ 73%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_ready_to_in_progress PASSED [ 73%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_new_to_ready PASSED [ 74%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_done_to_any_is_invalid PASSED [ 74%]
tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_fails_fast FAILED      [ 75%]
tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_success FAILED         [ 75%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_not_found FAILED  [ 75%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_invalid_transition FAILED [ 76%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_valid_transition FAILED [ 76%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_management PASSED                  [ 76%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_validation_errors PASSED           [ 77%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_velocity_calculation PASSED        [ 77%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_not_found FAILED             [ 78%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_true FAILED                  [ 78%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_count FAILED                        [ 78%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_success FAILED               [ 79%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_false FAILED                 [ 79%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_success FAILED           [ 79%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_success FAILED             [ 80%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_not_found FAILED         [ 80%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_success FAILED               [ 80%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_validation_limit_exceeded FAILED [ 81%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_not_found FAILED             [ 81%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_conflict FAILED              [ 82%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_success FAILED               [ 82%]
tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_validation_errors PASSED         [ 82%]
tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_action_list_lifecycle FAILED     [ 83%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_get_by_owner PASSED  [ 83%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_update_project_method PASSED [ 83%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_create_project_method PASSED [ 84%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_search_filters_and_pagination PASSED [ 84%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_exists PASSED        [ 84%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_success PASSED   [ 85%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_default_values PASSED                       [ 85%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_failure FAILED   [ 86%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_required_fields_validation FAILED           [ 86%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_estimate_points_non_negative PASSED         [ 86%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_enum_field_validation FAILED                [ 87%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_valid_task_create_request PASSED            [ 87%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_title_max_length_validation PASSED          [ 87%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_business_value_score_range FAILED           [ 88%]
tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_from_orm_model FAILED                   [ 88%]
tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_serialization FAILED                    [ 89%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_partial_update_all_fields_optional PASSED   [ 89%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_update_validation_rules_still_apply PASSED  [ 89%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_update_with_multiple_fields PASSED          [ 90%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_duplicate_task_id PASSED                      [ 90%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_create_task_full_lifecycle PASSED             [ 90%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_list_tasks_pagination_and_filtering PASSED    [ 91%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_task_validation_errors PASSED                 [ 91%]
tests/unit/services/test_services.py::TestActionListService::test_remove_item ERROR                              [ 91%]
tests/unit/services/test_services.py::TestActionListService::test_get_soft_deleted ERROR                         [ 92%]
tests/unit/services/test_services.py::TestActionListService::test_reorder_items_success ERROR                    [ 92%]
tests/unit/services/test_services.py::TestActionListService::test_add_item ERROR                                 [ 93%]
tests/unit/services/test_services.py::TestActionListService::test_mark_complete ERROR                            [ 93%]
tests/unit/services/test_services.py::TestActionListService::test_reorder_items_invalid_length ERROR             [ 93%]
tests/unit/services/test_services.py::TestActionListService::test_get_orphaned ERROR                             [ 94%]
tests/unit/services/test_services.py::TestSprintService::test_get_by_project ERROR                               [ 94%]
tests/unit/services/test_services.py::TestSprintService::test_get_current_sprints ERROR                          [ 94%]
tests/unit/services/test_services.py::TestSprintService::test_get_burndown ERROR                                 [ 95%]
tests/unit/services/test_services.py::TestSprintService::test_update_metrics ERROR                               [ 95%]
tests/unit/services/test_services.py::TestSprintService::test_change_status ERROR                                [ 95%]
tests/unit/services/test_services.py::TestSprintService::test_calculate_velocity ERROR                           [ 96%]
tests/unit/services/test_services.py::TestProjectService::test_change_status ERROR                               [ 96%]
tests/unit/services/test_services.py::TestProjectService::test_get_by_owner ERROR                                [ 97%]
tests/unit/services/test_services.py::TestProjectService::test_add_sprint ERROR                                  [ 97%]
tests/unit/services/test_services.py::TestProjectService::test_remove_sprint ERROR                               [ 97%]
tests/unit/services/test_services.py::TestProjectService::test_get_metrics_success ERROR                         [ 98%]
tests/unit/services/test_services.py::TestProjectService::test_get_by_status ERROR                               [ 98%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_duplicate_project_id PASSED             [ 98%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_metrics_endpoint PASSED         [ 99%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_validation_errors PASSED        [ 99%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_crud_lifecycle PASSED           [100%]

======================================================= ERRORS ========================================================
______________________ ERROR at setup of TestSprintServiceMetrics.test_get_burndown_calculations ______________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestSprintServiceMetrics.test_calculate_velocity_mixed_tasks ____________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestProjectServiceMetrics.test_get_metrics_project_not_found ____________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________ ERROR at setup of TestProjectServiceMetrics.test_get_metrics_no_tasks ________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________ ERROR at setup of TestProjectServiceBoundaryConditions.test_update_project_partial_single_field ___________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________ ERROR at setup of TestProjectServiceBoundaryConditions.test_update_project_empty_mission _______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________ ERROR at setup of TestProjectServiceBoundaryConditions.test_create_project_with_all_fields ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________ ERROR at setup of TestProjectServiceBoundaryConditions.test_create_project_with_minimum_fields ____________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________ ERROR at setup of TestProjectServiceSearchAndFiltering.test_get_by_status_no_results _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________ ERROR at setup of TestProjectServiceSearchAndFiltering.test_get_by_owner_no_results _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__________________ ERROR at setup of TestProjectServiceStatusTransitions.test_change_status_success ___________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________ ERROR at setup of TestProjectServiceStatusTransitions.test_change_status_project_not_found ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________ ERROR at setup of TestProjectServiceSprintManagement.test_remove_sprint_from_project _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________ ERROR at setup of TestProjectServiceSprintManagement.test_add_duplicate_sprint_idempotent ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestProjectServiceSprintManagement.test_add_sprint_to_project ___________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__________________ ERROR at setup of TestMinimalSettingsFixture.test_fixture_provides_minimal_config __________________

    @pytest.fixture
    def minimal_test_settings() -> Settings:
        """
        Provide minimal test settings without Redis.
    
        Useful for tests that don't require caching.
    
        Returns:
            Settings with only required configuration
    
        Example:
            >>> def test_no_cache(minimal_test_settings):
            ...     assert minimal_test_settings.redis is None
        """
>       return Settings(
            environment="testing",
            database=DatabaseConfig(
                host="localhost",
                port=5433,
                user="taskman_test",
                password=SecretStr("test_password"),
                database="taskman_test",
            ),
            redis=None,  # No Redis for minimal tests
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a354d8b0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ord@localhost:5433/taskman_test'), 'environment': 'testing', 'jwt_secret': SecretStr('**********'), 'redis': None, ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________ ERROR at setup of TestProductionLikeFixture.test_fixture_has_production_database ___________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3a45d10>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestProductionLikeFixture.test_fixture_has_production_redis ____________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a354f930>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestProductionLikeFixture.test_fixture_simulates_production ____________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3a772a0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________ ERROR at setup of TestEnvironmentIsolation.test_settings_default_to_testing _____________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3417840>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________________ ERROR at setup of TestSettingsFixture.test_fixture_includes_redis __________________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3414be0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________ ERROR at setup of TestSettingsFixture.test_fixture_includes_database _________________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a33bad00>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestSettingsFixture.test_fixture_provides_complete_settings ____________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a33bbb10>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________________________ ERROR at setup of test_init_creates_engines _____________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\pkgutil.py:528: AttributeError
_____________________________________ ERROR at setup of test_get_session_failover _____________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\pkgutil.py:528: AttributeError
_________________________________ ERROR at setup of test_get_session_primary_success __________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\pkgutil.py:528: AttributeError
____________________________________ ERROR at setup of test_health_check_reporting ____________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\pkgutil.py:528: AttributeError
__________________________________ ERROR at setup of test_health_check_primary_down ___________________________________

    @pytest.fixture
    def mock_engines():
>       with patch("db.connection_manager.create_async_engine") as mock_create:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\db\test_connection_manager.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'db.connection_manager'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'db' has no attribute 'connection_manager'

C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\pkgutil.py:528: AttributeError
______________________________ ERROR at setup of TestActionListService.test_remove_item _______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestActionListService.test_get_soft_deleted ____________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________________ ERROR at setup of TestActionListService.test_reorder_items_success __________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestActionListService.test_add_item ________________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ ERROR at setup of TestActionListService.test_mark_complete ______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________ ERROR at setup of TestActionListService.test_reorder_items_invalid_length ______________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________ ERROR at setup of TestActionListService.test_get_orphaned ______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_get_by_project _______________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestSprintService.test_get_current_sprints _____________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestSprintService.test_get_burndown ________________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_update_metrics _______________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_change_status ________________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ ERROR at setup of TestSprintService.test_calculate_velocity _____________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_change_status _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_get_by_owner ________________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestProjectService.test_add_sprint _________________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_remove_sprint _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestProjectService.test_get_metrics_success ____________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_get_by_status _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
====================================================== FAILURES =======================================================
______________________________ TestActionListSchemas.test_action_list_soft_delete_fields ______________________________

self = <test_schemas.TestActionListSchemas object at 0x000002B1A3183650>

    def test_action_list_soft_delete_fields(self):
        """Test action list soft delete fields."""
        data = {
            "id": "AL-TEST",
            "title": "Action List",
            "status": "deleted",
            "parent_deleted_at": datetime(2025, 1, 1, 12, 0, 0),
            "parent_deletion_note": {"reason": "Project closed"},
            "items": [],
        }
    
>       request = ActionListCreateRequest(**data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ActionListCreate
E       status
E         Input should be 'active' or 'archived' [type=enum, input_value='deleted', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/enum

tests\unit\schemas\test_schemas.py:284: ValidationError
________________________________ TestProjectSchemas.test_project_create_request_valid _________________________________

self = <test_schemas.TestProjectSchemas object at 0x000002B1A3181F40>

    def test_project_create_request_valid(self):
        """Test creating a valid project create request."""
        data = {
            "id": "P-TEST-001",
            "name": "Test Project",
            "mission": "Test mission",
            "start_date": date(2025, 1, 1),
            "owner": "test.owner",
        }
    
        request = ProjectCreateRequest(**data)
        assert request.id == "P-TEST-001"
>       assert request.status == ProjectStatus.DISCOVERY  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <ProjectStatu...G: 'planning'> == <ProjectStatu...: 'discovery'>
E         
E         - discovery
E         + planning

tests\unit\schemas\test_schemas.py:36: AssertionError
_________________________________ TestSprintSchemas.test_sprint_create_request_valid __________________________________

self = <test_schemas.TestSprintSchemas object at 0x000002B1A3182BA0>

    def test_sprint_create_request_valid(self):
        """Test creating a valid sprint create request."""
        data = {
            "id": "S-2025-01",
            "name": "Sprint 1",
            "goal": "Sprint goal",
            "cadence": SprintCadence.BIWEEKLY,
            "start_date": date(2025, 1, 1),
            "end_date": date(2025, 1, 14),
            "owner": "scrum.master",
            "primary_project": "P-TEST",
        }
    
        request = SprintCreateRequest(**data)
        assert request.id == "S-2025-01"
>       assert request.status == SprintStatus.PLANNED  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <SprintStatus...G: 'planning'> == <SprintStatus...ED: 'planned'>
E         
E         - planned
E         + planning

tests\unit\schemas\test_schemas.py:134: AssertionError
_________________________________ TestSprintSchemas.test_sprint_response_with_metrics _________________________________

self = <test_schemas.TestSprintSchemas object at 0x000002B1A3180EF0>

    def test_sprint_response_with_metrics(self):
        """Test sprint response with metrics."""
        data = {
            "id": "S-TEST",
            "name": "Sprint",
            "goal": "Goal",
            "cadence": SprintCadence.BIWEEKLY,
            "start_date": date(2025, 1, 1),
            "end_date": date(2025, 1, 14),
            "status": SprintStatus.ACTIVE,
            "owner": "owner",
            "primary_project": "P-TEST",
            "tasks": [],
            "imported_tasks": [],
            "related_projects": [],
            "velocity_target_points": 20.0,
            "committed_points": 18.0,
            "actual_points": 16.0,
            "carried_over_points": 2.0,
            "definition_of_done": [],
            "dependencies": {},
            "scope_changes": [],
            "risks": [],
            "ceremonies": {},
            "metrics": {"throughput": 16, "predictability_pct": 88.9},
            "timezone": "America/New_York",
            "observability": {},
            "created_at": datetime(2025, 1, 1),
            "updated_at": datetime(2025, 1, 1),
        }
    
>       response = SprintResponse(**data)
                   ^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for SprintResponse
E       dependencies
E         Input should be a valid list [type=list_type, input_value={}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/list_type

tests\unit\schemas\test_schemas.py:236: ValidationError
_______________________________ TestBaseSchemaConfiguration.test_strict_type_validation _______________________________

self = <test_schemas.TestBaseSchemaConfiguration object at 0x000002B1A31D4050>

    def test_strict_type_validation(self):
        """Test that type coercion is enabled (strict=False)."""
>       from taskman_api.schemas.base import BaseSchema
E       ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)

tests\unit\schemas\test_schemas.py:336: ImportError
______________________________ TestBaseSchemaConfiguration.test_from_attributes_orm_mode ______________________________

self = <test_schemas.TestBaseSchemaConfiguration object at 0x000002B1A31D4260>

    def test_from_attributes_orm_mode(self):
        """Test ORM mode (from_attributes) is enabled."""
>       from taskman_api.schemas.base import BaseSchema
E       ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)

tests\unit\schemas\test_schemas.py:348: ImportError
_____________________________ TestTaskRepository.test_find_by_project_with_status_filter ______________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3162AE0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A342DA30>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_project_with_status_filter(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by project with status filter."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.NEW, TaskStatus.IN_PROGRESS, TaskStatus.NEW]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_project(sample_project.id, status=TaskStatus.NEW)
                       ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_project'. Did you mean: 'get_by_project'?

tests\unit\db\repositories\test_task_repository.py:317: AttributeError
_____________________________________ TestTaskRepository.test_find_blocked_tasks ______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3163620>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A361E840>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_blocked_tasks(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding all blocked tasks."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.BLOCKED, TaskStatus.NEW, TaskStatus.BLOCKED]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_blocked_tasks()
                       ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_blocked_tasks'

tests\unit\db\repositories\test_task_repository.py:485: AttributeError
_________________________________ TestTaskRepository.test_find_by_status_and_priority _________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3163260>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A36B8AD0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_status_and_priority(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by status and priority (composite index)."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with various combinations
        combos = [
            (TaskStatus.NEW, Priority.P0),
            (TaskStatus.NEW, Priority.P1),
            (TaskStatus.IN_PROGRESS, Priority.P0),
            (TaskStatus.NEW, Priority.P0),
        ]
    
        for i, (status, priority) in enumerate(combos):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_status_and_priority(TaskStatus.NEW, Priority.P0)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_status_and_priority'

tests\unit\db\repositories\test_task_repository.py:431: AttributeError
________________________________________ TestTaskRepository.test_find_by_owner ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3162360>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A36EE5A0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_owner(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by owner."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different owners
        for i, owner in enumerate(["alice", "bob", "alice"]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner=owner,
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_owner("alice")
                       ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_owner'

tests\unit\db\repositories\test_task_repository.py:173: AttributeError
_______________________________________ TestTaskRepository.test_find_by_project _______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3162720>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A366FE60>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_project(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by project."""
        # Arrange
        repo = TaskRepository(async_session)
    
        # Create second project
        from datetime import date
    
        from taskman_api.core.enums import ProjectStatus
        from taskman_api.models.project import Project
    
>       project2 = Project(
            id="P-TEST-002",
            name="Project 2",
            mission="Mission 2",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            owner="owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=[],
            related_projects=[],
            shared_components=[],
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            observability={},
        )

tests\unit\db\repositories\test_task_repository.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-002', name='Project 2', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________________ TestTaskRepository.test_find_by_sprint ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3162EA0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3772660>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_sprint(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by sprint."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks
        for i in range(3):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_sprint(sample_sprint.id)
                       ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_sprint'. Did you mean: 'get_by_sprint'?

tests\unit\db\repositories\test_task_repository.py:371: AttributeError
__________________________________ TestTaskRepository.test_find_high_priority_tasks ___________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A31639E0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3772210>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_high_priority_tasks(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding P0 and P1 (critical/high priority) tasks."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different priorities
        for i, priority in enumerate([Priority.P0, Priority.P1, Priority.P2, Priority.P0]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_high_priority_tasks()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_high_priority_tasks'

tests\unit\db\repositories\test_task_repository.py:539: AttributeError
______________________________________ TestTaskRepository.test_find_by_priority _______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3161FA0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3786BD0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_priority(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by priority."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different priorities
        for i, priority in enumerate([Priority.P0, Priority.P1, Priority.P0]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_priority(Priority.P0)
                       ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_priority'

tests\unit\db\repositories\test_task_repository.py:119: AttributeError
_______________________________________ TestTaskRepository.test_find_by_status ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000002B1A3161340>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3899790>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_status(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by status."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.NEW, TaskStatus.IN_PROGRESS, TaskStatus.NEW]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_status(TaskStatus.NEW)
                       ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_status'. Did you mean: 'get_by_status'?

tests\unit\db\repositories\test_task_repository.py:65: AttributeError
______________________________________ TestBaseServiceDelete.test_delete_success ______________________________________

self = <test_base_service.TestBaseServiceDelete object at 0x000002B1A31B5850>
mock_task_repository = <Mock id='2961976161056'>

    @pytest.mark.asyncio
    async def test_delete_success(self, mock_task_repository):
        """Test successful entity deletion."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.delete("T-TEST-001")
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A37F7D40>, Ok)

tests\unit\services\test_base_service.py:191: AssertionError
_____________________________________ TestBaseServiceDelete.test_delete_not_found _____________________________________

self = <test_base_service.TestBaseServiceDelete object at 0x000002B1A31B5C40>
mock_task_repository = <Mock id='2961975200608'>

    @pytest.mark.asyncio
    async def test_delete_not_found(self, mock_task_repository):
        """Test delete with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return NotFoundError
        mock_task_repository.delete = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.delete("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:218: AssertionError
______________________________________ TestBaseServiceUpdate.test_update_success ______________________________________

self = <test_base_service.TestBaseServiceUpdate object at 0x000002B1A31B5010>
mock_task_repository = <Mock id='2961977165104'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_update_success(self, mock_task_repository, sample_task):
        """Test successful entity update."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        update_request = TaskUpdateRequest(title="Updated Title")
    
        # Act
        result = await service.update("T-TEST-001", update_request)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A38BE6F0>, Ok)

tests\unit\services\test_base_service.py:144: AssertionError
_____________________________________ TestBaseServiceUpdate.test_update_not_found _____________________________________

self = <test_base_service.TestBaseServiceUpdate object at 0x000002B1A31B53D0>
mock_task_repository = <Mock id='2961976323984'>

    @pytest.mark.asyncio
    async def test_update_not_found(self, mock_task_repository):
        """Test update with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        update_request = TaskUpdateRequest(title="Updated")
    
        # Mock repository to return NotFoundError
        mock_task_repository.find_by_id = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.update("T-NONEXISTENT", update_request)
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:174: AssertionError
_______________________________________ TestBaseServiceUtility.test_exists_true _______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000002B1A31B6960>
mock_task_repository = <Mock id='2961977230544'>

    @pytest.mark.asyncio
    async def test_exists_true(self, mock_task_repository):
        """Test exists returns True for existing entity."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.exists("T-TEST-001")
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() is True
E       assert <taskman_api.core.result.Ok object at 0x000002B1A3981940> is True
E        +  where <taskman_api.core.result.Ok object at 0x000002B1A3981940> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000002B1A399EBA0>.ok

tests\unit\services\test_base_service.py:274: AssertionError
______________________________________ TestBaseServiceUtility.test_count_success ______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000002B1A31B5B20>
mock_task_repository = <Mock id='2961975497296'>

    @pytest.mark.asyncio
    async def test_count_success(self, mock_task_repository):
        """Test count returns total entity count."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return count
        mock_task_repository.count = AsyncMock(return_value=Ok(42))
    
        # Act
        result = await service.count()
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() == 42
E       assert <taskman_api.core.result.Ok object at 0x000002B1A37F6EA0> == 42
E        +  where <taskman_api.core.result.Ok object at 0x000002B1A37F6EA0> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000002B1A38DE750>.ok

tests\unit\services\test_base_service.py:307: AssertionError
______________________________________ TestBaseServiceUtility.test_exists_false _______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000002B1A31B68A0>
mock_task_repository = <Mock id='2961976455344'>

    @pytest.mark.asyncio
    async def test_exists_false(self, mock_task_repository):
        """Test exists returns False for non-existent entity."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return False
        mock_task_repository.exists = AsyncMock(return_value=Ok(False))
    
        # Act
        result = await service.exists("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() is False
E       assert <taskman_api.core.result.Ok object at 0x000002B1A38DD5E0> is False
E        +  where <taskman_api.core.result.Ok object at 0x000002B1A38DD5E0> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000002B1A38FA300>.ok

tests\unit\services\test_base_service.py:291: AssertionError
________________________________________ TestBaseServiceGet.test_get_not_found ________________________________________

self = <test_base_service.TestBaseServiceGet object at 0x000002B1A31B4B60>
mock_task_repository = <Mock id='2961976568832'>

    @pytest.mark.asyncio
    async def test_get_not_found(self, mock_task_repository):
        """Test get with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return NotFoundError
        mock_task_repository.find_by_id = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.get("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:126: AssertionError
_________________________________________ TestBaseServiceGet.test_get_success _________________________________________

self = <test_base_service.TestBaseServiceGet object at 0x000002B1A31B47A0>
mock_task_repository = <Mock id='2961976455104'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_success(self, mock_task_repository, sample_task):
        """Test successful entity retrieval."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.get("T-TEST-001")
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3773710>, Ok)

tests\unit\services\test_base_service.py:97: AssertionError
________________________________________ TestBaseServiceList.test_list_success ________________________________________

self = <test_base_service.TestBaseServiceList object at 0x000002B1A31B60F0>
mock_task_repository = <Mock id='2961977115136'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_list_success(self, mock_task_repository, sample_task):
        """Test successful entity listing with pagination."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.list(limit=50, offset=0)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3937B60>, Ok)

tests\unit\services\test_base_service.py:234: AssertionError
_____________________________________ TestBaseServiceList.test_list_empty_result ______________________________________

self = <test_base_service.TestBaseServiceList object at 0x000002B1A31B64B0>
mock_task_repository = <Mock id='2961976624384'>

    @pytest.mark.asyncio
    async def test_list_empty_result(self, mock_task_repository):
        """Test list with no results returns empty list."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return empty list
        mock_task_repository.find_all = AsyncMock(return_value=Ok([]))
    
        # Act
        result = await service.list()
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3A8F650>, Ok)

tests\unit\services\test_base_service.py:254: AssertionError
__________________________________ TestBaseServiceCreate.test_create_conflict_error ___________________________________

self = <test_base_service.TestBaseServiceCreate object at 0x000002B1A31B4560>
mock_task_repository = <Mock id='2961978196528'>

    @pytest.mark.asyncio
    async def test_create_conflict_error(self, mock_task_repository):
        """Test creation with duplicate ID returns ConflictError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        request = TaskCreateRequest(
            id="T-DUPLICATE",
            title="Task",
            summary="Summary",
            description="Description",
            owner="owner",
            priority=Priority.P1,
            primary_project="P-001",
            primary_sprint="S-001",
        )
    
        # Mock repository to return ConflictError
        mock_task_repository.create = AsyncMock(
            return_value=Err(
                ConflictError(
                    message="Entity already exists",
                    entity_type="Task",
                    entity_id="T-DUPLICATE",
                )
            )
        )
    
        # Act
        result = await service.create(request)
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, ConflictError)
E       assert False
E        +  where False = isinstance(AppError("9 validation errors for TaskResponse\nid\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\ntitle\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nsummary\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\ndescription\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nstatus\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nowner\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\npriority\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nprimary_project\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nprimary_sprint\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing"), ConflictError)

tests\unit\services\test_base_service.py:80: AssertionError
______________________________________ TestBaseServiceCreate.test_create_success ______________________________________

self = <test_base_service.TestBaseServiceCreate object at 0x000002B1A31B4170>
mock_task_repository = <Mock id='2961976808832'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_create_success(self, mock_task_repository, sample_task):
        """Test successful entity creation."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        request = TaskCreateRequest(
            id="T-TEST-001",
            title="Test Task",
            summary="Summary",
            description="Description",
            owner="test.owner",
            priority=Priority.P1,
            primary_project="P-TEST-001",
            primary_sprint="S-TEST-001",
        )
    
        # Act
        result = await service.create(request)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A37ACF80>, Ok)

tests\unit\services\test_base_service.py:41: AssertionError
_____________________________________ TestActionListRepository.test_find_orphaned _____________________________________

self = <test_repositories.TestActionListRepository object at 0x000002B1A31602F0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A37AF710>

    async def test_find_orphaned(self, async_session: AsyncSession):
        """Test finding orphaned action lists."""
        from taskman_api.models.action_list import ActionList
    
        repo = ActionListRepository(async_session)
    
        # Create orphaned action list
>       orphaned = ActionList(
            id="AL-ORPHAN-001",
            title="Orphaned List",
            status="active",
            items=[],
            tags=[],
            evidence_refs=[],
            extra_metadata={},
            parent_deletion_note={},
        )

tests\unit\db\repositories\test_repositories.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-ORPHAN-001', name=None, status=None)>
kwargs = {'evidence_refs': [], 'extra_metadata': {}, 'id': 'AL-ORPHAN-001', 'items': [], ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________________ TestActionListRepository.test_find_by_owner _____________________________________

self = <test_repositories.TestActionListRepository object at 0x000002B1A314FCE0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A37AEDB0>

    async def test_find_by_owner(self, async_session: AsyncSession):
        """Test finding action lists by owner."""
        from taskman_api.models.action_list import ActionList
    
        repo = ActionListRepository(async_session)
    
        # Create action lists with different owners
        for i, owner in enumerate(["alice", "bob", "alice"]):
>           action_list = ActionList(
                id=f"AL-TEST-{i:03d}",
                title=f"List {i}",
                status="active",
                owner=owner,
                items=[],
                tags=[],
                evidence_refs=[],
                extra_metadata={},
                parent_deletion_note={},
            )

tests\unit\db\repositories\test_repositories.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-000', name=None, status=None)>
kwargs = {'evidence_refs': [], 'extra_metadata': {}, 'id': 'AL-TEST-000', 'items': [], ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________________________ TestProjectRepository.test_find_active_projects ___________________________________

self = <test_repositories.TestProjectRepository object at 0x000002B1A314E480>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3982060>

    async def test_find_active_projects(self, async_session: AsyncSession):
        """Test finding all active projects."""
        from taskman_api.models.project import Project
    
        repo = ProjectRepository(async_session)
    
>       project = Project(
            id="P-ACTIVE-001",
            name="Active Project",
            mission="Mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            owner="owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=[],
            related_projects=[],
            shared_components=[],
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            observability={},
        )

tests\unit\db\repositories\test_repositories.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-ACTIVE-001', name='Active Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________________ TestProjectRepository.test_find_by_status ______________________________________

self = <test_repositories.TestProjectRepository object at 0x000002B1A314F140>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3983D10>

    async def test_find_by_status(self, async_session: AsyncSession):
        """Test finding projects by status."""
        from taskman_api.models.project import Project
    
        repo = ProjectRepository(async_session)
    
        # Create projects with different statuses
        for i, status in enumerate([ProjectStatus.ACTIVE, ProjectStatus.PAUSED, ProjectStatus.ACTIVE]):
>           project = Project(
                id=f"P-TEST-{i:03d}",
                name=f"Project {i}",
                mission=f"Mission {i}",
                status=status,
                start_date=date(2025, 1, 1),
                owner="owner",
                sponsors=[],
                stakeholders=[],
                repositories=[],
                comms_channels=[],
                okrs=[],
                kpis=[],
                roadmap=[],
                risks=[],
                assumptions=[],
                constraints=[],
                dependencies_external=[],
                sprints=[],
                related_projects=[],
                shared_components=[],
                compliance_requirements=[],
                governance={},
                success_metrics=[],
                mpv_policy={},
                observability={},
            )

tests\unit\db\repositories\test_repositories.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-000', name='Project 0', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________________ TestSprintRepository.test_find_active_sprints ____________________________________

self = <test_repositories.TestSprintRepository object at 0x000002B1A314F890>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3982B10>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>

    async def test_find_active_sprints(self, async_session: AsyncSession, sample_project):
        """Test finding all active sprints."""
        from taskman_api.core.enums import SprintCadence
        from taskman_api.models.sprint import Sprint
    
        async_session.add(sample_project)
        await async_session.commit()
    
        repo = SprintRepository(async_session)
    
>       sprint = Sprint(
            id="S-ACTIVE-001",
            name="Active Sprint",
            goal="Goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="owner",
            primary_project=sample_project.id,
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            observability={},
        )

tests\unit\db\repositories\test_repositories.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-ACTIVE-001', name='Active Sprint', status='SprintStatus.ACTIVE')>
kwargs = {'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'ceremonies': {}, 'definition_of_done': [], 'dependencies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________________ TestSprintRepository.test_find_by_status _______________________________________

self = <test_repositories.TestSprintRepository object at 0x000002B1A314CD40>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A38A6870>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>

    async def test_find_by_status(self, async_session: AsyncSession, sample_project):
        """Test finding sprints by status."""
        from taskman_api.core.enums import SprintCadence
        from taskman_api.models.sprint import Sprint
    
        async_session.add(sample_project)
        await async_session.commit()
    
        repo = SprintRepository(async_session)
    
        # Create sprints with different statuses
        for i, status in enumerate([SprintStatus.ACTIVE, SprintStatus.PLANNED, SprintStatus.ACTIVE]):
>           sprint = Sprint(
                id=f"S-TEST-{i:03d}",
                name=f"Sprint {i}",
                goal=f"Goal {i}",
                cadence=SprintCadence.BIWEEKLY,
                start_date=date(2025, 1, 1),
                end_date=date(2025, 1, 14),
                status=status,
                owner="owner",
                primary_project=sample_project.id,
                tasks=[],
                imported_tasks=[],
                related_projects=[],
                definition_of_done=[],
                dependencies={},
                scope_changes=[],
                risks=[],
                ceremonies={},
                metrics={},
                observability={},
            )

tests\unit\db\repositories\test_repositories.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
..\..\.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-000', name='Sprint 0', status='SprintStatus.ACTIVE')>
kwargs = {'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'ceremonies': {}, 'definition_of_done': [], 'dependencies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

..\..\.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________________________________ TestSettings.test_with_redis_config _________________________________________

self = <test_config.TestSettings object at 0x000002B1A32605F0>

    def test_with_redis_config(self):
        """Test settings with Redis configuration provided."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                db=1,
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a33de2b0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=5, db=1), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________________________ TestSettings.test_valid_settings_development _____________________________________

self = <test_config.TestSettings object at 0x000002B1A3243650>

    def test_valid_settings_development(self):
        """Test valid settings for development environment."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("dev_password"),
                database="taskman_dev",
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3445d60>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...kman_dev'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_______________________________________ TestSettings.test_optional_redis_config _______________________________________

self = <test_config.TestSettings object at 0x000002B1A3260380>

    def test_optional_redis_config(self):
        """Test that Redis configuration is optional."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            redis=None,  # Optional
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3444230>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...d@localhost:5432/taskman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'redis': None, ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________ TestSettings.test_development_allows_insecure_secrets ________________________________

self = <test_config.TestSettings object at 0x000002B1A3243BF0>

    def test_development_allows_insecure_secrets(self):
        """Test that development environment allows test secrets."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            secret_key=SecretStr("INSECURE_DEV_KEY_32_CHARACTERS_MIN"),
            jwt_secret=SecretStr("test-key-for-development-32-chars"),
        )

tests\unit\test_config.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3446e40>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...skman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________________________ TestSettings.test_valid_settings_production _____________________________________

self = <test_config.TestSettings object at 0x000002B1A3242DE0>

    def test_valid_settings_production(self):
        """Test valid settings for production environment."""
>       settings = Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("prod_secure_password_123"),
                database="taskman_production",
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\unit\test_config.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a34456d0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...roduction'), 'environment': 'production', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________________ TestSettings.test_environment_helpers ________________________________________

self = <test_config.TestSettings object at 0x000002B1A3260D40>

    def test_environment_helpers(self):
        """Test environment helper properties."""
        # Development
>       dev_settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3447890>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...skman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________________________________ TestGetSettings.test_cache_clear ___________________________________________

self = <test_config.TestGetSettings object at 0x000002B1A3261100>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000002B1A38BF8C0>

    def test_cache_clear(self, monkeypatch):
        """Test that cache_clear forces reload."""
        # Set environment variables
        monkeypatch.setenv("APP_ENVIRONMENT", "testing")
        monkeypatch.setenv("APP_DATABASE__HOST", "localhost")
        monkeypatch.setenv("APP_DATABASE__PORT", "5432")
        monkeypatch.setenv("APP_DATABASE__USER", "taskman")
        monkeypatch.setenv("APP_DATABASE__PASSWORD", "test_password")
        monkeypatch.setenv("APP_DATABASE__DATABASE", "taskman_test")
        monkeypatch.setenv("APP_SECRET_KEY", "test-secret-key-min-32-characters")
        monkeypatch.setenv("APP_JWT_SECRET", "test-jwt-secret-min-32-characters")
    
        # First call
>       settings1 = get_settings()
                    ^^^^^^^^^^^^^^

tests\unit\test_config.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\config.py:290: in get_settings
    return Settings()
           ^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a37c78e0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________________ TestGetSettings.test_settings_cached _________________________________________

self = <test_config.TestGetSettings object at 0x000002B1A3260F20>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000002B1A390A9C0>

    def test_settings_cached(self, monkeypatch):
        """Test that settings are cached across calls."""
        # Set environment variables for this test
        monkeypatch.setenv("APP_ENVIRONMENT", "testing")
        monkeypatch.setenv("APP_DATABASE__HOST", "localhost")
        monkeypatch.setenv("APP_DATABASE__PORT", "5432")
        monkeypatch.setenv("APP_DATABASE__USER", "taskman")
        monkeypatch.setenv("APP_DATABASE__PASSWORD", "test_password")
        monkeypatch.setenv("APP_DATABASE__DATABASE", "taskman_test")
        monkeypatch.setenv("APP_SECRET_KEY", "test-secret-key-min-32-characters")
        monkeypatch.setenv("APP_JWT_SECRET", "test-jwt-secret-min-32-characters")
    
        # First call
>       settings1 = get_settings()
                    ^^^^^^^^^^^^^^

tests\unit\test_config.py:422: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\config.py:290: in get_settings
    return Settings()
           ^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x2b1a3914c80>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden

..\..\.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________ TestTaskServiceBulkOperationEdgeCases.test_bulk_update_partial_failure_fails_fast __________________

self = <test_task_service_edge_cases.TestTaskServiceBulkOperationEdgeCases object at 0x000002B1A3240200>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3A8F320>
mock_task_repository = <Mock name='TaskRepository()' id='2961978219296'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_partial_failure_fails_fast(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test bulk update fails on first error and doesn't continue.
    
        Ensures fail-fast behavior: if task 2 fails, task 3 should not be processed.
        """
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # First task succeeds, second task fails (not found)
            mock_task_repository.find_by_id = AsyncMock(
                side_effect=[
                    Ok(sample_task),  # Task 1 found
                    Err(
                        NotFoundError(
                            message="Task not found",
                            entity_type="Task",
                            entity_id="T-NONEXISTENT",
                        )
                    ),  # Task 2 not found
                ]
            )
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-NONEXISTENT", "status": "done"},  # This will fail
                {"id": "T-003", "status": "blocked"},  # This should not be processed
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service_edge_cases.py:303: AssertionError
________________________ TestTaskServiceAssignmentEdgeCases.test_assign_to_nonexistent_project ________________________

self = <test_task_service_edge_cases.TestTaskServiceAssignmentEdgeCases object at 0x000002B1A3240E00>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3899700>
mock_task_repository = <Mock name='TaskRepository()' id='2961976170912'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_nonexistent_project(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to non-existent project propagates error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task exists
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Update fails (foreign key constraint)
            mock_task_repository.update = AsyncMock(
                return_value=Err(
                    ValidationError(
                        message="Project not found",
                        field="primary_project",
                        value="P-NONEXISTENT",
                    )
                )
            )
    
            # Act
>           result = await service.assign_to_project("T-TEST-001", "P-NONEXISTENT")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service_edge_cases.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:274: in assign_to_project
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:103: in update
    project = await self.project_repo.get_by_id(update_data.primary_project)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.project_repository.ProjectRepository object at 0x000002B1A390B7D0>
entity_id = 'P-NONEXISTENT'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
________________________ TestTaskServiceAssignmentEdgeCases.test_assign_to_nonexistent_sprint _________________________

self = <test_task_service_edge_cases.TestTaskServiceAssignmentEdgeCases object at 0x000002B1A3240A40>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3A7DB50>
mock_task_repository = <Mock name='TaskRepository()' id='2961978156256'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_nonexistent_sprint(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to non-existent sprint propagates error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task exists
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Update fails (foreign key constraint)
            mock_task_repository.update = AsyncMock(
                return_value=Err(
                    ValidationError(
                        message="Sprint not found",
                        field="primary_sprint",
                        value="S-NONEXISTENT",
                    )
                )
            )
    
            # Act
>           result = await service.assign_to_sprint("T-TEST-001", "S-NONEXISTENT")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service_edge_cases.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:249: in assign_to_sprint
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:115: in update
    sprint = await self.sprint_repo.get_by_id(update_data.primary_sprint)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.sprint_repository.SprintRepository object at 0x000002B1A3A3EE10>
entity_id = 'S-NONEXISTENT'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
_____________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_new_to_ready _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322DD60>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3A25A30>
mock_task_repository = <Mock name='TaskRepository()' id='2961977792352'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_new_to_ready(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from NEW to READY."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Create task in NEW status
            task_new = copy.deepcopy(sample_task)
            task_new.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_new))
    
            # Mock update to return task in READY status
            task_ready = copy.deepcopy(sample_task)
            task_ready.status = TaskStatus.READY
            mock_task_repository.update = AsyncMock(return_value=Ok(task_ready))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A38FA9C0>, Ok)

tests\unit\services\test_task_service_edge_cases.py:47: AssertionError
____________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_new_to_done _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322F9B0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A38FA510>
mock_task_repository = <Mock name='TaskRepository()' id='2961971536832'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_new_to_done(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from NEW to DONE (skip intermediate states)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in NEW status
            task_new = copy.deepcopy(sample_task)
            task_new.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_new))
    
            # Act - attempt to jump directly to DONE
            result = await service.change_status("T-TEST-001", TaskStatus.DONE)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:226: AssertionError
_________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_in_progress_to_done __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322EB70>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A35551F0>
mock_task_repository = <Mock name='TaskRepository()' id='2961972741856'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_in_progress_to_done(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from IN_PROGRESS to DONE."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in IN_PROGRESS status
            task_in_progress = copy.deepcopy(sample_task)
            task_in_progress.status = TaskStatus.IN_PROGRESS
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Ok(task_in_progress)
            )
    
            # Mock update to return DONE task
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.update = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.DONE)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3899A00>, Ok)

tests\unit\services\test_task_service_edge_cases.py:113: AssertionError
____________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_done_to_new _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322EF00>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A37F25D0>
mock_task_repository = <Mock name='TaskRepository()' id='2961975490128'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_done_to_new(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DONE (terminal state) to NEW.
    
        DONE is a terminal state - no transitions allowed.
        """
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DONE status (terminal state)
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.NEW)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:144: AssertionError
__________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_dropped_to_ready __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322F620>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A4BE8AD0>
mock_task_repository = <Mock name='TaskRepository()' id='2961996417600'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_dropped_to_ready(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DROPPED (terminal state) to READY."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DROPPED status (terminal state)
            task_dropped = copy.deepcopy(sample_task)
            task_dropped.status = TaskStatus.DROPPED
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_dropped))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:199: AssertionError
________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_done_to_in_progress _________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322F290>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A37F6720>
mock_task_repository = <Mock name='TaskRepository()' id='2961975508816'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_done_to_in_progress(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DONE (terminal state) to IN_PROGRESS."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DONE status (terminal state)
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.IN_PROGRESS)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:172: AssertionError
__________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_ready_to_blocked __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322FD40>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A391E5A0>
mock_task_repository = <Mock name='TaskRepository()' id='2961976714128'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_ready_to_blocked(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from READY to BLOCKED (must be IN_PROGRESS first)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in READY status
            task_ready = copy.deepcopy(sample_task)
            task_ready.status = TaskStatus.READY
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_ready))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.BLOCKED)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:253: AssertionError
________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_in_progress_to_blocked ________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000002B1A322CCE0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A4B9F1A0>
mock_task_repository = <Mock name='TaskRepository()' id='2961996115424'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_in_progress_to_blocked(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from IN_PROGRESS to BLOCKED."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in IN_PROGRESS status
            task_in_progress = copy.deepcopy(sample_task)
            task_in_progress.status = TaskStatus.IN_PROGRESS
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Ok(task_in_progress)
            )
    
            # Mock update to return BLOCKED task
            task_blocked = copy.deepcopy(sample_task)
            task_blocked.status = TaskStatus.BLOCKED
            mock_task_repository.update = AsyncMock(return_value=Ok(task_blocked))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.BLOCKED)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A4C64230>, Ok)

tests\unit\services\test_task_service_edge_cases.py:80: AssertionError
______________________________ TestActionListEndpoints.test_create_action_list_conflict _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BFB00>
client = <httpx.AsyncClient object at 0x000002B1A4BF4650>

    async def test_create_action_list_conflict(self, client):
        """Test duplicate action list ID returns 409."""
        action_list_data = {
            "id": "AL-CONFLICT-001",
            "title": "Conflict Test",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
    
        # Create first action list
        first_response = await client.post("/api/v1/action-lists", json=action_list_data)
        assert first_response.status_code == status.HTTP_201_CREATED
    
        # Attempt to create duplicate
        duplicate_response = await client.post("/api/v1/action-lists", json=action_list_data)
    
>       assert duplicate_response.status_code == status.HTTP_409_CONFLICT
E       assert 201 == 409
E        +  where 201 = <Response [201 Created]>.status_code
E        +  and   409 = status.HTTP_409_CONFLICT

tests\integration\api\test_endpoints.py:666: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "8dda17dc-5f73-4908-a6ed-b451fc291bc1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.739235Z", "level": "info"}
{"list_id": "AL-0001", "event": "action_list_created", "timestamp": "2025-12-29T00:00:24.756306Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 17.63, "correlation_id": "8dda17dc-5f73-4908-a6ed-b451fc291bc1", "event": "http_response", "timestamp": "2025-12-29T00:00:24.757305Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "3f7c996d-31c6-4767-8688-2f81ede0bb5f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.760305Z", "level": "info"}
{"list_id": "AL-0002", "event": "action_list_created", "timestamp": "2025-12-29T00:00:24.765304Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 6.22, "correlation_id": "3f7c996d-31c6-4767-8688-2f81ede0bb5f", "event": "http_response", "timestamp": "2025-12-29T00:00:24.766304Z", "level": "info"}
_______________________________ TestActionListEndpoints.test_create_action_list_success _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BE480>
client = <httpx.AsyncClient object at 0x000002B1A398DB20>

    async def test_create_action_list_success(self, client):
        """Test successful action list creation."""
        action_list_data = {
            "id": "AL-TEST-001",
            "title": "Test Action List",
            "description": "Test description",
            "status": "active",
            "owner": "list.owner",
        }
    
        response = await client.post("/api/v1/action-lists", json=action_list_data)
    
        assert response.status_code == status.HTTP_201_CREATED
        data = response.json()
>       assert data["id"] == "AL-TEST-001"
E       AssertionError: assert 'AL-0003' == 'AL-TEST-001'
E         
E         - AL-TEST-001
E         + AL-0003

tests\integration\api\test_endpoints.py:536: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "92c6e1e1-1775-4ef1-a083-139a4a35e072", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.814021Z", "level": "info"}
{"list_id": "AL-0003", "event": "action_list_created", "timestamp": "2025-12-29T00:00:24.822539Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 10.04, "correlation_id": "92c6e1e1-1775-4ef1-a083-139a4a35e072", "event": "http_response", "timestamp": "2025-12-29T00:00:24.823540Z", "level": "info"}
________________________________ TestActionListEndpoints.test_get_action_list_success _________________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BE900>
client = <httpx.AsyncClient object at 0x000002B1A3982F60>

    async def test_get_action_list_success(self, client):
        """Test getting action list by ID."""
        # Create action list
        action_list_data = {
            "id": "AL-GET-001",
            "title": "Get Test List",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Get action list
        response = await client.get("/api/v1/action-lists/AL-GET-001")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:554: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "31750dbe-72b5-400a-8160-29865ab5786d", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.916006Z", "level": "info"}
{"list_id": "AL-0004", "event": "action_list_created", "timestamp": "2025-12-29T00:00:24.925533Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 11.02, "correlation_id": "31750dbe-72b5-400a-8160-29865ab5786d", "event": "http_response", "timestamp": "2025-12-29T00:00:24.926534Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists/AL-GET-001", "query": null, "correlation_id": "5ebb6171-f877-42e2-b331-ad36f5d02e20", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.927534Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists/AL-GET-001", "status_code": 404, "duration_ms": 5.35, "correlation_id": "5ebb6171-f877-42e2-b331-ad36f5d02e20", "event": "http_response", "timestamp": "2025-12-29T00:00:24.933674Z", "level": "warning"}
_______________________________ TestActionListEndpoints.test_update_action_list_success _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BF200>
client = <httpx.AsyncClient object at 0x000002B1A38D6960>

    async def test_update_action_list_success(self, client):
        """Test updating action list returns 200."""
        # Create action list
        action_list_data = {
            "id": "AL-UPDATE-001",
            "title": "Original Title",
            "description": "Original Description",
            "status": "active",
            "owner": "owner",
        }
        create_response = await client.post("/api/v1/action-lists", json=action_list_data)
        assert create_response.status_code == status.HTTP_201_CREATED
    
        # Update action list
        update_data = {"title": "Updated Title", "description": "Updated Description"}
        response = await client.patch("/api/v1/action-lists/AL-UPDATE-001", json=update_data)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:596: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "2f297e98-414e-4331-ac1a-0510d1ac094d", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.986780Z", "level": "info"}
{"list_id": "AL-0005", "event": "action_list_created", "timestamp": "2025-12-29T00:00:24.995484Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 9.37, "correlation_id": "2f297e98-414e-4331-ac1a-0510d1ac094d", "event": "http_response", "timestamp": "2025-12-29T00:00:24.996484Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-UPDATE-001", "query": null, "correlation_id": "9bbe0430-a610-4d4f-82f7-75fd240f62a7", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:24.996484Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-UPDATE-001", "status_code": 405, "duration_ms": 0.41, "correlation_id": "9bbe0430-a610-4d4f-82f7-75fd240f62a7", "event": "http_response", "timestamp": "2025-12-29T00:00:24.997485Z", "level": "warning"}
___________________________________ TestActionListEndpoints.test_list_action_lists ____________________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BED80>
client = <httpx.AsyncClient object at 0x000002B1A39358B0>

    async def test_list_action_lists(self, client):
        """Test listing action lists."""
        # Create action lists
        for i in range(3):
            action_list_data = {
                "id": f"AL-LIST-{i:03d}",
                "title": f"List {i}",
                "description": "Description",
                "status": "active",
                "owner": "owner",
            }
            await client.post("/api/v1/action-lists", json=action_list_data)
    
        # List action lists
        response = await client.get("/api/v1/action-lists")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:25', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:25', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:25', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:576: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "30bd919a-903d-4772-93b2-0eda07244013", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.111458Z", "level": "info"}
{"list_id": "AL-0006", "event": "action_list_created", "timestamp": "2025-12-29T00:00:25.120459Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 9.68, "correlation_id": "30bd919a-903d-4772-93b2-0eda07244013", "event": "http_response", "timestamp": "2025-12-29T00:00:25.121458Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "860f679e-fe07-407f-aab2-f8f8792674b1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.122459Z", "level": "info"}
{"list_id": "AL-0007", "event": "action_list_created", "timestamp": "2025-12-29T00:00:25.127979Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 6.23, "correlation_id": "860f679e-fe07-407f-aab2-f8f8792674b1", "event": "http_response", "timestamp": "2025-12-29T00:00:25.128976Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "56a53a6a-f955-4187-b85f-33050ebc4ea0", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.128976Z", "level": "info"}
{"list_id": "AL-0008", "event": "action_list_created", "timestamp": "2025-12-29T00:00:25.134978Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 7.09, "correlation_id": "56a53a6a-f955-4187-b85f-33050ebc4ea0", "event": "http_response", "timestamp": "2025-12-29T00:00:25.135978Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "query": null, "correlation_id": "0ef948a1-becd-43e2-a0ca-99acf4b2ae8a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.136977Z", "level": "info"}
{"count": 3, "total": 3, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:25.144977Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 8.4, "correlation_id": "0ef948a1-becd-43e2-a0ca-99acf4b2ae8a", "event": "http_response", "timestamp": "2025-12-29T00:00:25.145977Z", "level": "info"}
______________________________ TestActionListEndpoints.test_update_action_list_not_found ______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BF680>
client = <httpx.AsyncClient object at 0x000002B1A3A8BC80>

    async def test_update_action_list_not_found(self, client):
        """Test updating non-existent action list returns 404."""
        update_data = {"title": "Updated Title"}
        response = await client.patch("/api/v1/action-lists/AL-NONEXISTENT", json=update_data)
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 405 == 404
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests\integration\api\test_endpoints.py:606: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "PATCH", "path": "/api/v1/action-lists/AL-NONEXISTENT", "query": null, "correlation_id": "3af6423c-92e9-4246-85dc-70478bb9bf9f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.204007Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-NONEXISTENT", "status_code": 405, "duration_ms": 0.73, "correlation_id": "3af6423c-92e9-4246-85dc-70478bb9bf9f", "event": "http_response", "timestamp": "2025-12-29T00:00:25.205531Z", "level": "warning"}
_______________________________ TestActionListEndpoints.test_delete_action_list_success _______________________________

self = <test_endpoints.TestActionListEndpoints object at 0x000002B1A30BF8C0>
client = <httpx.AsyncClient object at 0x000002B1A3937500>

    async def test_delete_action_list_success(self, client):
        """Test deleting action list returns 204."""
        # Create action list
        action_list_data = {
            "id": "AL-DELETE-001",
            "title": "Delete Test",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Delete action list
        response = await client.delete("/api/v1/action-lists/AL-DELETE-001")
    
>       assert response.status_code == status.HTTP_204_NO_CONTENT
E       assert 404 == 204
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   204 = status.HTTP_204_NO_CONTENT

tests\integration\api\test_endpoints.py:623: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "fb58d113-1342-4a6b-b954-43309b23976f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.277596Z", "level": "info"}
{"list_id": "AL-0009", "event": "action_list_created", "timestamp": "2025-12-29T00:00:25.288115Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 12.4, "correlation_id": "fb58d113-1342-4a6b-b954-43309b23976f", "event": "http_response", "timestamp": "2025-12-29T00:00:25.290120Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/action-lists/AL-DELETE-001", "query": null, "correlation_id": "d4cfa289-bc0d-46e2-9c3f-8ce82a347daf", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:25.292118Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/action-lists/AL-DELETE-001", "status_code": 404, "duration_ms": 5.89, "correlation_id": "d4cfa289-bc0d-46e2-9c3f-8ce82a347daf", "event": "http_response", "timestamp": "2025-12-29T00:00:25.298116Z", "level": "warning"}
________________________________________ TestHealthEndpoint.test_health_check _________________________________________
  + Exception Group Traceback (most recent call last):
  |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_utils.py", line 79, in collapse_excgroups
  |     yield
  |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 183, in __call__
  |     async with anyio.create_task_group() as task_group:
  |                ^^^^^^^^^^^^^^^^^^^^^^^^^
  |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\runner.py", line 344, in from_call
    |     result: TResult | None = func()
    |                              ^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\runner.py", line 246, in <lambda>
    |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\logging.py", line 850, in pytest_runtest_call
    |     yield
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\capture.py", line 900, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\skipping.py", line 263, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\runner.py", line 178, in pytest_runtest_call
    |     item.runtest()
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pytest_asyncio\plugin.py", line 549, in runtest
    |     super().runtest()
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\python.py", line 1671, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\_pytest\python.py", line 157, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pytest_asyncio\plugin.py", line 1069, in inner
    |     _loop.run_until_complete(task)
    |   File "C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\asyncio\base_events.py", line 691, in run_until_complete
    |     return future.result()
    |            ^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\tests\integration\api\test_endpoints.py", line 14, in test_health_check
    |     response = await client.get("/health")
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1768, in get
    |     return await self.request(
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1540, in request
    |     return await self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1629, in send
    |     response = await self._send_handling_auth(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1657, in _send_handling_auth
    |     response = await self._send_handling_redirects(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1694, in _send_handling_redirects
    |     response = await self._send_single_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1730, in _send_single_request
    |     response = await transport.handle_async_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_transports\asgi.py", line 170, in handle_async_request
    |     await self.app(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\applications.py", line 113, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\errors.py", line 186, in __call__
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\errors.py", line 164, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 182, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |                                    ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\contextlib.py", line 158, in __exit__
    |     self.gen.throw(value)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_utils.py", line 85, in collapse_excgroups
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 184, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\middleware\logging_middleware.py", line 223, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 159, in call_next
    |     raise app_exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 144, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\exceptions.py", line 63, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 716, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 736, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 290, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 78, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 75, in app
    |     response = await f(request)
    |                ^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\fastapi\routing.py", line 302, in app
    |     raw_response = await run_endpoint_function(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\fastapi\routing.py", line 213, in run_endpoint_function
    |     return await dependant.call(**values)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\main.py", line 258, in health_check
    |     if "@" in settings.database.connection_string
    |               ^^^^^^^^^^^^^^^^^
    |   File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pydantic\main.py", line 991, in __getattr__
    |     raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
    | AttributeError: 'Settings' object has no attribute 'database'
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\tests\integration\api\test_endpoints.py", line 14, in test_health_check
    response = await client.get("/health")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1768, in get
    return await self.request(
           ^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1540, in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1629, in send
    response = await self._send_handling_auth(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1657, in _send_handling_auth
    response = await self._send_handling_redirects(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1694, in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_client.py", line 1730, in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\httpx\_transports\asgi.py", line 170, in handle_async_request
    await self.app(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\applications.py", line 113, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\errors.py", line 186, in __call__
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\errors.py", line 164, in __call__
    await self.app(scope, receive, _send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 182, in __call__
    with recv_stream, send_stream, collapse_excgroups():
                                   ^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\contextlib.py", line 158, in __exit__
    self.gen.throw(value)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_utils.py", line 85, in collapse_excgroups
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 184, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\middleware\logging_middleware.py", line 223, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 159, in call_next
    raise app_exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\base.py", line 144, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\middleware\exceptions.py", line 63, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 716, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 736, in app
    await route.handle(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 290, in handle
    await self.app(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 78, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\starlette\routing.py", line 75, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\fastapi\routing.py", line 302, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\fastapi\routing.py", line 213, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\main.py", line 258, in health_check
    if "@" in settings.database.connection_string
              ^^^^^^^^^^^^^^^^^
  File "C:\Users\James\Documents\Github\GHrepos\SCCMScripts\.venv\Lib\site-packages\pydantic\main.py", line 991, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
AttributeError: 'Settings' object has no attribute 'database'

During handling of the above exception, another exception occurred:

self = <test_endpoints.TestHealthEndpoint object at 0x000002B1A30779E0>
client = <httpx.AsyncClient object at 0x000002B1A3937A40>

    async def test_health_check(self, client):
        """Test health check returns 200."""
>       response = await client.get("/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\api\test_endpoints.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\.venv\Lib\site-packages\httpx\_client.py:1768: in get
    return await self.request(
..\..\.venv\Lib\site-packages\httpx\_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\httpx\_client.py:1629: in send
    response = await self._send_handling_auth(
..\..\.venv\Lib\site-packages\httpx\_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
..\..\.venv\Lib\site-packages\httpx\_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\httpx\_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\httpx\_transports\asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
..\..\.venv\Lib\site-packages\fastapi\applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\.venv\Lib\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\.venv\Lib\site-packages\starlette\middleware\base.py:182: in __call__
    with recv_stream, send_stream, collapse_excgroups():
                                   ^^^^^^^^^^^^^^^^^^^^
C:\Users\James\AppData\Roaming\uv\python\cpython-3.12.11-windows-x86_64-none\Lib\contextlib.py:158: in __exit__
    self.gen.throw(value)
..\..\.venv\Lib\site-packages\starlette\_utils.py:85: in collapse_excgroups
    raise exc
..\..\.venv\Lib\site-packages\starlette\middleware\base.py:184: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\middleware\logging_middleware.py:223: in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\starlette\middleware\base.py:159: in call_next
    raise app_exc
..\..\.venv\Lib\site-packages\starlette\middleware\base.py:144: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
..\..\.venv\Lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\.venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\.venv\Lib\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\routing.py:78: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\.venv\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\.venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\.venv\Lib\site-packages\starlette\routing.py:75: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
..\..\.venv\Lib\site-packages\fastapi\routing.py:302: in app
    raw_response = await run_endpoint_function(
..\..\.venv\Lib\site-packages\fastapi\routing.py:213: in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\main.py:258: in health_check
    if "@" in settings.database.connection_string
              ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Settings(api_host='0.0.0.0', api_port=3001, environment='development', database_url='postgresql://contextforge:contextforge@localhost:5434/taskman_v2', log_level='DEBUG')
item = 'database'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'Settings' object has no attribute 'database'

..\..\.venv\Lib\site-packages\pydantic\main.py:991: AttributeError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/health", "correlation_id": "55492695-5266-40ad-aea8-611fbf9040b3", "duration_ms": 212.29, "error": "'Settings' object has no attribute 'database'", "error_type": "AttributeError", "event": "http_request_error", "timestamp": "2025-12-29T00:00:25.572144Z", "level": "error"}
{"error": "'Settings' object has no attribute 'database'", "path": "/health", "event": "unhandled_exception", "timestamp": "2025-12-29T00:00:25.573983Z", "level": "error"}
__________________________________ TestProjectEndpoints.test_update_project_success ___________________________________

self = <test_endpoints.TestProjectEndpoints object at 0x000002B1A30AEB40>
client = <httpx.AsyncClient object at 0x000002B1A50F38C0>

    async def test_update_project_success(self, client):
        """Test updating project returns 200."""
        # Create project
        project_data = {
            "id": "P-UPDATE-001",
            "name": "Original Name",
            "mission": "Mission",
            "status": "active",
            "start_date": "2025-01-01",
            "owner": "owner",
        }
        create_response = await client.post("/api/v1/projects", json=project_data)
        assert create_response.status_code == status.HTTP_201_CREATED
    
        # Update project
        update_data = {"name": "Updated Name"}
        response = await client.patch("/api/v1/projects/P-UPDATE-001", json=update_data)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:266: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "1fc7a60f-ec90-40e7-9bc5-3eceb1740411", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.349559Z", "level": "info"}
{"project_id": "P-UPDATE-001", "name": "Original Name", "event": "project_created", "timestamp": "2025-12-29T00:00:26.381677Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 32.88, "correlation_id": "1fc7a60f-ec90-40e7-9bc5-3eceb1740411", "event": "http_response", "timestamp": "2025-12-29T00:00:26.382194Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/projects/P-UPDATE-001", "query": null, "correlation_id": "95bf5187-07ec-4d2a-9d0d-9e5d4706cd0d", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.383194Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/projects/P-UPDATE-001", "status_code": 405, "duration_ms": 0.71, "correlation_id": "95bf5187-07ec-4d2a-9d0d-9e5d4706cd0d", "event": "http_response", "timestamp": "2025-12-29T00:00:26.384195Z", "level": "warning"}
_______________________________________ TestProjectEndpoints.test_list_projects _______________________________________

self = <test_endpoints.TestProjectEndpoints object at 0x000002B1A30AE6C0>
client = <httpx.AsyncClient object at 0x000002B1A5FBEAE0>

    async def test_list_projects(self, client):
        """Test listing projects."""
        # Create projects
        for i in range(3):
            project_data = {
                "id": f"P-LIST-{i:03d}",
                "name": f"Project {i}",
                "mission": "Mission",
                "status": "active",
                "start_date": "2025-01-01",
                "owner": "owner",
            }
            await client.post("/api/v1/projects", json=project_data)
    
        # List projects
        response = await client.get("/api/v1/projects")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)

tests\integration\api\test_endpoints.py:245: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "e388eb18-f2aa-4989-a5cf-d74d5f5a60ee", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.529071Z", "level": "info"}
{"project_id": "P-LIST-000", "name": "Project 0", "event": "project_created", "timestamp": "2025-12-29T00:00:26.542162Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 14.56, "correlation_id": "e388eb18-f2aa-4989-a5cf-d74d5f5a60ee", "event": "http_response", "timestamp": "2025-12-29T00:00:26.543706Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "6c7db0b4-af80-43d0-b7af-c196319aa73b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.544702Z", "level": "info"}
{"project_id": "P-LIST-001", "name": "Project 1", "event": "project_created", "timestamp": "2025-12-29T00:00:26.550703Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 6.58, "correlation_id": "6c7db0b4-af80-43d0-b7af-c196319aa73b", "event": "http_response", "timestamp": "2025-12-29T00:00:26.551703Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "be353a18-b8df-42be-909d-4e96b92e1c40", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.551703Z", "level": "info"}
{"project_id": "P-LIST-002", "name": "Project 2", "event": "project_created", "timestamp": "2025-12-29T00:00:26.556422Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 6.05, "correlation_id": "be353a18-b8df-42be-909d-4e96b92e1c40", "event": "http_response", "timestamp": "2025-12-29T00:00:26.558421Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "query": null, "correlation_id": "9455b87e-2efc-43d5-b43e-fc5e46bed285", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.559423Z", "level": "info"}
{"count": 3, "total": 3, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:26.568422Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 9.9, "correlation_id": "9455b87e-2efc-43d5-b43e-fc5e46bed285", "event": "http_response", "timestamp": "2025-12-29T00:00:26.569422Z", "level": "info"}
_________________________________ TestProjectEndpoints.test_update_project_not_found __________________________________

self = <test_endpoints.TestProjectEndpoints object at 0x000002B1A30AEFC0>
client = <httpx.AsyncClient object at 0x000002B1A60A45F0>

    async def test_update_project_not_found(self, client):
        """Test updating non-existent project returns 404."""
        update_data = {"name": "Updated Name"}
        response = await client.patch("/api/v1/projects/P-NONEXISTENT", json=update_data)
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 405 == 404
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests\integration\api\test_endpoints.py:275: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "PATCH", "path": "/api/v1/projects/P-NONEXISTENT", "query": null, "correlation_id": "8ea84256-91c2-4f3d-b92b-aa86f6317641", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.621840Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/projects/P-NONEXISTENT", "status_code": 405, "duration_ms": 1.1, "correlation_id": "8ea84256-91c2-4f3d-b92b-aa86f6317641", "event": "http_response", "timestamp": "2025-12-29T00:00:26.623363Z", "level": "warning"}
____________________________ TestPaginationEdgeCases.test_list_action_lists_limit_boundary ____________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D92E0>
client = <httpx.AsyncClient object at 0x000002B1A5541820>

    async def test_list_action_lists_limit_boundary(self, client):
        """Test action lists list with boundary limit value."""
        response = await client.get("/api/v1/action-lists?limit=1")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:763: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/action-lists", "query": "limit=1", "correlation_id": "32acca19-0ad3-44e0-b7d6-f408ace5e01e", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.866006Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:26.872525Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 6.63, "correlation_id": "32acca19-0ad3-44e0-b7d6-f408ace5e01e", "event": "http_response", "timestamp": "2025-12-29T00:00:26.872525Z", "level": "info"}
_______________________________ TestPaginationEdgeCases.test_list_projects_large_limit ________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D9BE0>
client = <httpx.AsyncClient object at 0x000002B1A555F440>

    async def test_list_projects_large_limit(self, client):
        """Test projects list with large limit value."""
        response = await client.get("/api/v1/projects?limit=100")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)

tests\integration\api\test_endpoints.py:780: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/projects", "query": "limit=100", "correlation_id": "90660860-422b-4529-9118-5a9ed962e639", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.911706Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:26.919705Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 8.33, "correlation_id": "90660860-422b-4529-9118-5a9ed962e639", "event": "http_response", "timestamp": "2025-12-29T00:00:26.919705Z", "level": "info"}
_________________________________ TestPaginationEdgeCases.test_list_tasks_with_offset _________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D8560>
client = <httpx.AsyncClient object at 0x000002B1A5540110>

    async def test_list_tasks_with_offset(self, client):
        """Test tasks list respects offset parameter."""
        # Create tasks
        for i in range(5):
            task_data = {
                "id": f"T-OFFSET-{i:03d}",
                "title": f"Task {i}",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": "p2",
                "primary_project": "P-001",
                "primary_sprint": "S-001",
            }
            await client.post("/api/v1/tasks", json=task_data)
    
        # Test offset parameter
        response = await client.get("/api/v1/tasks?offset=2&limit=10")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:717: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "2aedd0a9-3146-4c36-a6b3-abfa798feead", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.956377Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 15.51, "correlation_id": "2aedd0a9-3146-4c36-a6b3-abfa798feead", "event": "http_response", "timestamp": "2025-12-29T00:00:26.972411Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "5e0ab972-b140-4a9a-a09b-888facb65883", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.972411Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.29, "correlation_id": "5e0ab972-b140-4a9a-a09b-888facb65883", "event": "http_response", "timestamp": "2025-12-29T00:00:26.976412Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "cb63ee5d-6c22-45fc-855d-8d4cb60846cf", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.976412Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.59, "correlation_id": "cb63ee5d-6c22-45fc-855d-8d4cb60846cf", "event": "http_response", "timestamp": "2025-12-29T00:00:26.979412Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "f92a1ae9-9ec0-4ba7-bfb1-964f3ba14968", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.980413Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.53, "correlation_id": "f92a1ae9-9ec0-4ba7-bfb1-964f3ba14968", "event": "http_response", "timestamp": "2025-12-29T00:00:26.982413Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "50dacfef-217c-4d06-8279-7c9931cfbf53", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.983413Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.63, "correlation_id": "50dacfef-217c-4d06-8279-7c9931cfbf53", "event": "http_response", "timestamp": "2025-12-29T00:00:26.985931Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "offset=2&limit=10", "correlation_id": "e5d2faf3-9a56-411a-b699-84a0e00069a8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:26.986930Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:26.994930Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 9.37, "correlation_id": "e5d2faf3-9a56-411a-b699-84a0e00069a8", "event": "http_response", "timestamp": "2025-12-29T00:00:26.995930Z", "level": "info"}
_______________________________ TestPaginationEdgeCases.test_list_projects_empty_result _______________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D89E0>
client = <httpx.AsyncClient object at 0x000002B1A55AD6A0>

    async def test_list_projects_empty_result(self, client):
        """Test projects list returns empty array when no projects exist."""
        response = await client.get("/api/v1/projects?limit=10&offset=1000")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)

tests\integration\api\test_endpoints.py:725: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/projects", "query": "limit=10&offset=1000", "correlation_id": "b20bc773-3beb-49be-9085-69bfdd46688b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.034743Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:27.042745Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 8.41, "correlation_id": "b20bc773-3beb-49be-9085-69bfdd46688b", "event": "http_response", "timestamp": "2025-12-29T00:00:27.043744Z", "level": "info"}
_________________________________ TestPaginationEdgeCases.test_list_tasks_zero_offset _________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D9760>
client = <httpx.AsyncClient object at 0x000002B1A55AFE00>

    async def test_list_tasks_zero_offset(self, client):
        """Test tasks list with explicit zero offset."""
        response = await client.get("/api/v1/tasks?offset=0&limit=10")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:772: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/tasks", "query": "offset=0&limit=10", "correlation_id": "2ea39967-6491-4782-8b5f-8d5db061cf16", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.087857Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:27.101139Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 13.87, "correlation_id": "2ea39967-6491-4782-8b5f-8d5db061cf16", "event": "http_response", "timestamp": "2025-12-29T00:00:27.102139Z", "level": "info"}
____________________________ TestPaginationEdgeCases.test_list_sprints_default_pagination _____________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30DA060>
client = <httpx.AsyncClient object at 0x000002B1A554B230>

    async def test_list_sprints_default_pagination(self, client):
        """Test sprints list uses default pagination when not specified."""
        response = await client.get("/api/v1/sprints")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:788: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/sprints", "query": null, "correlation_id": "bbd8b247-0d0d-489a-a5e8-43f8e5c0d50a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.140239Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:27.148238Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 8.58, "correlation_id": "bbd8b247-0d0d-489a-a5e8-43f8e5c0d50a", "event": "http_response", "timestamp": "2025-12-29T00:00:27.148238Z", "level": "info"}
______________________________ TestPaginationEdgeCases.test_list_sprints_with_pagination ______________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D8E60>
client = <httpx.AsyncClient object at 0x000002B1A50BB7D0>

    async def test_list_sprints_with_pagination(self, client):
        """Test sprints list pagination works correctly."""
        # Create multiple sprints
        for i in range(5):
            sprint_data = {
                "id": f"S-PAGE-{i:03d}",
                "name": f"Sprint {i}",
                "goal": "Goal",
                "cadence": "weekly",
                "start_date": "2025-01-01",
                "end_date": "2025-01-07",
                "status": "active",
                "owner": "owner",
                "primary_project": "P-001",
            }
            await client.post("/api/v1/sprints", json=sprint_data)
    
        # Test pagination
        page1 = await client.get("/api/v1/sprints?limit=2&offset=0")
        page2 = await client.get("/api/v1/sprints?limit=2&offset=2")
    
        assert page1.status_code == status.HTTP_200_OK
        assert page2.status_code == status.HTTP_200_OK
    
        data1 = page1.json()
        data2 = page2.json()
>       assert isinstance(data1, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:754: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "b18631f5-d29a-4a1e-8b70-2f18e49af063", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.185841Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 12.34, "correlation_id": "b18631f5-d29a-4a1e-8b70-2f18e49af063", "event": "http_response", "timestamp": "2025-12-29T00:00:27.198351Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "c6cd027a-8696-4115-928e-9cfd81bfee13", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.198351Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 2.44, "correlation_id": "c6cd027a-8696-4115-928e-9cfd81bfee13", "event": "http_response", "timestamp": "2025-12-29T00:00:27.201351Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "36dfaf15-07f0-4b4a-94e4-32c7a2134cbb", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.201351Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 2.57, "correlation_id": "36dfaf15-07f0-4b4a-94e4-32c7a2134cbb", "event": "http_response", "timestamp": "2025-12-29T00:00:27.204350Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "9d0430df-7f23-416d-8eaf-824f99d7ec3a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.205350Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 2.48, "correlation_id": "9d0430df-7f23-416d-8eaf-824f99d7ec3a", "event": "http_response", "timestamp": "2025-12-29T00:00:27.207350Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "b102339b-57eb-4cc4-bc9e-f3f01f5abecd", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.208351Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 3.12, "correlation_id": "b102339b-57eb-4cc4-bc9e-f3f01f5abecd", "event": "http_response", "timestamp": "2025-12-29T00:00:27.211350Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": "limit=2&offset=0", "correlation_id": "d5008b98-9e74-4bbe-ab54-2b7fb19ac82e", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.212351Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:27.220354Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 9.0, "correlation_id": "d5008b98-9e74-4bbe-ab54-2b7fb19ac82e", "event": "http_response", "timestamp": "2025-12-29T00:00:27.221352Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "query": "limit=2&offset=2", "correlation_id": "f051cc72-b662-489a-9e1d-85533b7b4ef1", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.222353Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:27.228863Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 7.29, "correlation_id": "f051cc72-b662-489a-9e1d-85533b7b4ef1", "event": "http_response", "timestamp": "2025-12-29T00:00:27.229465Z", "level": "info"}
_________________________________ TestPaginationEdgeCases.test_list_tasks_with_limit __________________________________

self = <test_endpoints.TestPaginationEdgeCases object at 0x000002B1A30D80E0>
client = <httpx.AsyncClient object at 0x000002B1A512D8E0>

    async def test_list_tasks_with_limit(self, client):
        """Test tasks list respects limit parameter."""
        # Create multiple tasks
        for i in range(5):
            task_data = {
                "id": f"T-LIMIT-{i:03d}",
                "title": f"Task {i}",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": "p2",
                "primary_project": "P-001",
                "primary_sprint": "S-001",
            }
            await client.post("/api/v1/tasks", json=task_data)
    
        # Test limit parameter
        response = await client.get("/api/v1/tasks?limit=3")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:693: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "5e83edf3-ebeb-4387-95bc-a46232294eb8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.268108Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 73.84, "correlation_id": "5e83edf3-ebeb-4387-95bc-a46232294eb8", "event": "http_response", "timestamp": "2025-12-29T00:00:27.342028Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "30a56caa-223d-453f-9fdb-0fb6ffa41c9b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.343028Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.98, "correlation_id": "30a56caa-223d-453f-9fdb-0fb6ffa41c9b", "event": "http_response", "timestamp": "2025-12-29T00:00:27.346582Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "5bf7a653-35ff-4f68-8cb9-b10d74427cc8", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.347537Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.92, "correlation_id": "5bf7a653-35ff-4f68-8cb9-b10d74427cc8", "event": "http_response", "timestamp": "2025-12-29T00:00:27.350538Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "f270a54d-9491-4c1b-b330-0d0500ae72e9", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.351537Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 4.09, "correlation_id": "f270a54d-9491-4c1b-b330-0d0500ae72e9", "event": "http_response", "timestamp": "2025-12-29T00:00:27.356538Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "6a833272-664e-4130-8f8b-c250c09b4cd2", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.356538Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.77, "correlation_id": "6a833272-664e-4130-8f8b-c250c09b4cd2", "event": "http_response", "timestamp": "2025-12-29T00:00:27.361051Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "limit=3", "correlation_id": "004f845d-fb58-4b31-b07e-c082f3da209f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.362055Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:27.372052Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 10.27, "correlation_id": "004f845d-fb58-4b31-b07e-c082f3da209f", "event": "http_response", "timestamp": "2025-12-29T00:00:27.373053Z", "level": "info"}
___________________________________ TestSprintEndpoints.test_delete_sprint_success ____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30BD160>
client = <httpx.AsyncClient object at 0x000002B1A3A882F0>

    async def test_delete_sprint_success(self, client):
        """Test deleting sprint returns 204."""
        # Create sprint
        sprint_data = {
            "id": "S-DELETE-001",
            "name": "Delete Test",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Delete sprint
        response = await client.delete("/api/v1/sprints/S-DELETE-001")
    
>       assert response.status_code == status.HTTP_204_NO_CONTENT
E       assert 404 == 204
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   204 = status.HTTP_204_NO_CONTENT

tests\integration\api\test_endpoints.py:465: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "40319391-7a69-4069-9ab1-e9ae155fd4ef", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.427207Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 6.04, "correlation_id": "40319391-7a69-4069-9ab1-e9ae155fd4ef", "event": "http_response", "timestamp": "2025-12-29T00:00:27.433818Z", "level": "warning"}
{"method": "DELETE", "path": "/api/v1/sprints/S-DELETE-001", "query": null, "correlation_id": "a63bb089-46ea-4884-86cb-d1590d4ed945", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.433818Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/sprints/S-DELETE-001", "status_code": 404, "duration_ms": 5.5, "correlation_id": "a63bb089-46ea-4884-86cb-d1590d4ed945", "event": "http_response", "timestamp": "2025-12-29T00:00:27.439818Z", "level": "warning"}
_____________________________________ TestSprintEndpoints.test_get_sprint_success _____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30BCC20>
client = <httpx.AsyncClient object at 0x000002B1A4BC37A0>

    async def test_get_sprint_success(self, client):
        """Test getting sprint by ID."""
        # Create sprint
        sprint_data = {
            "id": "S-GET-001",
            "name": "Get Test Sprint",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Get sprint
        response = await client.get("/api/v1/sprints/S-GET-001")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:384: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "68ca357f-5729-42fb-9e3e-d21ef39cdffa", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.494430Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 7.68, "correlation_id": "68ca357f-5729-42fb-9e3e-d21ef39cdffa", "event": "http_response", "timestamp": "2025-12-29T00:00:27.502427Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints/S-GET-001", "query": null, "correlation_id": "d154bcbe-0780-42f1-8b52-352f2e70e3b5", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.502427Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints/S-GET-001", "status_code": 404, "duration_ms": 5.82, "correlation_id": "d154bcbe-0780-42f1-8b52-352f2e70e3b5", "event": "http_response", "timestamp": "2025-12-29T00:00:27.508430Z", "level": "warning"}
__________________________________ TestSprintEndpoints.test_update_sprint_not_found ___________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30BC530>
client = <httpx.AsyncClient object at 0x000002B1A4BC2360>

    async def test_update_sprint_not_found(self, client):
        """Test updating non-existent sprint returns 404."""
        update_data = {"name": "Updated Sprint"}
        response = await client.patch("/api/v1/sprints/S-NONEXISTENT", json=update_data)
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 405 == 404
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests\integration\api\test_endpoints.py:444: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "PATCH", "path": "/api/v1/sprints/S-NONEXISTENT", "query": null, "correlation_id": "dbe305a7-1fbe-40c2-861d-6fdb714c4cfa", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.556720Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/sprints/S-NONEXISTENT", "status_code": 405, "duration_ms": 0.74, "correlation_id": "dbe305a7-1fbe-40c2-861d-6fdb714c4cfa", "event": "http_response", "timestamp": "2025-12-29T00:00:27.556720Z", "level": "warning"}
___________________________________ TestSprintEndpoints.test_update_sprint_success ____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30ADE80>
client = <httpx.AsyncClient object at 0x000002B1A4C4C8C0>

    async def test_update_sprint_success(self, client):
        """Test updating sprint returns 200."""
        # Create sprint
        sprint_data = {
            "id": "S-UPDATE-001",
            "name": "Original Sprint",
            "goal": "Original Goal",
            "cadence": "biweekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-14",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        create_response = await client.post("/api/v1/sprints", json=sprint_data)
>       assert create_response.status_code == status.HTTP_201_CREATED
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:428: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "dfc3f9d3-a359-4419-9830-e2afc3144fbb", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.600482Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 5.6, "correlation_id": "dfc3f9d3-a359-4419-9830-e2afc3144fbb", "event": "http_response", "timestamp": "2025-12-29T00:00:27.606026Z", "level": "warning"}
___________________________________ TestSprintEndpoints.test_create_sprint_conflict ___________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30BDF10>
client = <httpx.AsyncClient object at 0x000002B1A37F6030>

    async def test_create_sprint_conflict(self, client):
        """Test duplicate sprint ID returns 409."""
        sprint_data = {
            "id": "S-CONFLICT-001",
            "name": "Conflict Test",
            "goal": "Goal",
            "cadence": "biweekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-14",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
    
        # Create first sprint
        first_response = await client.post("/api/v1/sprints", json=sprint_data)
>       assert first_response.status_code == status.HTTP_201_CREATED
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:511: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "b1286121-367e-4e2f-b3f5-d6737435a4f2", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.678053Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 5.38, "correlation_id": "b1286121-367e-4e2f-b3f5-d6737435a4f2", "event": "http_response", "timestamp": "2025-12-29T00:00:27.683089Z", "level": "warning"}
___________________________________ TestSprintEndpoints.test_create_sprint_success ____________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30BC7A0>
client = <httpx.AsyncClient object at 0x000002B1A4BE8380>

    async def test_create_sprint_success(self, client):
        """Test successful sprint creation."""
        sprint_data = {
            "id": "S-TEST-001",
            "name": "Sprint 1",
            "goal": "Sprint goal",
            "cadence": "biweekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-14",
            "status": "active",
            "owner": "scrum.master",
            "primary_project": "P-001",
        }
    
        response = await client.post("/api/v1/sprints", json=sprint_data)
    
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:360: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "7cc620f5-889c-418c-b144-bab65ca3370d", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.754435Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 6.97, "correlation_id": "7cc620f5-889c-418c-b144-bab65ca3370d", "event": "http_response", "timestamp": "2025-12-29T00:00:27.761433Z", "level": "warning"}
________________________________________ TestSprintEndpoints.test_list_sprints ________________________________________

self = <test_endpoints.TestSprintEndpoints object at 0x000002B1A30AF080>
client = <httpx.AsyncClient object at 0x000002B1A4B9C830>

    async def test_list_sprints(self, client):
        """Test listing sprints."""
        # Create sprints
        for i in range(3):
            sprint_data = {
                "id": f"S-LIST-{i:03d}",
                "name": f"Sprint {i}",
                "goal": "Goal",
                "cadence": "biweekly",
                "start_date": "2025-01-01",
                "end_date": "2025-01-14",
                "status": "active",
                "owner": "owner",
                "primary_project": "P-001",
            }
            await client.post("/api/v1/sprints", json=sprint_data)
    
        # List sprints
        response = await client.get("/api/v1/sprints")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:410: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "5c0a569d-ef48-4904-b697-6513bf81516f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.800156Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 5.8, "correlation_id": "5c0a569d-ef48-4904-b697-6513bf81516f", "event": "http_response", "timestamp": "2025-12-29T00:00:27.805157Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "6871e831-ea39-47c0-a6e5-5f6af27b2af7", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.806156Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 3.6, "correlation_id": "6871e831-ea39-47c0-a6e5-5f6af27b2af7", "event": "http_response", "timestamp": "2025-12-29T00:00:27.810157Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "0550f29c-4d76-403b-a0d8-dfbef347d10f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.811156Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 2.85, "correlation_id": "0550f29c-4d76-403b-a0d8-dfbef347d10f", "event": "http_response", "timestamp": "2025-12-29T00:00:27.814157Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": null, "correlation_id": "56b2148c-379e-4451-985b-9968efae98ae", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.814157Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:27.822155Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 8.27, "correlation_id": "56b2148c-379e-4451-985b-9968efae98ae", "event": "http_response", "timestamp": "2025-12-29T00:00:27.823155Z", "level": "info"}
_______________________________ TestFilteringEdgeCases.test_list_tasks_filter_by_status _______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30DA540>
client = <httpx.AsyncClient object at 0x000002B1A4B8CB30>

    async def test_list_tasks_filter_by_status(self, client):
        """Test filtering tasks by status."""
        # Create tasks with different statuses
        task_new = {
            "id": "T-FILTER-NEW",
            "title": "New Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_new)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/tasks?status=new")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:814: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "092b8b06-5747-45fe-8b1d-38e48e66d04f", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.870748Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 8.3, "correlation_id": "092b8b06-5747-45fe-8b1d-38e48e66d04f", "event": "http_response", "timestamp": "2025-12-29T00:00:27.878847Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "status=new", "correlation_id": "f3113c07-b775-446b-8efc-eaf755218d66", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.879847Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:27.889364Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 9.84, "correlation_id": "f3113c07-b775-446b-8efc-eaf755218d66", "event": "http_response", "timestamp": "2025-12-29T00:00:27.890363Z", "level": "info"}
_____________________________ TestFilteringEdgeCases.test_list_sprints_filter_by_project ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30DB2C0>
client = <httpx.AsyncClient object at 0x000002B1A37F07A0>

    async def test_list_sprints_filter_by_project(self, client):
        """Test filtering sprints by project."""
        sprint_data = {
            "id": "S-FILTER-PROJ",
            "name": "Project Sprint",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Note: API may not have project filter implemented yet
        response = await client.get("/api/v1/sprints?project=P-001")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:939: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "1cac354a-7b57-4216-90fa-6b0158b73196", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.946859Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 7.61, "correlation_id": "1cac354a-7b57-4216-90fa-6b0158b73196", "event": "http_response", "timestamp": "2025-12-29T00:00:27.954372Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": "project=P-001", "correlation_id": "2e95cc11-0f86-4464-a7ad-955edb30a68a", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:27.955371Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:27.964369Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 9.19, "correlation_id": "2e95cc11-0f86-4464-a7ad-955edb30a68a", "event": "http_response", "timestamp": "2025-12-29T00:00:27.964369Z", "level": "info"}
_______________________________ TestFilteringEdgeCases.test_list_tasks_filter_by_owner ________________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30D97C0>
client = <httpx.AsyncClient object at 0x000002B1A38F8AA0>

    async def test_list_tasks_filter_by_owner(self, client):
        """Test filtering tasks by owner."""
        task_data = {
            "id": "T-FILTER-OWNER",
            "title": "Owned Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "test.owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Note: API may not have owner filter implemented yet
        response = await client.get("/api/v1/tasks?owner=test.owner")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:857: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "e70b8bc9-c4b1-46ac-b3dc-5e3123c5f55e", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.009786Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.61, "correlation_id": "e70b8bc9-c4b1-46ac-b3dc-5e3123c5f55e", "event": "http_response", "timestamp": "2025-12-29T00:00:28.016784Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "owner=test.owner", "correlation_id": "2ae1e5e9-f49a-48e7-b6de-64fd21728ad9", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.017787Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:28.026317Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 10.31, "correlation_id": "2ae1e5e9-f49a-48e7-b6de-64fd21728ad9", "event": "http_response", "timestamp": "2025-12-29T00:00:28.027317Z", "level": "info"}
__________________________ TestFilteringEdgeCases.test_list_action_lists_empty_filter_value ___________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30EC980>
client = <httpx.AsyncClient object at 0x000002B1A38BDA60>

    async def test_list_action_lists_empty_filter_value(self, client):
        """Test empty filter value."""
        response = await client.get("/api/v1/action-lists?status=")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:1002: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/action-lists", "query": "status=", "correlation_id": "0b06d26b-45a6-462a-a921-131a55cac584", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.073467Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:28.081501Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 8.36, "correlation_id": "0b06d26b-45a6-462a-a921-131a55cac584", "event": "http_response", "timestamp": "2025-12-29T00:00:28.081523Z", "level": "info"}
_____________________________ TestFilteringEdgeCases.test_list_projects_filter_by_status ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30D85C0>
client = <httpx.AsyncClient object at 0x000002B1A3A266C0>

    async def test_list_projects_filter_by_status(self, client):
        """Test filtering projects by status."""
        project_data = {
            "id": "P-FILTER-STATUS",
            "name": "Active Project",
            "mission": "Mission",
            "status": "active",
            "start_date": "2025-01-01",
            "owner": "owner",
        }
        await client.post("/api/v1/projects", json=project_data)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/projects?status=active")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)

tests\integration\api\test_endpoints.py:876: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "ed8e018f-d098-4069-a434-3510ebe48661", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.121317Z", "level": "info"}
{"project_id": "P-FILTER-STATUS", "name": "Active Project", "event": "project_created", "timestamp": "2025-12-29T00:00:28.133314Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 12.24, "correlation_id": "ed8e018f-d098-4069-a434-3510ebe48661", "event": "http_response", "timestamp": "2025-12-29T00:00:28.134314Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "query": "status=active", "correlation_id": "dea96c70-ad8b-43a4-b98c-768d6952c5ec", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.135315Z", "level": "info"}
{"count": 1, "total": 1, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:28.144960Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 11.32, "correlation_id": "dea96c70-ad8b-43a4-b98c-768d6952c5ec", "event": "http_response", "timestamp": "2025-12-29T00:00:28.145960Z", "level": "info"}
___________________________ TestFilteringEdgeCases.test_list_sprints_invalid_filter_ignored ___________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30EC500>
client = <httpx.AsyncClient object at 0x000002B1A3A3DC40>

    async def test_list_sprints_invalid_filter_ignored(self, client):
        """Test invalid filter parameter is ignored."""
        response = await client.get("/api/v1/sprints?invalid_param=value")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:994: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/sprints", "query": "invalid_param=value", "correlation_id": "37a179c9-33ee-46f6-878c-986a285046f4", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.190637Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:28.198636Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 8.53, "correlation_id": "37a179c9-33ee-46f6-878c-986a285046f4", "event": "http_response", "timestamp": "2025-12-29T00:00:28.199636Z", "level": "info"}
______________________________ TestFilteringEdgeCases.test_list_tasks_filter_by_priority ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30BF6E0>
client = <httpx.AsyncClient object at 0x000002B1A3A7FF80>

    async def test_list_tasks_filter_by_priority(self, client):
        """Test filtering tasks by priority."""
        # Create tasks with different priorities
        task_p1 = {
            "id": "T-FILTER-P1",
            "title": "High Priority Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p1",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_p1)
    
        # Note: API may not have priority filter implemented yet
        response = await client.get("/api/v1/tasks?priority=p1")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:836: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "bb9e0e68-5da0-4011-bd66-a2c70adb670c", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.238869Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.54, "correlation_id": "bb9e0e68-5da0-4011-bd66-a2c70adb670c", "event": "http_response", "timestamp": "2025-12-29T00:00:28.244870Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "priority=p1", "correlation_id": "a4e67a1e-8752-47f8-ad19-a6eb134870ca", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.245872Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:28.254886Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 9.63, "correlation_id": "a4e67a1e-8752-47f8-ad19-a6eb134870ca", "event": "http_response", "timestamp": "2025-12-29T00:00:28.255887Z", "level": "info"}
______________________________ TestFilteringEdgeCases.test_list_projects_filter_by_owner ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30DA9C0>
client = <httpx.AsyncClient object at 0x000002B1A37498E0>

    async def test_list_projects_filter_by_owner(self, client):
        """Test filtering projects by owner."""
        project_data = {
            "id": "P-FILTER-OWNER",
            "name": "My Project",
            "mission": "Mission",
            "status": "active",
            "start_date": "2025-01-01",
            "owner": "project.owner",
        }
        await client.post("/api/v1/projects", json=project_data)
    
        # Note: API may not have owner filter implemented yet
        response = await client.get("/api/v1/projects?owner=project.owner")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)

tests\integration\api\test_endpoints.py:895: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/projects", "query": null, "correlation_id": "d0d282c6-55d0-414e-862f-2834a640e7e3", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.300992Z", "level": "info"}
{"project_id": "P-FILTER-OWNER", "name": "My Project", "event": "project_created", "timestamp": "2025-12-29T00:00:28.312695Z", "level": "info"}
{"method": "POST", "path": "/api/v1/projects", "status_code": 201, "duration_ms": 12.54, "correlation_id": "d0d282c6-55d0-414e-862f-2834a640e7e3", "event": "http_response", "timestamp": "2025-12-29T00:00:28.313694Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "query": "owner=project.owner", "correlation_id": "099dba6b-2e90-411a-a6f9-e454438e3611", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.314694Z", "level": "info"}
{"count": 1, "total": 1, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:28.322230Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 11.42, "correlation_id": "099dba6b-2e90-411a-a6f9-e454438e3611", "event": "http_response", "timestamp": "2025-12-29T00:00:28.326232Z", "level": "info"}
_______________________________ TestFilteringEdgeCases.test_list_tasks_multiple_filters _______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30DBBC0>
client = <httpx.AsyncClient object at 0x000002B1A3A7FFB0>

    async def test_list_tasks_multiple_filters(self, client):
        """Test combining multiple filters."""
        task_data = {
            "id": "T-MULTI-FILTER",
            "title": "Multi Filter Task",
            "summary": "Summary",
            "description": "Description",
            "owner": "filter.owner",
            "priority": "p1",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Note: API may not have multiple filter support yet
        response = await client.get("/api/v1/tasks?priority=p1&owner=filter.owner")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:978: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "28cbdd5a-b8ea-4baf-aa4d-3ec0c812ab09", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.399617Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 7.46, "correlation_id": "28cbdd5a-b8ea-4baf-aa4d-3ec0c812ab09", "event": "http_response", "timestamp": "2025-12-29T00:00:28.406618Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "priority=p1&owner=filter.owner", "correlation_id": "9b7588a7-12e5-48d2-994c-5ea5b1f821ec", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.407618Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:28.419622Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 12.76, "correlation_id": "9b7588a7-12e5-48d2-994c-5ea5b1f821ec", "event": "http_response", "timestamp": "2025-12-29T00:00:28.420620Z", "level": "info"}
___________________________ TestFilteringEdgeCases.test_list_action_lists_filter_by_status ____________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30DB740>
client = <httpx.AsyncClient object at 0x000002B1A5B7FDA0>

    async def test_list_action_lists_filter_by_status(self, client):
        """Test filtering action lists by status."""
        action_list_data = {
            "id": "AL-FILTER-STATUS",
            "title": "Active List",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/action-lists?status=active")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:28', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)

tests\integration\api\test_endpoints.py:957: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "4cae0a37-568a-4608-82fd-365a1df84f98", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.487650Z", "level": "info"}
{"list_id": "AL-0010", "event": "action_list_created", "timestamp": "2025-12-29T00:00:28.497651Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 10.41, "correlation_id": "4cae0a37-568a-4608-82fd-365a1df84f98", "event": "http_response", "timestamp": "2025-12-29T00:00:28.498651Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "query": "status=active", "correlation_id": "d538809a-987f-4135-a178-b04b62009c7e", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.499651Z", "level": "info"}
{"count": 1, "total": 1, "page": 1, "event": "action_lists_listed", "timestamp": "2025-12-29T00:00:28.505161Z", "level": "info"}
{"method": "GET", "path": "/api/v1/action-lists", "status_code": 200, "duration_ms": 6.61, "correlation_id": "d538809a-987f-4135-a178-b04b62009c7e", "event": "http_response", "timestamp": "2025-12-29T00:00:28.506162Z", "level": "info"}
________________________________ TestFilteringEdgeCases.test_list_projects_no_filters _________________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30EC080>
client = <httpx.AsyncClient object at 0x000002B1A5B4E450>

    async def test_list_projects_no_filters(self, client):
        """Test projects list without any filters returns all projects."""
        response = await client.get("/api/v1/projects")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)

tests\integration\api\test_endpoints.py:986: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "GET", "path": "/api/v1/projects", "query": null, "correlation_id": "01edc4d5-f4d5-4ba4-ae33-dec72e149965", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.561307Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "projects_listed", "timestamp": "2025-12-29T00:00:28.572433Z", "level": "info"}
{"method": "GET", "path": "/api/v1/projects", "status_code": 200, "duration_ms": 11.19, "correlation_id": "01edc4d5-f4d5-4ba4-ae33-dec72e149965", "event": "http_response", "timestamp": "2025-12-29T00:00:28.572433Z", "level": "info"}
______________________________ TestFilteringEdgeCases.test_list_sprints_filter_by_status ______________________________

self = <test_endpoints.TestFilteringEdgeCases object at 0x000002B1A30DAE40>
client = <httpx.AsyncClient object at 0x000002B1A50FB7D0>

    async def test_list_sprints_filter_by_status(self, client):
        """Test filtering sprints by status."""
        sprint_data = {
            "id": "S-FILTER-STATUS",
            "name": "Active Sprint",
            "goal": "Goal",
            "cadence": "weekly",
            "start_date": "2025-01-01",
            "end_date": "2025-01-07",
            "status": "active",
            "owner": "owner",
            "primary_project": "P-001",
        }
        await client.post("/api/v1/sprints", json=sprint_data)
    
        # Note: API may not have status filter implemented yet
        response = await client.get("/api/v1/sprints?status=active")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)

tests\integration\api\test_endpoints.py:917: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/sprints", "query": null, "correlation_id": "db36ec61-75cf-43e2-ae25-d8539e57a5ee", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.627707Z", "level": "info"}
{"method": "POST", "path": "/api/v1/sprints", "status_code": 404, "duration_ms": 7.57, "correlation_id": "db36ec61-75cf-43e2-ae25-d8539e57a5ee", "event": "http_response", "timestamp": "2025-12-29T00:00:28.635848Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/sprints", "query": "status=active", "correlation_id": "a09711ac-3ce7-4d4e-badd-fb6d6e9e98db", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.636851Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "sprints_listed", "timestamp": "2025-12-29T00:00:28.649851Z", "level": "info"}
{"method": "GET", "path": "/api/v1/sprints", "status_code": 200, "duration_ms": 13.93, "correlation_id": "a09711ac-3ce7-4d4e-badd-fb6d6e9e98db", "event": "http_response", "timestamp": "2025-12-29T00:00:28.650850Z", "level": "info"}
__________________________________________ TestTaskEndpoints.test_list_tasks __________________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000002B1A30AD580>
client = <httpx.AsyncClient object at 0x000002B1A5E85130>

    async def test_list_tasks(self, client):
        """Test listing tasks with pagination."""
        # Create multiple tasks
        for i in range(5):
            task_data = {
                "id": f"T-LIST-{i:03d}",
                "title": f"Task {i}",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": "p2",  # Fixed: was "medium", now uses proper enum value
                "primary_project": "P-001",
                "primary_sprint": "S-001",
            }
            await client.post("/api/v1/tasks", json=task_data)
    
        # List tasks
        response = await client.get("/api/v1/tasks?limit=10&offset=0")
    
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)

tests\integration\api\test_endpoints.py:142: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "805bdb73-76c1-47c0-95bd-3b43748d4d23", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.739370Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.44, "correlation_id": "805bdb73-76c1-47c0-95bd-3b43748d4d23", "event": "http_response", "timestamp": "2025-12-29T00:00:28.745409Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "d55711bc-82df-4186-a02e-a49f49442dd3", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.746414Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.55, "correlation_id": "d55711bc-82df-4186-a02e-a49f49442dd3", "event": "http_response", "timestamp": "2025-12-29T00:00:28.749408Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "1bea6bd2-78e0-4969-84c9-c55e3c39a6d5", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.749408Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 2.99, "correlation_id": "1bea6bd2-78e0-4969-84c9-c55e3c39a6d5", "event": "http_response", "timestamp": "2025-12-29T00:00:28.752410Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "9175b290-851a-46c0-afdf-322004c8d92d", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.753409Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.41, "correlation_id": "9175b290-851a-46c0-afdf-322004c8d92d", "event": "http_response", "timestamp": "2025-12-29T00:00:28.757410Z", "level": "warning"}
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "e1e57264-3ef1-42c8-bc33-2f8cd4b9c953", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.757410Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 3.7, "correlation_id": "e1e57264-3ef1-42c8-bc33-2f8cd4b9c953", "event": "http_response", "timestamp": "2025-12-29T00:00:28.761412Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks", "query": "limit=10&offset=0", "correlation_id": "432d74c8-a2ac-42e0-a159-c57de144c9d0", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.762410Z", "level": "info"}
{"count": 0, "total": 0, "page": 1, "event": "tasks_listed", "timestamp": "2025-12-29T00:00:28.771495Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks", "status_code": 200, "duration_ms": 9.76, "correlation_id": "432d74c8-a2ac-42e0-a159-c57de144c9d0", "event": "http_response", "timestamp": "2025-12-29T00:00:28.772493Z", "level": "info"}
_______________________________________ TestTaskEndpoints.test_get_task_success _______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000002B1A30AC350>
client = <httpx.AsyncClient object at 0x000002B1A5E073B0>

    async def test_get_task_success(self, client):
        """Test getting task by ID."""
        # Create task first
        task_data = {
            "id": "T-GET-001",
            "title": "Get Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",  # Fixed: was "medium", now uses proper enum value
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Get task
        response = await client.get("/api/v1/tasks/T-GET-001")
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:63: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "31545ed4-c32f-4384-aaa8-767f955d7612", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.821493Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 7.28, "correlation_id": "31545ed4-c32f-4384-aaa8-767f955d7612", "event": "http_response", "timestamp": "2025-12-29T00:00:28.828491Z", "level": "warning"}
{"method": "GET", "path": "/api/v1/tasks/T-GET-001", "query": null, "correlation_id": "54e1b8ee-800e-4dbb-a146-c52c673babb9", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.830494Z", "level": "info"}
{"method": "GET", "path": "/api/v1/tasks/T-GET-001", "status_code": 404, "duration_ms": 5.63, "correlation_id": "54e1b8ee-800e-4dbb-a146-c52c673babb9", "event": "http_response", "timestamp": "2025-12-29T00:00:28.835554Z", "level": "warning"}
_____________________________________ TestTaskEndpoints.test_delete_task_success ______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000002B1A30ACF20>
client = <httpx.AsyncClient object at 0x000002B1A5E613A0>

    async def test_delete_task_success(self, client):
        """Test deleting task."""
        # Create task
        task_data = {
            "id": "T-DELETE-001",
            "title": "Delete Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p3",  # Fixed: was "low", now uses proper enum value
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        await client.post("/api/v1/tasks", json=task_data)
    
        # Delete task
        response = await client.delete("/api/v1/tasks/T-DELETE-001")
    
>       assert response.status_code == status.HTTP_204_NO_CONTENT
E       assert 404 == 204
E        +  where 404 = <Response [404 Not Found]>.status_code
E        +  and   204 = status.HTTP_204_NO_CONTENT

tests\integration\api\test_endpoints.py:115: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "1799503b-00b9-46b7-b7af-7b96ad46b879", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.880954Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.07, "correlation_id": "1799503b-00b9-46b7-b7af-7b96ad46b879", "event": "http_response", "timestamp": "2025-12-29T00:00:28.886066Z", "level": "warning"}
{"method": "DELETE", "path": "/api/v1/tasks/T-DELETE-001", "query": null, "correlation_id": "0e19df46-9469-4f11-b043-1c9759232cdc", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.887067Z", "level": "info"}
{"method": "DELETE", "path": "/api/v1/tasks/T-DELETE-001", "status_code": 404, "duration_ms": 5.0, "correlation_id": "0e19df46-9469-4f11-b043-1c9759232cdc", "event": "http_response", "timestamp": "2025-12-29T00:00:28.892778Z", "level": "warning"}
_____________________________________ TestTaskEndpoints.test_update_task_success ______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000002B1A30ACB30>
client = <httpx.AsyncClient object at 0x000002B1A59A0410>

    async def test_update_task_success(self, client):
        """Test updating task."""
        # Create task
        task_data = {
            "id": "T-UPDATE-001",
            "title": "Original Title",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p3",  # Fixed: was "low", now uses proper enum value
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
        create_response = await client.post("/api/v1/tasks", json=task_data)
>       assert create_response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:87: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "0df39270-c123-41d8-a92e-69659164ed9b", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:28.933316Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 6.59, "correlation_id": "0df39270-c123-41d8-a92e-69659164ed9b", "event": "http_response", "timestamp": "2025-12-29T00:00:28.939812Z", "level": "warning"}
_____________________________________ TestTaskEndpoints.test_create_task_success ______________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000002B1A30AC1D0>
client = <httpx.AsyncClient object at 0x000002B1A5933710>

    async def test_create_task_success(self, client):
        """Test successful task creation."""
        task_data = {
            "id": "T-TEST-001",
            "title": "Test Task",
            "summary": "Test summary",
            "description": "Test description",
            "owner": "test.owner",
            "priority": "p1",  # Fixed: was "high", now uses proper enum value
            "primary_project": "P-TEST-001",
            "primary_sprint": "S-TEST-001",
        }
    
        response = await client.post("/api/v1/tasks", json=task_data)
    
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:40: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "b104ea8e-dacc-4f32-afd2-f73b76c434da", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:29.029172Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 11.06, "correlation_id": "b104ea8e-dacc-4f32-afd2-f73b76c434da", "event": "http_response", "timestamp": "2025-12-29T00:00:29.040092Z", "level": "warning"}
_____________________________________ TestTaskEndpoints.test_create_task_conflict _____________________________________

self = <test_endpoints.TestTaskEndpoints object at 0x000002B1A30AD1F0>
client = <httpx.AsyncClient object at 0x000002B1A59323C0>

    async def test_create_task_conflict(self, client):
        """Test duplicate task ID returns 409."""
        task_data = {
            "id": "T-CONFLICT-001",
            "title": "Conflict Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
    
        # Create first task
        first_response = await client.post("/api/v1/tasks", json=task_data)
>       assert first_response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:177: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "3130f05c-d08a-4669-85ab-116b95bf84d7", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:29.124534Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 10.51, "correlation_id": "3130f05c-d08a-4669-85ab-116b95bf84d7", "event": "http_response", "timestamp": "2025-12-29T00:00:29.135189Z", "level": "warning"}
___________________________ TestValidationEdgeCases.test_update_action_list_invalid_status ____________________________

self = <test_endpoints.TestValidationEdgeCases object at 0x000002B1A30EEA20>
client = <httpx.AsyncClient object at 0x000002B1A4ED4D40>

    async def test_update_action_list_invalid_status(self, client):
        """Test action list update with invalid status enum.
    
        Note: API currently accepts invalid status values in PATCH requests
        due to lenient Pydantic validation. This test verifies endpoint accepts
        the update gracefully (200 OK) rather than strictly validating (422).
        """
        # Create action list first
        action_list_data = {
            "id": "AL-INVALID-STATUS",
            "title": "List",
            "description": "Description",
            "status": "active",
            "owner": "owner",
        }
        await client.post("/api/v1/action-lists", json=action_list_data)
    
        # Update with invalid status (API accepts this currently)
        update_data = {"status": "invalid_status"}
        response = await client.patch("/api/v1/action-lists/AL-INVALID-STATUS", json=update_data)
    
        # API accepts the update (lenient validation in PATCH)
>       assert response.status_code == status.HTTP_200_OK
E       assert 405 == 200
E        +  where 405 = <Response [405 Method Not Allowed]>.status_code
E        +  and   200 = status.HTTP_200_OK

tests\integration\api\test_endpoints.py:1190: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "687e6630-894e-4370-8376-df80db3efec5", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:29.272670Z", "level": "info"}
{"list_id": "AL-0011", "event": "action_list_created", "timestamp": "2025-12-29T00:00:29.280670Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 8.5, "correlation_id": "687e6630-894e-4370-8376-df80db3efec5", "event": "http_response", "timestamp": "2025-12-29T00:00:29.281208Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-INVALID-STATUS", "query": null, "correlation_id": "3bd0063d-0594-4ed1-ad9b-356b78ecd635", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:29.282186Z", "level": "info"}
{"method": "PATCH", "path": "/api/v1/action-lists/AL-INVALID-STATUS", "status_code": 405, "duration_ms": 0.4, "correlation_id": "3bd0063d-0594-4ed1-ad9b-356b78ecd635", "event": "http_response", "timestamp": "2025-12-29T00:00:29.282186Z", "level": "warning"}
______________________________ TestValidationEdgeCases.test_create_task_max_title_length ______________________________

self = <test_endpoints.TestValidationEdgeCases object at 0x000002B1A30ECF20>
client = <httpx.AsyncClient object at 0x000002B1A4F53320>

    async def test_create_task_max_title_length(self, client):
        """Test task creation with maximum title length (500 chars)."""
        task_data = {
            "id": "T-MAX-TITLE",
            "title": "x" * 500,  # Max allowed length
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": "p2",
            "primary_project": "P-001",
            "primary_sprint": "S-001",
        }
    
        response = await client.post("/api/v1/tasks", json=task_data)
    
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests\integration\api\test_endpoints.py:1023: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/tasks", "query": null, "correlation_id": "a3afbe06-ea65-4c8e-ae73-a3b82ba9b3c9", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:29.545620Z", "level": "info"}
{"method": "POST", "path": "/api/v1/tasks", "status_code": 400, "duration_ms": 5.76, "correlation_id": "a3afbe06-ea65-4c8e-ae73-a3b82ba9b3c9", "event": "http_response", "timestamp": "2025-12-29T00:00:29.550920Z", "level": "warning"}
_________________________________ TestTaskServiceSearch.test_get_high_priority_tasks __________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000002B1A322DE80>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A4F50CE0>
mock_task_repository = <Mock name='TaskRepository()' id='2961999992672'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_high_priority_tasks(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test get high priority tasks (P0, P1)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
>           result = await service.get_high_priority_tasks(limit=20)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.services.task_service.TaskService object at 0x000002B1A4E9AAB0>, limit = 20, offset = 0

    async def get_high_priority_tasks(
        self,
        limit: int = 100,
        offset: int = 0,
    ) -> Result[list[TaskResponse], AppError]:
        """Get high-priority tasks (P0, P1).
    
        Args:
            limit: Maximum results (default: 100)
            offset: Results to skip (default: 0)
    
        Returns:
            Result containing high-priority tasks or error
    
        Example:
            result = await service.get_high_priority_tasks(limit=20)
            match result:
                case Ok(tasks):
                    print(f"Found {len(tasks)} critical tasks")
        """
        result = await self.task_repo.find_high_priority_tasks(limit, offset)
    
        match result:
            case Ok(tasks):
                responses = [
>                   self.response_class.model_validate(self._deserialize_json_fields(task))
                    for task in tasks
                ]
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E               acceptance_criteria.0
E                 Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
E                   For further information visit https://errors.pydantic.dev/2.11/v/dict_type

src\taskman_api\services\task_service.py:414: ValidationError
______________________________ TestTaskServiceSearch.test_search_by_status_and_priority _______________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000002B1A322DAF0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A4ED4E00>
mock_task_repository = <Mock name='TaskRepository()' id='2961999486592'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_search_by_status_and_priority(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test search with status and priority filters."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
            result = await service.search(
                status=TaskStatus.IN_PROGRESS, priority=Priority.P1
            )
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3B24C20>, Ok)

tests\unit\services\test_task_service.py:336: AssertionError
_____________________________________ TestTaskServiceSearch.test_search_by_status _____________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000002B1A322D730>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3B25820>
mock_task_repository = <Mock name='TaskRepository()' id='2961978840976'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_search_by_status(self, mocker, mock_task_repository, sample_task):
        """Test search by status filter."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
            result = await service.search(status=TaskStatus.IN_PROGRESS, limit=50)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3A3DFD0>, Ok)

tests\unit\services\test_task_service.py:310: AssertionError
____________________________________ TestTaskServiceSearch.test_get_blocked_tasks _____________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000002B1A322E210>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3B50B60>
mock_task_repository = <Mock name='TaskRepository()' id='2961979017936'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_blocked_tasks(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test get blocked tasks."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
>           result = await service.get_blocked_tasks()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.services.task_service.TaskService object at 0x000002B1A3B03260>, limit = 100, offset = 0

    async def get_blocked_tasks(
        self,
        limit: int = 100,
        offset: int = 0,
    ) -> Result[list[TaskResponse], AppError]:
        """Get all blocked tasks.
    
        Args:
            limit: Maximum results (default: 100)
            offset: Results to skip (default: 0)
    
        Returns:
            Result containing blocked tasks or error
    
        Example:
            result = await service.get_blocked_tasks()
            match result:
                case Ok(tasks):
                    for task in tasks:
                        print(f"Blocked: {task.title}")
        """
        result = await self.task_repo.find_by_status(
            TaskStatus.BLOCKED, limit, offset
        )
    
        match result:
            case Ok(tasks):
                responses = [
>                   self.response_class.model_validate(task) for task in tasks
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                ]
E               pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E               acceptance_criteria.0
E                 Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
E                   For further information visit https://errors.pydantic.dev/2.11/v/dict_type

src\taskman_api\services\task_service.py:449: ValidationError
__________________________________ TestTaskServiceAssignment.test_assign_to_project ___________________________________

self = <test_task_service.TestTaskServiceAssignment object at 0x000002B1A322CA70>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3B5BD70>
mock_task_repository = <Mock name='TaskRepository()' id='2961979064000'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_project(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to project."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            updated_task = sample_task
            updated_task.primary_project = "P-TASKMAN"
            mock_task_repository.update = AsyncMock(return_value=Ok(updated_task))
    
            # Act
>           result = await service.assign_to_project("T-TEST-001", "P-TASKMAN")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:274: in assign_to_project
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:103: in update
    project = await self.project_repo.get_by_id(update_data.primary_project)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.project_repository.ProjectRepository object at 0x000002B1A4BEBDA0>
entity_id = 'P-TASKMAN'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
___________________________________ TestTaskServiceAssignment.test_assign_to_sprint ___________________________________

self = <test_task_service.TestTaskServiceAssignment object at 0x000002B1A322C620>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A4F67A10>
mock_task_repository = <Mock name='TaskRepository()' id='2962000083376'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_sprint(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to sprint."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            updated_task = sample_task
            updated_task.primary_sprint = "S-2025-01"
            mock_task_repository.update = AsyncMock(return_value=Ok(updated_task))
    
            # Act
>           result = await service.assign_to_sprint("T-TEST-001", "S-2025-01")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:249: in assign_to_sprint
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:115: in update
    sprint = await self.sprint_repo.get_by_id(update_data.primary_sprint)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.sprint_repository.SprintRepository object at 0x000002B1A3B830E0>
entity_id = 'S-2025-01'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
______________________________ TestTaskServiceBulkOperations.test_bulk_update_fails_fast ______________________________

self = <test_task_service.TestTaskServiceBulkOperations object at 0x000002B1A322D2B0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3AD7860>
mock_task_repository = <Mock name='TaskRepository()' id='2961978521984'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_fails_fast(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test bulk update fails on first error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # First task succeeds, second task fails
            mock_task_repository.find_by_id = AsyncMock(
                side_effect=[
                    Ok(sample_task),  # First call succeeds
                    Err(
                        NotFoundError(
                            message="Task not found",
                            entity_type="Task",
                            entity_id="T-002",
                        )
                    ),  # Second call fails
                ]
            )
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-002", "status": "done"},  # This will fail
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service.py:289: AssertionError
_______________________________ TestTaskServiceBulkOperations.test_bulk_update_success ________________________________

self = <test_task_service.TestTaskServiceBulkOperations object at 0x000002B1A322CEF0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A5E600B0>
mock_task_repository = <Mock name='TaskRepository()' id='2962015786272'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_success(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test successful bulk update of multiple tasks."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update for each task
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-002", "priority": "p1"},
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3B16750>, Ok)

tests\unit\services\test_task_service.py:245: AssertionError
____________________________ TestTaskServiceStatusTransitions.test_change_status_not_found ____________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000002B1A322C3B0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3B17290>
mock_task_repository = <Mock name='TaskRepository()' id='2961978783456'>

    @pytest.mark.asyncio
    async def test_change_status_not_found(self, mocker, mock_task_repository):
        """Test change_status with non-existent task."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get() to return NotFoundError
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Err(
                    NotFoundError(
                        message="Task not found",
                        entity_type="Task",
                        entity_id="T-NONEXISTENT",
                    )
                )
            )
    
            # Act
            result = await service.change_status("T-NONEXISTENT", TaskStatus.READY)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service.py:106: AssertionError
_______________________ TestTaskServiceStatusTransitions.test_change_status_invalid_transition ________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000002B1A322C0B0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A3AB7F20>
mock_task_repository = <Mock name='TaskRepository()' id='2961979146320'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.DONE')>

    @pytest.mark.asyncio
    async def test_change_status_invalid_transition(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid status transition (DONE  IN_PROGRESS)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get() to return task with DONE status (terminal state)
            sample_task.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.IN_PROGRESS)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service.py:75: AssertionError
________________________ TestTaskServiceStatusTransitions.test_change_status_valid_transition _________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000002B1A321F920>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000002B1A5A88A40>
mock_task_repository = <Mock name='TaskRepository()' id='2962011752016'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_change_status_valid_transition(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid status transition (NEW  READY)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Create independent copies to avoid fixture mutation
            task_with_new_status = copy.deepcopy(sample_task)
            task_with_new_status.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_with_new_status))
    
            # Mock update with independent task copy
            task_with_ready_status = copy.deepcopy(sample_task)
            task_with_ready_status.status = TaskStatus.READY
            mock_task_repository.update = AsyncMock(return_value=Ok(task_with_ready_status))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3B29430>, Ok)

tests\unit\services\test_task_service.py:48: AssertionError
______________________________________ TestBaseRepository.test_update_not_found _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311FFB0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3B29460>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_update_not_found(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test update returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:243: TypeError
_________________________________________ TestBaseRepository.test_exists_true _________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A314CD10>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3AFB080>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_exists_true(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test exists returns True when entity exists."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:334: TypeError
____________________________________________ TestBaseRepository.test_count ____________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A314D460>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3AFABD0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_count(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test count returns correct number of entities."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:367: TypeError
_______________________________________ TestBaseRepository.test_update_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A314C5C0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A3A7F230>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_update_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity update."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:218: TypeError
________________________________________ TestBaseRepository.test_exists_false _________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A314D070>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4F67B90>

    async def test_exists_false(self, async_session: AsyncSession):
        """Test exists returns False when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:350: TypeError
_____________________________________ TestBaseRepository.test_find_by_id_success ______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311F410>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4E9B320>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_id_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful find by ID."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:110: TypeError
______________________________________ TestBaseRepository.test_find_all_success _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311FB90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4ED4140>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_all_success(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test find all with pagination."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:149: TypeError
____________________________________ TestBaseRepository.test_find_by_id_not_found _____________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311F800>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A555FD70>

    async def test_find_by_id_not_found(self, async_session: AsyncSession):
        """Test find by ID returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:128: TypeError
_______________________________________ TestBaseRepository.test_create_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311EB70>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4F51640>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_create_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity creation."""
        # Arrange
        await async_session.commit()  # Ensure clean state
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:29: TypeError
_____________________________ TestBaseRepository.test_find_all_validation_limit_exceeded ______________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A314C1A0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4EBFBF0>

    async def test_find_all_validation_limit_exceeded(self, async_session: AsyncSession):
        """Test find all with limit > 1000 returns ValidationError."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:199: TypeError
______________________________________ TestBaseRepository.test_delete_not_found _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A314C380>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4F53140>

    async def test_delete_not_found(self, async_session: AsyncSession):
        """Test delete returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:315: TypeError
_______________________________________ TestBaseRepository.test_create_conflict _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311F020>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A4F52510>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_create_conflict(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test create with duplicate ID returns ConflictError."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:54: TypeError
_______________________________________ TestBaseRepository.test_delete_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000002B1A311FC20>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000002B1A5E8B8C0>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_delete_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity deletion."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'

tests\unit\db\repositories\test_base_repository.py:295: TypeError
________________________________ TestActionListIntegration.test_action_list_lifecycle _________________________________

self = <test_action_lists_api.TestActionListIntegration object at 0x000002B1A3075700>
client = <httpx.AsyncClient object at 0x000002B1A3B99FA0>

    async def test_action_list_lifecycle(self, client: AsyncClient):
        """Test complete action list lifecycle: Create -> Get -> Update -> Delete."""
        # 1. Create
        create_payload = {
            "id": "AL-INT-001",
            "title": "Integration Test List",
            "description": "Test Description",
            "status": "active",
            "items": [{"id": "Task-1", "text": "Task 1"}, {"id": "Task-2", "text": "Task 2"}],
        }
        create_res = await client.post("/api/v1/action-lists", json=create_payload)
        # If schema mismatch, we get 422.
        if create_res.status_code != status.HTTP_201_CREATED:
            pytest.fail(f"Create failed: {create_res.text}")
    
        assert create_res.status_code == status.HTTP_201_CREATED
        created_data = create_res.json()
        list_id = created_data["id"]
        # Service overwrites ID with AL-xxxx format, so it won't be AL-INT-001
        assert list_id.startswith("AL-")
        assert created_data["title"] == "Integration Test List"
        # task_ids in response might be just IDs or full items depending on response schema mapping from entity
        # Entity has task_ids=[dict, dict]. Response has items=[dict, dict].
>       assert len(created_data["items"]) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests\integration\api\test_action_lists_api.py:35: AssertionError
------------------------------------------------ Captured stdout call -------------------------------------------------
{"method": "POST", "path": "/api/v1/action-lists", "query": null, "correlation_id": "e35301c0-8e2e-495a-9a95-68605b180de3", "client_ip": "127.0.0.1", "event": "http_request", "timestamp": "2025-12-29T00:00:30.588143Z", "level": "info"}
{"list_id": "AL-0013", "event": "action_list_created", "timestamp": "2025-12-29T00:00:30.599143Z", "level": "info"}
{"method": "POST", "path": "/api/v1/action-lists", "status_code": 201, "duration_ms": 11.81, "correlation_id": "e35301c0-8e2e-495a-9a95-68605b180de3", "event": "http_response", "timestamp": "2025-12-29T00:00:30.600143Z", "level": "info"}
____________________________ TestTaskCreateRequest.test_task_id_pattern_validation_failure ____________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000002B1A31D5340>

    def test_task_id_pattern_validation_failure(self):
        """Test task ID pattern validation with invalid patterns."""
        # Test pattern validation errors
        pattern_invalid_ids = [
            "TASK-001",  # Wrong prefix
            "T001",  # Missing hyphen
            "T-",  # No ID part
            "T-@invalid",  # Invalid character
        ]
    
        for task_id in pattern_invalid_ids:
            data = {
                "id": task_id,
                "title": "Test",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": Priority.P2,
                "primary_project": "P-TEST",
                "primary_sprint": "S-TEST",
            }
    
            with pytest.raises(ValidationError) as exc_info:
                TaskCreateRequest(**data)
    
            errors = exc_info.value.errors()
            assert any("pattern" in str(err).lower() for err in errors)
    
        # Test min_length validation (empty string)
        data = {
            "id": "",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P2,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
        }
        with pytest.raises(ValidationError) as exc_info:
            TaskCreateRequest(**data)
        errors = exc_info.value.errors()
>       assert any("at least 1 character" in str(err).lower() for err in errors)
E       assert False
E        +  where False = any(<generator object TestTaskCreateRequest.test_task_id_pattern_validation_failure.<locals>.<genexpr> at 0x000002B1A59DFBC0>)

tests\unit\schemas\test_task_schemas.py:104: AssertionError
________________________________ TestTaskCreateRequest.test_required_fields_validation ________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000002B1A31D55E0>

    def test_required_fields_validation(self):
        """Test that required fields are validated."""
        # Missing required fields
        data = {
            "id": "T-TEST-001",
        }
    
        with pytest.raises(ValidationError) as exc_info:
            TaskCreateRequest(**data)
    
        errors = exc_info.value.errors()
        required_fields = {"title", "summary", "description", "owner", "priority", "primary_project", "primary_sprint"}
        error_fields = {err["loc"][0] for err in errors}
    
>       assert required_fields.issubset(error_fields)
E       AssertionError: assert False
E        +  where False = <built-in method issubset of set object at 0x000002B1A4F26260>({'description', 'owner', 'primary_project', 'primary_sprint', 'summary', 'title'})
E        +    where <built-in method issubset of set object at 0x000002B1A4F26260> = {'description', 'owner', 'primary_project', 'primary_sprint', 'priority', 'summary', ...}.issubset

tests\unit\schemas\test_task_schemas.py:120: AssertionError
__________________________________ TestTaskCreateRequest.test_enum_field_validation ___________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000002B1A31D4080>

    def test_enum_field_validation(self):
        """Test enum field validation."""
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P1,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "status": TaskStatus.IN_PROGRESS,
            "severity": Severity.SEV2,
            "shape": GeometryShape.CIRCLE,
        }
    
>       request = TaskCreateRequest(**data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskCreate
E       severity
E         Input should be 'critical', 'high', 'medium' or 'low' [type=enum, input_value=<Severity.SEV2: 'sev2'>, input_type=Severity]
E           For further information visit https://errors.pydantic.dev/2.11/v/enum

tests\unit\schemas\test_task_schemas.py:206: ValidationError
________________________________ TestTaskCreateRequest.test_business_value_score_range ________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000002B1A31D5760>

    def test_business_value_score_range(self):
        """Test business_value_score must be 0-10."""
        # Test below range
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P2,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "business_value_score": -1,
        }
    
        with pytest.raises(ValidationError):
            TaskCreateRequest(**data)
    
        # Test above range
        data["business_value_score"] = 11
    
>       with pytest.raises(ValidationError):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>

tests\unit\schemas\test_task_schemas.py:182: Failed
____________________________________ TestTaskResponse.test_response_from_orm_model ____________________________________

self = <test_task_schemas.TestTaskResponse object at 0x000002B1A31D6870>

    def test_response_from_orm_model(self):
        """Test creating response from ORM model."""
        from taskman_api.models.task import Task
    
        # Create mock ORM task
        task = Task(
            id="T-TEST-001",
            title="Test Task",
            summary="Summary",
            description="Description",
            status=TaskStatus.NEW,
            owner="owner",
            assignees=[],
            priority=Priority.P1,
            primary_project="P-TEST",
            primary_sprint="S-TEST",
            related_projects=[],
            related_sprints=[],
            parents=[],
            depends_on=[],
            blocks=[],
            blockers=[],
            acceptance_criteria=[],
            definition_of_done=[],
            quality_gates={},
            verification={},
            actions_taken=[],
            labels=[],
            related_links=[],
            risks=[],
            observability={},
        )
    
        # Set timestamps manually (normally set by TimestampMixin)
        task.created_at = datetime(2025, 1, 1, 12, 0, 0)
        task.updated_at = datetime(2025, 1, 1, 12, 0, 0)
    
        # Create response from ORM model
>       response = TaskResponse.model_validate(task)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E       automation_candidate
E         Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.11/v/bool_type

tests\unit\schemas\test_task_schemas.py:313: ValidationError
____________________________________ TestTaskResponse.test_response_serialization _____________________________________

self = <test_task_schemas.TestTaskResponse object at 0x000002B1A31D6A80>

    def test_response_serialization(self):
        """Test response can be serialized to dict/JSON."""
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "status": TaskStatus.NEW,
            "owner": "owner",
            "assignees": [],
            "priority": Priority.P1,
            "severity": None,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "related_projects": [],
            "related_sprints": [],
            "estimate_points": None,
            "actual_time_hours": None,
            "due_at": None,
            "parents": [],
            "depends_on": [],
            "blocks": [],
            "blockers": [],
            "acceptance_criteria": [],
            "definition_of_done": [],
            "quality_gates": {},
            "verification": {},
            "actions_taken": [],
            "labels": [],
            "related_links": [],
            "shape": None,
            "stage": None,
            "work_type": None,
            "work_stream": None,
            "business_value_score": None,
            "cost_of_delay_score": None,
            "automation_candidate": None,
            "cycle_time_days": None,
            "risks": [],
            "observability": {},
            "created_at": datetime(2025, 1, 1, 12, 0, 0),
            "updated_at": datetime(2025, 1, 1, 12, 0, 0),
        }
    
>       response = TaskResponse(**data)
                   ^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E       automation_candidate
E         Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.11/v/bool_type

tests\unit\schemas\test_task_schemas.py:364: ValidationError

---------- coverage: platform win32, python 3.12.11-final-0 ----------
Name                                                     Stmts   Miss Branch BrPart   Cover   Missing
-----------------------------------------------------------------------------------------------------
src\taskman_api\__init__.py                                  0      0      0      0 100.00%
src\taskman_api\config.py                                   62      2      6      0  97.06%   255, 261
src\taskman_api\core\__init__.py                             4      0      0      0 100.00%
src\taskman_api\core\enums.py                               71      0      0      0 100.00%
src\taskman_api\core\errors.py                              78     31     36      6  53.51%   48-57, 107, 136, 138, 139->141, 141->143, 144, 169-177, 199-205, 226-230, 253-259
src\taskman_api\core\result.py                              37      6      0      0  83.78%   40, 50, 54, 66, 72, 76
src\taskman_api\db\__init__.py                               3      0      0      0 100.00%
src\taskman_api\db\base.py                                   6      1      0      0  83.33%   32
src\taskman_api\db\connection_manager.py                    91     52     10      2  40.59%   66-68, 97-101, 108-112, 117-121, 135-165, 170-183
src\taskman_api\db\session.py                               27      7      4      0  64.52%   48-50, 63-64, 73-75
src\taskman_api\dependencies.py                             43      8      0      0  81.40%   33-37, 47, 52, 57, 62
src\taskman_api\main.py                                    104     38     18      3  56.56%   54-77, 106-160, 242, 244, 246, 272, 295, 306
src\taskman_api\middleware\__init__.py                       2      0      0      0 100.00%
src\taskman_api\middleware\logging_middleware.py            85     15     32     10  73.50%   77, 98, 102, 123, 127, 133, 168, 193->197, 249-255, 258->272, 261
src\taskman_api\models\__init__.py                           5      0      0      0 100.00%
src\taskman_api\models\action_list.py                       39      5      6      3  82.22%   34, 40, 46, 83, 88
src\taskman_api\models\project.py                           45      1      0      0  97.78%   91
src\taskman_api\models\sprint.py                            51      2      0      0  96.08%   44, 101
src\taskman_api\models\task.py                              56      0      0      0 100.00%
src\taskman_api\repositories\__init__.py                     6      0      0      0 100.00%
src\taskman_api\repositories\action_list_repository.py      43     20     10      1  49.06%   27-32, 36-39, 61-64, 71-74, 77, 88-95, 99-101, 105-107, 111-112
src\taskman_api\repositories\base.py                        33      5      0      0  84.85%   41-44, 66-71
src\taskman_api\repositories\project_repository.py          46      4     12      4  86.21%   31-34, 107->109, 110, 111->113, 114
src\taskman_api\repositories\sprint_repository.py           51      5     14      5  84.62%   31-34, 119->121, 122, 123->125, 126, 128
src\taskman_api\repositories\task_repository.py             78     47     42      3  33.33%   26-29, 33-34, 38-41, 48, 52-55, 81, 83, 85, 92-95, 98, 142-180, 201-233
src\taskman_api\routers\__init__.py                          7      0      0      0 100.00%
src\taskman_api\routers\action_lists.py                    114     81     56      0  19.41%   50-62, 76-82, 92-105, 117-129, 139-148, 160-172, 182-194, 209-226, 236-247, 261-276
src\taskman_api\routers\agent.py                            30     15      6      0  41.67%   32-72
src\taskman_api\routers\diagnostic.py                       20     14      0      0  30.00%   16-40
src\taskman_api\routers\projects.py                         73     43     32      0  30.48%   42-43, 53-64, 74-86, 96-103, 115-126, 136-143
src\taskman_api\routers\sprints.py                         108     71     52      0  24.38%   48-49, 59-70, 80-94, 104-111, 121-128, 140-151, 161-168, 176-185, 193-202
src\taskman_api\routers\tasks.py                            94     56     42      0  30.88%   47-48, 57-58, 72-83, 93-105, 115-122, 133-144, 154-161, 170-183
src\taskman_api\schemas\__init__.py                          7      0      0      0 100.00%
src\taskman_api\schemas\action_list.py                      82      1      2      1  97.62%   102
src\taskman_api\schemas\base.py                             53      3      6      1  89.83%   25-28
src\taskman_api\schemas\enums.py                            62      0      0      0 100.00%
src\taskman_api\schemas\project.py                         108      1      2      1  98.18%   165
src\taskman_api\schemas\sprint.py                          109      2      4      2  96.46%   148, 155
src\taskman_api\schemas\task.py                            138      2      4      2  97.18%   218, 226
src\taskman_api\services\__init__.py                         6      0      0      0 100.00%
src\taskman_api\services\action_list_service.py             86     51     16      0  34.31%   60-65, 89-91, 97-107, 113-121, 125-136, 144-164
src\taskman_api\services\base.py                           110     18     24      3  81.34%   73-75, 102-104, 158, 196, 212->211, 241-242, 251, 273-278, 297-298, 309-310
src\taskman_api\services\project_service.py                 97     71     36      0  19.55%   78-85, 115-175, 198-212, 232-246, 265-266, 290-300, 321-331
src\taskman_api\services\sprint_service.py                 141     91     48      1  29.10%   89-96, 114-120, 127-129, 134-157, 184->186, 209-229, 262-325, 344-345, 369-380, 401-410, 431-440, 462-470
src\taskman_api\services\task_service.py                    92     15     32      6  76.61%   104->114, 164-178, 317, 318->305, 379-384, 417-419, 451-453
-----------------------------------------------------------------------------------------------------
TOTAL                                                     2603    784    552     54  61.77%

FAIL Required test coverage of 70.0% not reached. Total coverage: 61.77%
=============================================== short test summary info ===============================================
FAILED tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_soft_delete_fields - pydantic_core._pydantic_core.ValidationError: 1 validation error for ActionListCreate
status
  Input should be 'active' or 'archived' [type=enum, input_value='deleted', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/enum
FAILED tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_create_request_valid - AssertionError: assert <ProjectStatu...G: 'planning'> == <ProjectStatu...: 'discovery'>
  
  - discovery
  + planning
FAILED tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_create_request_valid - AssertionError: assert <SprintStatus...G: 'planning'> == <SprintStatus...ED: 'planned'>
  
  - planned
  + planning
FAILED tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_response_with_metrics - pydantic_core._pydantic_core.ValidationError: 1 validation error for SprintResponse
dependencies
  Input should be a valid list [type=list_type, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.11/v/list_type
FAILED tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_strict_type_validation - ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)
FAILED tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_from_attributes_orm_mode - ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project_with_status_filter - AttributeError: 'TaskRepository' object has no attribute 'find_by_project'. Did you mean: 'get_by_project'?
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_blocked_tasks - AttributeError: 'TaskRepository' object has no attribute 'find_blocked_tasks'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status_and_priority - AttributeError: 'TaskRepository' object has no attribute 'find_by_status_and_priority'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_owner - AttributeError: 'TaskRepository' object has no attribute 'find_by_owner'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_sprint - AttributeError: 'TaskRepository' object has no attribute 'find_by_sprint'. Did you mean: 'get_by_sprint'?
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_high_priority_tasks - AttributeError: 'TaskRepository' object has no attribute 'find_high_priority_tasks'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_priority - AttributeError: 'TaskRepository' object has no attribute 'find_by_priority'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status - AttributeError: 'TaskRepository' object has no attribute 'find_by_status'. Did you mean: 'get_by_status'?
FAILED tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A37F7D40>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A38BE6F0>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_true - assert <taskman_api.core.result.Ok object at 0x000002B1A3981940> is True
 +  where <taskman_api.core.result.Ok object at 0x000002B1A3981940> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000002B1A399EBA0>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_count_success - assert <taskman_api.core.result.Ok object at 0x000002B1A37F6EA0> == 42
 +  where <taskman_api.core.result.Ok object at 0x000002B1A37F6EA0> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000002B1A38DE750>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_false - assert <taskman_api.core.result.Ok object at 0x000002B1A38DD5E0> is False
 +  where <taskman_api.core.result.Ok object at 0x000002B1A38DD5E0> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000002B1A38FA300>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3773710>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3937B60>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_empty_result - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3A8F650>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_conflict_error - assert False
 +  where False = isinstance(AppError("9 validation errors for TaskResponse\nid\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\ntitle\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nsummary\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\ndescription\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nstatus\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nowner\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\npriority\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nprimary_project\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing\nprimary_sprint\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/missing"), ConflictError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A37ACF80>, Ok)
FAILED tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_orphaned - TypeError: 'title' is an invalid keyword argument for ActionList
FAILED tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_by_owner - TypeError: 'title' is an invalid keyword argument for ActionList
FAILED tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_active_projects - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_by_status - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_active_sprints - TypeError: 'tasks' is an invalid keyword argument for Sprint
FAILED tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_by_status - TypeError: 'tasks' is an invalid keyword argument for Sprint
FAILED tests/unit/test_config.py::TestSettings::test_with_redis_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_valid_settings_development - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_optional_redis_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_development_allows_insecure_secrets - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_valid_settings_production - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_environment_helpers - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestGetSettings::test_cache_clear - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/test_config.py::TestGetSettings::test_settings_cached - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_partial_failure_fails_fast - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_project - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_sprint - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_new_to_ready - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A38FA9C0>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_new_to_done - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_done - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3899A00>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_new - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_dropped_to_ready - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_in_progress - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_ready_to_blocked - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_blocked - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A4C64230>, Ok)
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_conflict - assert 201 == 409
 +  where 201 = <Response [201 Created]>.status_code
 +  and   409 = status.HTTP_409_CONFLICT
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_create_action_list_success - AssertionError: assert 'AL-0003' == 'AL-TEST-001'
  
  - AL-TEST-001
  + AL-0003
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_get_action_list_success - assert 404 == 200
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_success - assert 405 == 200
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_list_action_lists - AssertionError: assert False
 +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:25', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:25', 'description': 'Description', 'due_date': None, ...}, {'completed_at': None, 'created_at': '2025-12-29T00:00:25', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_update_action_list_not_found - assert 405 == 404
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   404 = status.HTTP_404_NOT_FOUND
FAILED tests/integration/api/test_endpoints.py::TestActionListEndpoints::test_delete_action_list_success - assert 404 == 204
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   204 = status.HTTP_204_NO_CONTENT
FAILED tests/integration/api/test_endpoints.py::TestHealthEndpoint::test_health_check - AttributeError: 'Settings' object has no attribute 'database'
FAILED tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_success - assert 405 == 200
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_list_projects - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}, {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestProjectEndpoints::test_update_project_not_found - assert 405 == 404
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   404 = status.HTTP_404_NOT_FOUND
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_action_lists_limit_boundary - AssertionError: assert False
 +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_large_limit - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_offset - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_projects_empty_result - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_zero_offset - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_default_pagination - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_sprints_with_pagination - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestPaginationEdgeCases::test_list_tasks_with_limit - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_delete_sprint_success - assert 404 == 204
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   204 = status.HTTP_204_NO_CONTENT
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_get_sprint_success - assert 404 == 200
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_not_found - assert 405 == 404
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   404 = status.HTTP_404_NOT_FOUND
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_update_sprint_success - assert 404 == 201
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_conflict - assert 404 == 201
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_create_sprint_success - assert 404 == 201
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestSprintEndpoints::test_list_sprints - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_project - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_owner - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_empty_filter_value - AssertionError: assert False
 +  where False = isinstance({'action_lists': [], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_invalid_filter_ignored - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_filter_by_priority - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_filter_by_owner - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [{'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_tasks_multiple_filters - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_action_lists_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'action_lists': [{'completed_at': None, 'created_at': '2025-12-29T00:00:28', 'description': 'Description', 'due_date': None, ...}], 'has_more': False, 'page': 1, 'per_page': 20, ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_projects_no_filters - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'projects': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestFilteringEdgeCases::test_list_sprints_filter_by_status - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'sprints': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_list_tasks - AssertionError: assert False
 +  where False = isinstance({'has_more': False, 'page': 1, 'per_page': 20, 'tasks': [], ...}, list)
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_get_task_success - assert 404 == 200
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_delete_task_success - assert 404 == 204
 +  where 404 = <Response [404 Not Found]>.status_code
 +  and   204 = status.HTTP_204_NO_CONTENT
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_update_task_success - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_success - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestTaskEndpoints::test_create_task_conflict - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_update_action_list_invalid_status - assert 405 == 200
 +  where 405 = <Response [405 Method Not Allowed]>.status_code
 +  and   200 = status.HTTP_200_OK
FAILED tests/integration/api/test_endpoints.py::TestValidationEdgeCases::test_create_task_max_title_length - assert 400 == 201
 +  where 400 = <Response [400 Bad Request]>.status_code
 +  and   201 = status.HTTP_201_CREATED
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_high_priority_tasks - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
acceptance_criteria.0
  Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/dict_type
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status_and_priority - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3B24C20>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3A3DFD0>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_blocked_tasks - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
acceptance_criteria.0
  Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/dict_type
FAILED tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_project - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_sprint - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_fails_fast - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3B16750>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_invalid_transition - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_valid_transition - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000002B1A3B29430>, Ok)
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_not_found - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_true - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_count - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_success - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_false - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_success - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_success - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_not_found - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_success - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_validation_limit_exceeded - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_not_found - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_conflict - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_success - TypeError: Can't instantiate abstract class BaseRepository without an implementation for abstract method 'exists'
FAILED tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_action_list_lifecycle - assert 0 == 2
 +  where 0 = len([])
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_failure - assert False
 +  where False = any(<generator object TestTaskCreateRequest.test_task_id_pattern_validation_failure.<locals>.<genexpr> at 0x000002B1A59DFBC0>)
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_required_fields_validation - AssertionError: assert False
 +  where False = <built-in method issubset of set object at 0x000002B1A4F26260>({'description', 'owner', 'primary_project', 'primary_sprint', 'summary', 'title'})
 +    where <built-in method issubset of set object at 0x000002B1A4F26260> = {'description', 'owner', 'primary_project', 'primary_sprint', 'priority', 'summary', ...}.issubset
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_enum_field_validation - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskCreate
severity
  Input should be 'critical', 'high', 'medium' or 'low' [type=enum, input_value=<Severity.SEV2: 'sev2'>, input_type=Severity]
    For further information visit https://errors.pydantic.dev/2.11/v/enum
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_business_value_score_range - Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_from_orm_model - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
automation_candidate
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.11/v/bool_type
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_serialization - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
automation_candidate
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.11/v/bool_type
ERROR tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_get_burndown_calculations - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_calculate_velocity_mixed_tasks - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_project_not_found - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_no_tasks - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_partial_single_field - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_empty_mission - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_all_fields - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_minimum_fields - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_status_no_results - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_owner_no_results - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_success - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_project_not_found - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_remove_sprint_from_project - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_duplicate_sprint_idempotent - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_sprint_to_project - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/test_fixtures.py::TestMinimalSettingsFixture::test_fixture_provides_minimal_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_database - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_redis - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_simulates_production - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_settings_default_to_testing - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_redis - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_database - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_provides_complete_settings - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.11/v/extra_forbidden
ERROR tests/unit/db/test_connection_manager.py::test_init_creates_engines - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_get_session_failover - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_get_session_primary_success - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_health_check_reporting - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/db/test_connection_manager.py::test_health_check_primary_down - AttributeError: module 'db' has no attribute 'connection_manager'
ERROR tests/unit/services/test_services.py::TestActionListService::test_remove_item - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_get_soft_deleted - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_reorder_items_success - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_add_item - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_mark_complete - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_reorder_items_invalid_length - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_get_orphaned - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_by_project - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_current_sprints - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_burndown - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_update_metrics - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_change_status - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_calculate_velocity - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestProjectService::test_change_status - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_by_owner - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_add_sprint - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_remove_sprint - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_metrics_success - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_by_status - TypeError: 'sprints' is an invalid keyword argument for Project
===================================== 130 failed, 96 passed, 47 errors in 19.15s ======================================
