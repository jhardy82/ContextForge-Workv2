================================================= test session starts =================================================
platform win32 -- Python 3.11.9, pytest-8.4.2, pluggy-1.6.0 -- C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\.venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api
configfile: pytest_full.ini
plugins: anyio-4.12.0, Faker-30.10.0, asyncio-0.26.0, cov-5.0.0, mock-3.15.1
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
collecting ... collected 208 items

test_sqlite_integration.py::test_add_item_endpoint PASSED                                                        [  0%]
tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_action_list_lifecycle PASSED     [  0%]
tests/integration/api/test_action_lists_api.py::TestActionListIntegration::test_validation_errors PASSED         [  1%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_crud_lifecycle PASSED           [  1%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_validation_errors PASSED        [  2%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_project_metrics_endpoint PASSED         [  2%]
tests/integration/api/test_projects_api.py::TestProjectIntegration::test_duplicate_project_id PASSED             [  3%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_management PASSED                  [  3%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_validation_errors PASSED           [  4%]
tests/integration/api/test_sprints_api.py::TestSprintIntegration::test_sprint_velocity_calculation PASSED        [  4%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_create_task_full_lifecycle PASSED             [  5%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_task_validation_errors PASSED                 [  5%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_list_tasks_pagination_and_filtering PASSED    [  6%]
tests/integration/api/test_tasks_api.py::TestTaskIntegration::test_duplicate_task_id PASSED                      [  6%]
tests/integration/services/test_cross_service_ops.py::test_full_workflow_simulation PASSED                       [  7%]
tests/integration/services/test_project_sprint_flow.py::test_project_sprint_task_hierarchy PASSED                [  7%]
tests/integration/services/test_project_sprint_flow.py::test_orphan_prevention PASSED                            [  8%]
tests/integration/services/test_task_sprint_flow.py::test_task_movement_between_sprints PASSED                   [  8%]
tests/integration/services/test_task_sprint_flow.py::test_sprint_closure_logic PASSED                            [  9%]
tests/integration/services/test_task_validation.py::test_create_task_with_invalid_project PASSED                 [  9%]
tests/integration/services/test_task_validation.py::test_create_task_with_invalid_sprint PASSED                  [ 10%]
tests/integration/services/test_task_validation.py::test_update_task_with_invalid_foreign_keys PASSED            [ 10%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_success FAILED               [ 11%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_conflict FAILED              [ 11%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_success FAILED           [ 12%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_not_found FAILED         [ 12%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_success FAILED             [ 12%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_validation_limit_exceeded FAILED [ 13%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_success FAILED               [ 13%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_not_found FAILED             [ 14%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_success FAILED               [ 14%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_not_found FAILED             [ 15%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_true FAILED                  [ 15%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_false FAILED                 [ 16%]
tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_count FAILED                        [ 16%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_exists PASSED        [ 17%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_get_by_owner PASSED  [ 17%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_search_filters_and_pagination PASSED [ 18%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_create_project_method PASSED [ 18%]
tests/unit/db/repositories/test_project_repository.py::TestProjectRepositoryEdgeCases::test_update_project_method PASSED [ 19%]
tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_by_status FAILED               [ 19%]
tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_active_projects FAILED         [ 20%]
tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_by_status FAILED                [ 20%]
tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_active_sprints FAILED           [ 21%]
tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_by_owner FAILED             [ 21%]
tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_orphaned FAILED             [ 22%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_exists PASSED          [ 22%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_get_by_project PASSED  [ 23%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_get_active_sprints PASSED [ 23%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_search_sprints PASSED  [ 24%]
tests/unit/db/repositories/test_sprint_repository.py::TestSprintRepositoryEdgeCases::test_create_and_update_sprint_helpers PASSED [ 24%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status FAILED               [ 25%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_priority FAILED             [ 25%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_owner FAILED                [ 25%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project FAILED              [ 26%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project_with_status_filter FAILED [ 26%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_sprint FAILED               [ 27%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status_and_priority FAILED  [ 27%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_blocked_tasks FAILED           [ 28%]
tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_high_priority_tasks FAILED     [ 28%]
tests/unit/db/test_connection_manager.py::test_init_creates_engines FAILED                                       [ 29%]
tests/unit/db/test_connection_manager.py::test_get_session_primary_success FAILED                                [ 29%]
tests/unit/db/test_connection_manager.py::test_get_session_failover PASSED                                       [ 30%]
tests/unit/db/test_connection_manager.py::test_health_check_reporting PASSED                                     [ 30%]
tests/unit/db/test_connection_manager.py::test_health_check_primary_down PASSED                                  [ 31%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_create_request_valid FAILED                 [ 31%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_id_pattern_validation PASSED                [ 32%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_update_request_partial PASSED               [ 32%]
tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_response_serialization PASSED               [ 33%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_create_request_valid FAILED                   [ 33%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_id_pattern_validation PASSED                  [ 34%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_velocity_points_non_negative PASSED           [ 34%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_update_request_partial PASSED                 [ 35%]
tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_response_with_metrics FAILED                  [ 35%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_create_request_valid PASSED          [ 36%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_with_associations PASSED             [ 36%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_soft_delete_fields FAILED            [ 37%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_update_request_partial PASSED        [ 37%]
tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_response_with_metadata PASSED        [ 37%]
tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_strict_type_validation FAILED              [ 38%]
tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_from_attributes_orm_mode FAILED            [ 38%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_valid_task_create_request PASSED            [ 39%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_success PASSED   [ 39%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_failure FAILED   [ 40%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_required_fields_validation FAILED           [ 40%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_title_max_length_validation PASSED          [ 41%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_estimate_points_non_negative PASSED         [ 41%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_business_value_score_range FAILED           [ 42%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_enum_field_validation FAILED                [ 42%]
tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_default_values PASSED                       [ 43%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_partial_update_all_fields_optional PASSED   [ 43%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_update_with_multiple_fields PASSED          [ 44%]
tests/unit/schemas/test_task_schemas.py::TestTaskUpdateRequest::test_update_validation_rules_still_apply PASSED  [ 44%]
tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_from_orm_model FAILED                   [ 45%]
tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_serialization FAILED                    [ 45%]
tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_success FAILED                      [ 46%]
tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_conflict_error FAILED               [ 46%]
tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_success FAILED                            [ 47%]
tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_not_found FAILED                          [ 47%]
tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_success FAILED                      [ 48%]
tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_not_found FAILED                    [ 48%]
tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_success FAILED                      [ 49%]
tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_not_found FAILED                    [ 49%]
tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_success FAILED                          [ 50%]
tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_empty_result FAILED                     [ 50%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_true FAILED                        [ 50%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_false FAILED                       [ 51%]
tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_count_success FAILED                      [ 51%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_minimum_fields ERROR [ 52%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_all_fields ERROR [ 52%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_partial_single_field ERROR [ 53%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_empty_mission ERROR [ 53%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_success ERROR [ 54%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_project_not_found ERROR [ 54%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_sprint_to_project ERROR [ 55%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_duplicate_sprint_idempotent ERROR [ 55%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_remove_sprint_from_project ERROR [ 56%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_no_tasks ERROR [ 56%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_project_not_found ERROR [ 57%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_status_no_results ERROR [ 57%]
tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_owner_no_results ERROR [ 58%]
tests/unit/services/test_services.py::TestProjectService::test_get_metrics_success ERROR                         [ 58%]
tests/unit/services/test_services.py::TestProjectService::test_add_sprint ERROR                                  [ 59%]
tests/unit/services/test_services.py::TestProjectService::test_remove_sprint ERROR                               [ 59%]
tests/unit/services/test_services.py::TestProjectService::test_change_status ERROR                               [ 60%]
tests/unit/services/test_services.py::TestProjectService::test_get_by_status ERROR                               [ 60%]
tests/unit/services/test_services.py::TestProjectService::test_get_by_owner ERROR                                [ 61%]
tests/unit/services/test_services.py::TestSprintService::test_calculate_velocity ERROR                           [ 61%]
tests/unit/services/test_services.py::TestSprintService::test_get_burndown ERROR                                 [ 62%]
tests/unit/services/test_services.py::TestSprintService::test_change_status ERROR                                [ 62%]
tests/unit/services/test_services.py::TestSprintService::test_get_current_sprints ERROR                          [ 62%]
tests/unit/services/test_services.py::TestSprintService::test_get_by_project ERROR                               [ 63%]
tests/unit/services/test_services.py::TestSprintService::test_update_metrics ERROR                               [ 63%]
tests/unit/services/test_services.py::TestActionListService::test_reorder_items_success ERROR                    [ 64%]
tests/unit/services/test_services.py::TestActionListService::test_reorder_items_invalid_length ERROR             [ 64%]
tests/unit/services/test_services.py::TestActionListService::test_mark_complete ERROR                            [ 65%]
tests/unit/services/test_services.py::TestActionListService::test_add_item ERROR                                 [ 65%]
tests/unit/services/test_services.py::TestActionListService::test_remove_item ERROR                              [ 66%]
tests/unit/services/test_services.py::TestActionListService::test_get_orphaned ERROR                             [ 66%]
tests/unit/services/test_services.py::TestActionListService::test_get_soft_deleted ERROR                         [ 67%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_calculate_velocity_mixed_tasks ERROR [ 67%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_get_burndown_calculations ERROR [ 68%]
tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceSerialization::test_deserialize_maps_primary_project PASSED [ 68%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_valid_transition FAILED [ 69%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_invalid_transition FAILED [ 69%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_not_found FAILED  [ 70%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_new_to_ready PASSED [ 70%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_ready_to_in_progress PASSED [ 71%]
tests/unit/services/test_task_service.py::TestTaskServiceStatusValidation::test_is_valid_transition_done_to_any_is_invalid PASSED [ 71%]
tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_sprint FAILED                [ 72%]
tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_project FAILED               [ 72%]
tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_success FAILED         [ 73%]
tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_fails_fast FAILED      [ 73%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status FAILED                    [ 74%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status_and_priority FAILED       [ 74%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_high_priority_tasks FAILED             [ 75%]
tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_blocked_tasks FAILED                   [ 75%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_new_to_ready FAILED [ 75%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_blocked FAILED [ 76%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_done FAILED [ 76%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_new FAILED [ 77%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_in_progress FAILED [ 77%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_dropped_to_ready FAILED [ 78%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_new_to_done FAILED [ 78%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_ready_to_blocked FAILED [ 79%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_partial_failure_fails_fast FAILED [ 79%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_empty_list PASSED [ 80%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_sprint FAILED [ 80%]
tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_project FAILED [ 81%]
tests/unit/test_config.py::TestDatabaseConfig::test_valid_database_config PASSED                                 [ 81%]
tests/unit/test_config.py::TestDatabaseConfig::test_connection_string_generation PASSED                          [ 82%]
tests/unit/test_config.py::TestDatabaseConfig::test_async_connection_string_generation PASSED                    [ 82%]
tests/unit/test_config.py::TestDatabaseConfig::test_invalid_port_too_low PASSED                                  [ 83%]
tests/unit/test_config.py::TestDatabaseConfig::test_invalid_port_too_high PASSED                                 [ 83%]
tests/unit/test_config.py::TestDatabaseConfig::test_empty_user_rejected PASSED                                   [ 84%]
tests/unit/test_config.py::TestDatabaseConfig::test_default_values PASSED                                        [ 84%]
tests/unit/test_config.py::TestRedisConfig::test_valid_redis_config PASSED                                       [ 85%]
tests/unit/test_config.py::TestRedisConfig::test_default_values PASSED                                           [ 85%]
tests/unit/test_config.py::TestRedisConfig::test_invalid_url_pattern PASSED                                      [ 86%]
tests/unit/test_config.py::TestRedisConfig::test_timeout_validation PASSED                                       [ 86%]
tests/unit/test_config.py::TestRedisConfig::test_db_number_validation PASSED                                     [ 87%]
tests/unit/test_config.py::TestSettings::test_valid_settings_development FAILED                                  [ 87%]
tests/unit/test_config.py::TestSettings::test_valid_settings_production FAILED                                   [ 87%]
tests/unit/test_config.py::TestSettings::test_production_rejects_insecure_secret_key PASSED                      [ 88%]
tests/unit/test_config.py::TestSettings::test_production_rejects_insecure_jwt_secret PASSED                      [ 88%]
tests/unit/test_config.py::TestSettings::test_development_allows_insecure_secrets FAILED                         [ 89%]
tests/unit/test_config.py::TestSettings::test_secret_key_min_length_32 PASSED                                    [ 89%]
tests/unit/test_config.py::TestSettings::test_optional_redis_config FAILED                                       [ 90%]
tests/unit/test_config.py::TestSettings::test_with_redis_config FAILED                                           [ 90%]
tests/unit/test_config.py::TestSettings::test_invalid_environment PASSED                                         [ 91%]
tests/unit/test_config.py::TestSettings::test_extra_fields_rejected PASSED                                       [ 91%]
tests/unit/test_config.py::TestSettings::test_environment_helpers FAILED                                         [ 92%]
tests/unit/test_config.py::TestGetSettings::test_settings_cached FAILED                                          [ 92%]
tests/unit/test_config.py::TestGetSettings::test_cache_clear FAILED                                              [ 93%]
tests/unit/test_fixtures.py::TestDatabaseConfigFixture::test_fixture_provides_isolated_config PASSED             [ 93%]
tests/unit/test_fixtures.py::TestDatabaseConfigFixture::test_fixture_connection_string PASSED                    [ 94%]
tests/unit/test_fixtures.py::TestRedisConfigFixture::test_fixture_provides_isolated_config PASSED                [ 94%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_provides_complete_settings ERROR                  [ 95%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_database ERROR                           [ 95%]
tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_redis ERROR                              [ 96%]
tests/unit/test_fixtures.py::TestMinimalSettingsFixture::test_fixture_provides_minimal_config ERROR              [ 96%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_simulates_production ERROR                  [ 97%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_database ERROR               [ 97%]
tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_redis ERROR                  [ 98%]
tests/unit/test_fixtures.py::TestCacheClearFixture::test_cache_cleared_between_tests_1 PASSED                    [ 98%]
tests/unit/test_fixtures.py::TestCacheClearFixture::test_cache_cleared_between_tests_2 PASSED                    [ 99%]
tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_environment_set_to_testing PASSED                    [ 99%]
tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_settings_default_to_testing ERROR                    [100%]

======================================================= ERRORS ========================================================
___________ ERROR at setup of TestProjectServiceBoundaryConditions.test_create_project_with_minimum_fields ____________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________ ERROR at setup of TestProjectServiceBoundaryConditions.test_create_project_with_all_fields ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________ ERROR at setup of TestProjectServiceBoundaryConditions.test_update_project_partial_single_field ___________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________ ERROR at setup of TestProjectServiceBoundaryConditions.test_update_project_empty_mission _______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__________________ ERROR at setup of TestProjectServiceStatusTransitions.test_change_status_success ___________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________ ERROR at setup of TestProjectServiceStatusTransitions.test_change_status_project_not_found ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestProjectServiceSprintManagement.test_add_sprint_to_project ___________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________ ERROR at setup of TestProjectServiceSprintManagement.test_add_duplicate_sprint_idempotent ______________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________ ERROR at setup of TestProjectServiceSprintManagement.test_remove_sprint_from_project _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________ ERROR at setup of TestProjectServiceMetrics.test_get_metrics_no_tasks ________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestProjectServiceMetrics.test_get_metrics_project_not_found ____________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________ ERROR at setup of TestProjectServiceSearchAndFiltering.test_get_by_status_no_results _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________ ERROR at setup of TestProjectServiceSearchAndFiltering.test_get_by_owner_no_results _________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestProjectService.test_get_metrics_success ____________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestProjectService.test_add_sprint _________________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_remove_sprint _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_change_status _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_get_by_status _______________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestProjectService.test_get_by_owner ________________________________

    @pytest.fixture
    def sample_project() -> Project:
        """Create sample project for testing."""
>       return Project(
            id="P-TEST-001",
            name="Test Project",
            mission="Test project mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            target_end_date=None,
            owner="project.owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=["S-TEST-001"],
            related_projects=[],
            shared_components=[],
            security_posture=None,
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            tnve_mandate=False,
            evidence_root=None,
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ ERROR at setup of TestSprintService.test_calculate_velocity _____________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestSprintService.test_get_burndown ________________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_change_status ________________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestSprintService.test_get_current_sprints _____________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_get_by_project _______________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________ ERROR at setup of TestSprintService.test_update_metrics _______________________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_________________________ ERROR at setup of TestActionListService.test_reorder_items_success __________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________ ERROR at setup of TestActionListService.test_reorder_items_invalid_length ______________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ ERROR at setup of TestActionListService.test_mark_complete ______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
________________________________ ERROR at setup of TestActionListService.test_add_item ________________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________ ERROR at setup of TestActionListService.test_remove_item _______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________ ERROR at setup of TestActionListService.test_get_orphaned ______________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________ ERROR at setup of TestActionListService.test_get_soft_deleted ____________________________

    @pytest.fixture
    def sample_action_list() -> ActionList:
        """Create sample action list for testing."""
>       return ActionList(
            id="AL-TEST-001",
            title="Test Action List",
            description="Test description",
            status="active",
            owner="list.owner",
            tags=["test"],
            project_id="P-TEST-001",
            sprint_id="S-TEST-001",
            items=[
                {"task": "Item 1", "done": False},
                {"task": "Item 2", "done": True},
            ],
            geometry_shape="Circle",
            priority="high",
            due_date=None,
            evidence_refs=[],
            extra_metadata={},
            notes=None,
            parent_deleted_at=None,
            parent_deletion_note={},
            completed_at=None,
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-001', name=None, status=None)>
kwargs = {'completed_at': None, 'created_at': datetime.datetime(2025, 1, 1, 12, 0), 'description': 'Test description', 'due_date': None, ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________ ERROR at setup of TestSprintServiceMetrics.test_calculate_velocity_mixed_tasks ____________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________ ERROR at setup of TestSprintServiceMetrics.test_get_burndown_calculations ______________________

    @pytest.fixture
    def sample_sprint() -> Sprint:
        """Create sample sprint for testing."""
>       return Sprint(
            id="S-TEST-001",
            name="Sprint 1",
            goal="Sprint goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="scrum.master",
            primary_project="P-TEST-001",
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            velocity_target_points=20.0,
            committed_points=18.0,
            actual_points=16.0,
            carried_over_points=2.0,
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            timezone="UTC",
            observability={},
            created_at=datetime(2025, 1, 1, 12, 0, 0),
            updated_at=datetime(2025, 1, 1, 12, 0, 0),
        )

tests\unit\services\conftest.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-001', name='Sprint 1', status='SprintStatus.ACTIVE')>
kwargs = {'actual_points': 16.0, 'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'carried_over_points': 2.0, 'ceremonies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________ ERROR at setup of TestSettingsFixture.test_fixture_provides_complete_settings ____________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb6283f20>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________ ERROR at setup of TestSettingsFixture.test_fixture_includes_database _________________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb6280ff0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________________ ERROR at setup of TestSettingsFixture.test_fixture_includes_redis __________________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb6281180>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________ ERROR at setup of TestMinimalSettingsFixture.test_fixture_provides_minimal_config __________________

    @pytest.fixture
    def minimal_test_settings() -> Settings:
        """
        Provide minimal test settings without Redis.
    
        Useful for tests that don't require caching.
    
        Returns:
            Settings with only required configuration
    
        Example:
            >>> def test_no_cache(minimal_test_settings):
            ...     assert minimal_test_settings.redis is None
        """
>       return Settings(
            environment="testing",
            database=DatabaseConfig(
                host="localhost",
                port=5433,
                user="taskman_test",
                password=SecretStr("test_password"),
                database="taskman_test",
            ),
            redis=None,  # No Redis for minimal tests
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61faf30>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ord@localhost:5433/taskman_test'), 'environment': 'testing', 'jwt_secret': SecretStr('**********'), 'redis': None, ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestProductionLikeFixture.test_fixture_simulates_production ____________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61fa6c0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________ ERROR at setup of TestProductionLikeFixture.test_fixture_has_production_database ___________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61f0370>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
____________________ ERROR at setup of TestProductionLikeFixture.test_fixture_has_production_redis ____________________

    @pytest.fixture
    def production_like_settings() -> Settings:
        """
        Provide production-like settings for integration tests.
    
        Returns:
            Settings configured with production environment constraints
    
        Example:
            >>> def test_prod_validation(production_like_settings):
            ...     assert production_like_settings.is_production is True
            ...     assert production_like_settings.debug is False
        """
>       return Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("production_secure_password_123"),
                database="taskman_production",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                timeout=10,
                db=0,
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\conftest.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb6283c50>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...wt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=10, db=0), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________ ERROR at setup of TestEnvironmentIsolation.test_settings_default_to_testing _____________________

test_database_config = DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), database='taskman_t...kman_test', async_connection_string='postgresql+asyncpg://taskman_test:test_password_safe@localhost:5433/taskman_test')
test_redis_config = RedisConfig(url='redis://localhost:6379', timeout=5, db=15)

    @pytest.fixture
    def test_settings(
        test_database_config: DatabaseConfig,
        test_redis_config: RedisConfig,
    ) -> Settings:
        """
        Provide complete test settings configuration.
    
        Args:
            test_database_config: Isolated database configuration
            test_redis_config: Isolated Redis configuration
    
        Returns:
            Settings configured for testing environment
    
        Example:
            >>> def test_app(test_settings):
            ...     assert test_settings.environment == "testing"
            ...     assert test_settings.debug is True
        """
>       return Settings(
            environment="testing",
            database=test_database_config,
            redis=test_redis_config,
            secret_key=SecretStr("test-secret-key-min-32-characters"),
            jwt_secret=SecretStr("test-jwt-secret-min-32-characters"),
        )

tests\conftest.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb6282e90>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5433, user='taskman_test', password=SecretStr('**********'), databa...ing', 'jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://localhost:6379', timeout=5, db=15), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
====================================================== FAILURES =======================================================
_______________________________________ TestBaseRepository.test_create_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB4331D50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB59BFC90>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_create_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity creation."""
        # Arrange
        await async_session.commit()  # Ensure clean state
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:29: TypeError
_______________________________________ TestBaseRepository.test_create_conflict _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB4332690>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5781810>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_create_conflict(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test create with duplicate ID returns ConflictError."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:54: TypeError
_____________________________________ TestBaseRepository.test_find_by_id_success ______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB4332F90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5B93B10>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_id_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful find by ID."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:110: TypeError
____________________________________ TestBaseRepository.test_find_by_id_not_found _____________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB4333910>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5B5E9D0>

    async def test_find_by_id_not_found(self, async_session: AsyncSession):
        """Test find by ID returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:128: TypeError
______________________________________ TestBaseRepository.test_find_all_success _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB4333990>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5A6AF10>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_all_success(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test find all with pagination."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:149: TypeError
_____________________________ TestBaseRepository.test_find_all_validation_limit_exceeded ______________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB4305850>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5ADD8D0>

    async def test_find_all_validation_limit_exceeded(self, async_session: AsyncSession):
        """Test find all with limit > 1000 returns ValidationError."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:199: TypeError
_______________________________________ TestBaseRepository.test_update_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433C1D0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB58D6B50>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_update_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity update."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:218: TypeError
______________________________________ TestBaseRepository.test_update_not_found _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433C690>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5B93B90>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_update_not_found(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test update returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:243: TypeError
_______________________________________ TestBaseRepository.test_delete_success ________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433CB10>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5B914D0>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_delete_success(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test successful entity deletion."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:295: TypeError
______________________________________ TestBaseRepository.test_delete_not_found _______________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433CF90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5A51050>

    async def test_delete_not_found(self, async_session: AsyncSession):
        """Test delete returns NotFoundError when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:315: TypeError
_________________________________________ TestBaseRepository.test_exists_true _________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433D790>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5C93DD0>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_exists_true(
        self,
        async_session: AsyncSession,
        sample_task: Task,
        sample_project,
        sample_sprint,
    ):
        """Test exists returns True when entity exists."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:334: TypeError
________________________________________ TestBaseRepository.test_exists_false _________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433DFD0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5870310>

    async def test_exists_false(self, async_session: AsyncSession):
        """Test exists returns False when entity doesn't exist."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:350: TypeError
____________________________________________ TestBaseRepository.test_count ____________________________________________

self = <test_base_repository.TestBaseRepository object at 0x000001AEB433E810>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB585B810>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_count(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test count returns correct number of entities."""
        # Arrange
>       repo = BaseRepository(Task, async_session)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class BaseRepository with abstract method exists

tests\unit\db\repositories\test_base_repository.py:367: TypeError
______________________________________ TestProjectRepository.test_find_by_status ______________________________________

self = <test_repositories.TestProjectRepository object at 0x000001AEB4348190>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5877790>

    async def test_find_by_status(self, async_session: AsyncSession):
        """Test finding projects by status."""
        from taskman_api.models.project import Project
    
        repo = ProjectRepository(async_session)
    
        # Create projects with different statuses
        for i, status in enumerate([ProjectStatus.ACTIVE, ProjectStatus.PAUSED, ProjectStatus.ACTIVE]):
>           project = Project(
                id=f"P-TEST-{i:03d}",
                name=f"Project {i}",
                mission=f"Mission {i}",
                status=status,
                start_date=date(2025, 1, 1),
                owner="owner",
                sponsors=[],
                stakeholders=[],
                repositories=[],
                comms_channels=[],
                okrs=[],
                kpis=[],
                roadmap=[],
                risks=[],
                assumptions=[],
                constraints=[],
                dependencies_external=[],
                sprints=[],
                related_projects=[],
                shared_components=[],
                compliance_requirements=[],
                governance={},
                success_metrics=[],
                mpv_policy={},
                observability={},
            )

tests\unit\db\repositories\test_repositories.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-000', name='Project 0', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___________________________________ TestProjectRepository.test_find_active_projects ___________________________________

self = <test_repositories.TestProjectRepository object at 0x000001AEB434AB90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5CB9D90>

    async def test_find_active_projects(self, async_session: AsyncSession):
        """Test finding all active projects."""
        from taskman_api.models.project import Project
    
        repo = ProjectRepository(async_session)
    
>       project = Project(
            id="P-ACTIVE-001",
            name="Active Project",
            mission="Mission",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            owner="owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=[],
            related_projects=[],
            shared_components=[],
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            observability={},
        )

tests\unit\db\repositories\test_repositories.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-ACTIVE-001', name='Active Project', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______________________________________ TestSprintRepository.test_find_by_status _______________________________________

self = <test_repositories.TestSprintRepository object at 0x000001AEB434B350>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB58343D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>

    async def test_find_by_status(self, async_session: AsyncSession, sample_project):
        """Test finding sprints by status."""
        from taskman_api.core.enums import SprintCadence
        from taskman_api.models.sprint import Sprint
    
        async_session.add(sample_project)
        await async_session.commit()
    
        repo = SprintRepository(async_session)
    
        # Create sprints with different statuses
        for i, status in enumerate([SprintStatus.ACTIVE, SprintStatus.PLANNED, SprintStatus.ACTIVE]):
>           sprint = Sprint(
                id=f"S-TEST-{i:03d}",
                name=f"Sprint {i}",
                goal=f"Goal {i}",
                cadence=SprintCadence.BIWEEKLY,
                start_date=date(2025, 1, 1),
                end_date=date(2025, 1, 14),
                status=status,
                owner="owner",
                primary_project=sample_project.id,
                tasks=[],
                imported_tasks=[],
                related_projects=[],
                definition_of_done=[],
                dependencies={},
                scope_changes=[],
                risks=[],
                ceremonies={},
                metrics={},
                observability={},
            )

tests\unit\db\repositories\test_repositories.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-TEST-000', name='Sprint 0', status='SprintStatus.ACTIVE')>
kwargs = {'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'ceremonies': {}, 'definition_of_done': [], 'dependencies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____________________________________ TestSprintRepository.test_find_active_sprints ____________________________________

self = <test_repositories.TestSprintRepository object at 0x000001AEB434BA50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5701B50>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>

    async def test_find_active_sprints(self, async_session: AsyncSession, sample_project):
        """Test finding all active sprints."""
        from taskman_api.core.enums import SprintCadence
        from taskman_api.models.sprint import Sprint
    
        async_session.add(sample_project)
        await async_session.commit()
    
        repo = SprintRepository(async_session)
    
>       sprint = Sprint(
            id="S-ACTIVE-001",
            name="Active Sprint",
            goal="Goal",
            cadence=SprintCadence.BIWEEKLY,
            start_date=date(2025, 1, 1),
            end_date=date(2025, 1, 14),
            status=SprintStatus.ACTIVE,
            owner="owner",
            primary_project=sample_project.id,
            tasks=[],
            imported_tasks=[],
            related_projects=[],
            definition_of_done=[],
            dependencies={},
            scope_changes=[],
            risks=[],
            ceremonies={},
            metrics={},
            observability={},
        )

tests\unit\db\repositories\test_repositories.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Sprint(id='S-ACTIVE-001', name='Active Sprint', status='SprintStatus.ACTIVE')>
kwargs = {'cadence': <SprintCadence.BIWEEKLY: 'biweekly'>, 'ceremonies': {}, 'definition_of_done': [], 'dependencies': {}, ...}
cls_ = <class 'taskman_api.models.sprint.Sprint'>, k = 'tasks'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'tasks' is an invalid keyword argument for Sprint

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________________ TestActionListRepository.test_find_by_owner _____________________________________

self = <test_repositories.TestActionListRepository object at 0x000001AEB4350710>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5B4C410>

    async def test_find_by_owner(self, async_session: AsyncSession):
        """Test finding action lists by owner."""
        from taskman_api.models.action_list import ActionList
    
        repo = ActionListRepository(async_session)
    
        # Create action lists with different owners
        for i, owner in enumerate(["alice", "bob", "alice"]):
>           action_list = ActionList(
                id=f"AL-TEST-{i:03d}",
                title=f"List {i}",
                status="active",
                owner=owner,
                items=[],
                tags=[],
                evidence_refs=[],
                extra_metadata={},
                parent_deletion_note={},
            )

tests\unit\db\repositories\test_repositories.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-TEST-000', name=None, status=None)>
kwargs = {'evidence_refs': [], 'extra_metadata': {}, 'id': 'AL-TEST-000', 'items': [], ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________________ TestActionListRepository.test_find_orphaned _____________________________________

self = <test_repositories.TestActionListRepository object at 0x000001AEB4350F50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB57FB490>

    async def test_find_orphaned(self, async_session: AsyncSession):
        """Test finding orphaned action lists."""
        from taskman_api.models.action_list import ActionList
    
        repo = ActionListRepository(async_session)
    
        # Create orphaned action list
>       orphaned = ActionList(
            id="AL-ORPHAN-001",
            title="Orphaned List",
            status="active",
            items=[],
            tags=[],
            evidence_refs=[],
            extra_metadata={},
            parent_deletion_note={},
        )

tests\unit\db\repositories\test_repositories.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ActionList(id='AL-ORPHAN-001', name=None, status=None)>
kwargs = {'evidence_refs': [], 'extra_metadata': {}, 'id': 'AL-ORPHAN-001', 'items': [], ...}
cls_ = <class 'taskman_api.models.action_list.ActionList'>, k = 'title'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'title' is an invalid keyword argument for ActionList

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______________________________________ TestTaskRepository.test_find_by_status ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4360A50>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB59419D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_status(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by status."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.NEW, TaskStatus.IN_PROGRESS, TaskStatus.NEW]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_status(TaskStatus.NEW)
                       ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_status'

tests\unit\db\repositories\test_task_repository.py:65: AttributeError
______________________________________ TestTaskRepository.test_find_by_priority _______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4360F10>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5CB9090>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_priority(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by priority."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different priorities
        for i, priority in enumerate([Priority.P0, Priority.P1, Priority.P0]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_priority(Priority.P0)
                       ^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_priority'

tests\unit\db\repositories\test_task_repository.py:119: AttributeError
________________________________________ TestTaskRepository.test_find_by_owner ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB43613D0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB19720D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_owner(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by owner."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different owners
        for i, owner in enumerate(["alice", "bob", "alice"]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner=owner,
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_owner("alice")
                       ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_owner'

tests\unit\db\repositories\test_task_repository.py:173: AttributeError
_______________________________________ TestTaskRepository.test_find_by_project _______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4361B90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB42F77D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_project(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by project."""
        # Arrange
        repo = TaskRepository(async_session)
    
        # Create second project
        from datetime import date
    
        from taskman_api.core.enums import ProjectStatus
        from taskman_api.models.project import Project
    
>       project2 = Project(
            id="P-TEST-002",
            name="Project 2",
            mission="Mission 2",
            status=ProjectStatus.ACTIVE,
            start_date=date(2025, 1, 1),
            owner="owner",
            sponsors=[],
            stakeholders=[],
            repositories=[],
            comms_channels=[],
            okrs=[],
            kpis=[],
            roadmap=[],
            risks=[],
            assumptions=[],
            constraints=[],
            dependencies_external=[],
            sprints=[],
            related_projects=[],
            shared_components=[],
            compliance_requirements=[],
            governance={},
            success_metrics=[],
            mpv_policy={},
            observability={},
        )

tests\unit\db\repositories\test_task_repository.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state.py:596: in _initialize_instance
    with util.safe_reraise():
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\state.py:594: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Project(id='P-TEST-002', name='Project 2', status='ProjectStatus.ACTIVE')>
kwargs = {'assumptions': [], 'comms_channels': [], 'compliance_requirements': [], 'constraints': [], ...}
cls_ = <class 'taskman_api.models.project.Project'>, k = 'sprints'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'sprints' is an invalid keyword argument for Project

.venv\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____________________________ TestTaskRepository.test_find_by_project_with_status_filter ______________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB43623D0>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5ADC9D0>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_project_with_status_filter(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by project with status filter."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.NEW, TaskStatus.IN_PROGRESS, TaskStatus.NEW]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_project(sample_project.id, status=TaskStatus.NEW)
                       ^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_project'

tests\unit\db\repositories\test_task_repository.py:317: AttributeError
_______________________________________ TestTaskRepository.test_find_by_sprint ________________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4362C10>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB56FB610>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_sprint(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by sprint."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks
        for i in range(3):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_sprint(sample_sprint.id)
                       ^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_sprint'

tests\unit\db\repositories\test_task_repository.py:371: AttributeError
_________________________________ TestTaskRepository.test_find_by_status_and_priority _________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4363450>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5836310>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_by_status_and_priority(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding tasks by status and priority (composite index)."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with various combinations
        combos = [
            (TaskStatus.NEW, Priority.P0),
            (TaskStatus.NEW, Priority.P1),
            (TaskStatus.IN_PROGRESS, Priority.P0),
            (TaskStatus.NEW, Priority.P0),
        ]
    
        for i, (status, priority) in enumerate(combos):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_by_status_and_priority(TaskStatus.NEW, Priority.P0)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_by_status_and_priority'

tests\unit\db\repositories\test_task_repository.py:431: AttributeError
_____________________________________ TestTaskRepository.test_find_blocked_tasks ______________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4363C90>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB4315090>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_blocked_tasks(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding all blocked tasks."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different statuses
        for i, status in enumerate([TaskStatus.BLOCKED, TaskStatus.NEW, TaskStatus.BLOCKED]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=status,
                owner="owner",
                assignees=[],
                priority=Priority.P2,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_blocked_tasks()
                       ^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_blocked_tasks'

tests\unit\db\repositories\test_task_repository.py:485: AttributeError
__________________________________ TestTaskRepository.test_find_high_priority_tasks ___________________________________

self = <test_task_repository.TestTaskRepository object at 0x000001AEB4374510>
async_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001AEB5F25C90>
sample_project = <Project(id='P-TEST-001', name='Test Project', status='ProjectStatus.ACTIVE')>
sample_sprint = <Sprint(id='S-TEST-001', name='Test Sprint 1', status='SprintStatus.ACTIVE')>

    async def test_find_high_priority_tasks(
        self,
        async_session: AsyncSession,
        sample_project,
        sample_sprint,
    ):
        """Test finding P0 and P1 (critical/high priority) tasks."""
        # Arrange
        repo = TaskRepository(async_session)
        async_session.add(sample_project)
        async_session.add(sample_sprint)
    
        # Create tasks with different priorities
        for i, priority in enumerate([Priority.P0, Priority.P1, Priority.P2, Priority.P0]):
            task = Task(
                id=f"T-TEST-{i:03d}",
                title=f"Task {i}",
                summary=f"Summary {i}",
                description=f"Description {i}",
                status=TaskStatus.NEW,
                owner="owner",
                assignees=[],
                priority=priority,
                primary_project=sample_project.id,
                primary_sprint=sample_sprint.id,
                related_projects=[],
                related_sprints=[],
                parents=[],
                depends_on=[],
                blocks=[],
                blockers=[],
                acceptance_criteria=[],
                definition_of_done=[],
                quality_gates={},
                verification={},
                actions_taken=[],
                labels=[],
                related_links=[],
                risks=[],
                observability={},
            )
            async_session.add(task)
    
        await async_session.commit()
    
        # Act
>       result = await repo.find_high_priority_tasks()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'TaskRepository' object has no attribute 'find_high_priority_tasks'

tests\unit\db\repositories\test_task_repository.py:539: AttributeError
______________________________________________ test_init_creates_engines ______________________________________________

mock_engines = (<MagicMock name='create_async_engine' id='1849888343376'>, <AsyncMock id='1849888600976'>, <AsyncMock id='1849889922448'>)

    @pytest.mark.asyncio
    async def test_init_creates_engines(mock_engines):
        mock_create, _, _ = mock_engines
        manager = ConnectionManager(MOCK_PG_URL, MOCK_SQLITE_PATH)
    
>       assert mock_create.call_count == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <MagicMock name='create_async_engine' id='1849888343376'>.call_count

tests\unit\db\test_connection_manager.py:31: AssertionError
__________________________________________ test_get_session_primary_success ___________________________________________

manager = <taskman_api.db.connection_manager.ConnectionManager object at 0x000001AEB5FA5850>

    @pytest.mark.asyncio
    async def test_get_session_primary_success(manager):
        # Setup mock session
        mock_session = AsyncMock(spec=AsyncSession)
        manager.PrimarySession = MagicMock(return_value=mock_session)
    
        # Run
        async for session in manager.get_session():
>           assert session is mock_session
E           AssertionError: assert <AsyncMock name='mock.__aenter__()' id='1849889862352'> is <AsyncMock spec='AsyncSession' id='1849889859472'>

tests\unit\db\test_connection_manager.py:45: AssertionError
________________________________ TestProjectSchemas.test_project_create_request_valid _________________________________

self = <test_schemas.TestProjectSchemas object at 0x000001AEB43814D0>

    def test_project_create_request_valid(self):
        """Test creating a valid project create request."""
        data = {
            "id": "P-TEST-001",
            "name": "Test Project",
            "mission": "Test mission",
            "start_date": date(2025, 1, 1),
            "owner": "test.owner",
        }
    
        request = ProjectCreateRequest(**data)
        assert request.id == "P-TEST-001"
>       assert request.status == ProjectStatus.DISCOVERY  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <ProjectStatu...G: 'planning'> == <ProjectStatu...: 'discovery'>
E         
E         - discovery
E         + planning

tests\unit\schemas\test_schemas.py:36: AssertionError
_________________________________ TestSprintSchemas.test_sprint_create_request_valid __________________________________

self = <test_schemas.TestSprintSchemas object at 0x000001AEB4383110>

    def test_sprint_create_request_valid(self):
        """Test creating a valid sprint create request."""
        data = {
            "id": "S-2025-01",
            "name": "Sprint 1",
            "goal": "Sprint goal",
            "cadence": SprintCadence.BIWEEKLY,
            "start_date": date(2025, 1, 1),
            "end_date": date(2025, 1, 14),
            "owner": "scrum.master",
            "primary_project": "P-TEST",
        }
    
        request = SprintCreateRequest(**data)
        assert request.id == "S-2025-01"
>       assert request.status == SprintStatus.PLANNED  # Default
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert <SprintStatus...G: 'planning'> == <SprintStatus...ED: 'planned'>
E         
E         - planned
E         + planning

tests\unit\schemas\test_schemas.py:134: AssertionError
_________________________________ TestSprintSchemas.test_sprint_response_with_metrics _________________________________

self = <test_schemas.TestSprintSchemas object at 0x000001AEB4382ED0>

    def test_sprint_response_with_metrics(self):
        """Test sprint response with metrics."""
        data = {
            "id": "S-TEST",
            "name": "Sprint",
            "goal": "Goal",
            "cadence": SprintCadence.BIWEEKLY,
            "start_date": date(2025, 1, 1),
            "end_date": date(2025, 1, 14),
            "status": SprintStatus.ACTIVE,
            "owner": "owner",
            "primary_project": "P-TEST",
            "tasks": [],
            "imported_tasks": [],
            "related_projects": [],
            "velocity_target_points": 20.0,
            "committed_points": 18.0,
            "actual_points": 16.0,
            "carried_over_points": 2.0,
            "definition_of_done": [],
            "dependencies": {},
            "scope_changes": [],
            "risks": [],
            "ceremonies": {},
            "metrics": {"throughput": 16, "predictability_pct": 88.9},
            "timezone": "America/New_York",
            "observability": {},
            "created_at": datetime(2025, 1, 1),
            "updated_at": datetime(2025, 1, 1),
        }
    
>       response = SprintResponse(**data)
                   ^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for SprintResponse
E       dependencies
E         Input should be a valid list [type=list_type, input_value={}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.12/v/list_type

tests\unit\schemas\test_schemas.py:236: ValidationError
______________________________ TestActionListSchemas.test_action_list_soft_delete_fields ______________________________

self = <test_schemas.TestActionListSchemas object at 0x000001AEB438CAD0>

    def test_action_list_soft_delete_fields(self):
        """Test action list soft delete fields."""
        data = {
            "id": "AL-TEST",
            "title": "Action List",
            "status": "deleted",
            "parent_deleted_at": datetime(2025, 1, 1, 12, 0, 0),
            "parent_deletion_note": {"reason": "Project closed"},
            "items": [],
        }
    
>       request = ActionListCreateRequest(**data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for ActionListCreate
E       status
E         Input should be 'active' or 'archived' [type=enum, input_value='deleted', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/enum

tests\unit\schemas\test_schemas.py:284: ValidationError
_______________________________ TestBaseSchemaConfiguration.test_strict_type_validation _______________________________

self = <test_schemas.TestBaseSchemaConfiguration object at 0x000001AEB438D950>

    def test_strict_type_validation(self):
        """Test that type coercion is enabled (strict=False)."""
>       from taskman_api.schemas.base import BaseSchema
E       ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)

tests\unit\schemas\test_schemas.py:336: ImportError
______________________________ TestBaseSchemaConfiguration.test_from_attributes_orm_mode ______________________________

self = <test_schemas.TestBaseSchemaConfiguration object at 0x000001AEB438DF90>

    def test_from_attributes_orm_mode(self):
        """Test ORM mode (from_attributes) is enabled."""
>       from taskman_api.schemas.base import BaseSchema
E       ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)

tests\unit\schemas\test_schemas.py:348: ImportError
____________________________ TestTaskCreateRequest.test_task_id_pattern_validation_failure ____________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001AEB4394750>

    def test_task_id_pattern_validation_failure(self):
        """Test task ID pattern validation with invalid patterns."""
        # Test pattern validation errors
        pattern_invalid_ids = [
            "TASK-001",  # Wrong prefix
            "T001",  # Missing hyphen
            "T-",  # No ID part
            "T-@invalid",  # Invalid character
        ]
    
        for task_id in pattern_invalid_ids:
            data = {
                "id": task_id,
                "title": "Test",
                "summary": "Summary",
                "description": "Description",
                "owner": "owner",
                "priority": Priority.P2,
                "primary_project": "P-TEST",
                "primary_sprint": "S-TEST",
            }
    
            with pytest.raises(ValidationError) as exc_info:
                TaskCreateRequest(**data)
    
            errors = exc_info.value.errors()
            assert any("pattern" in str(err).lower() for err in errors)
    
        # Test min_length validation (empty string)
        data = {
            "id": "",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P2,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
        }
        with pytest.raises(ValidationError) as exc_info:
            TaskCreateRequest(**data)
        errors = exc_info.value.errors()
>       assert any("at least 1 character" in str(err).lower() for err in errors)
E       assert False
E        +  where False = any(<generator object TestTaskCreateRequest.test_task_id_pattern_validation_failure.<locals>.<genexpr> at 0x000001AEB5FC3E60>)

tests\unit\schemas\test_task_schemas.py:104: AssertionError
________________________________ TestTaskCreateRequest.test_required_fields_validation ________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001AEB4394DD0>

    def test_required_fields_validation(self):
        """Test that required fields are validated."""
        # Missing required fields
        data = {
            "id": "T-TEST-001",
        }
    
        with pytest.raises(ValidationError) as exc_info:
            TaskCreateRequest(**data)
    
        errors = exc_info.value.errors()
        required_fields = {"title", "summary", "description", "owner", "priority", "primary_project", "primary_sprint"}
        error_fields = {err["loc"][0] for err in errors}
    
>       assert required_fields.issubset(error_fields)
E       AssertionError: assert False
E        +  where False = <built-in method issubset of set object at 0x000001AEB5FC2340>({'description', 'owner', 'primary_project', 'primary_sprint', 'summary', 'title'})
E        +    where <built-in method issubset of set object at 0x000001AEB5FC2340> = {'description', 'owner', 'primary_project', 'primary_sprint', 'priority', 'summary', ...}.issubset

tests\unit\schemas\test_task_schemas.py:120: AssertionError
________________________________ TestTaskCreateRequest.test_business_value_score_range ________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001AEB4396090>

    def test_business_value_score_range(self):
        """Test business_value_score must be 0-10."""
        # Test below range
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P2,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "business_value_score": -1,
        }
    
        with pytest.raises(ValidationError):
            TaskCreateRequest(**data)
    
        # Test above range
        data["business_value_score"] = 11
    
>       with pytest.raises(ValidationError):
E       Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>

tests\unit\schemas\test_task_schemas.py:182: Failed
__________________________________ TestTaskCreateRequest.test_enum_field_validation ___________________________________

self = <test_task_schemas.TestTaskCreateRequest object at 0x000001AEB43966D0>

    def test_enum_field_validation(self):
        """Test enum field validation."""
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "owner": "owner",
            "priority": Priority.P1,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "status": TaskStatus.IN_PROGRESS,
            "severity": Severity.SEV2,
            "shape": GeometryShape.CIRCLE,
        }
    
>       request = TaskCreateRequest(**data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskCreate
E       severity
E         Input should be 'critical', 'high', 'medium' or 'low' [type=enum, input_value=<Severity.SEV2: 'sev2'>, input_type=Severity]
E           For further information visit https://errors.pydantic.dev/2.12/v/enum

tests\unit\schemas\test_task_schemas.py:206: ValidationError
____________________________________ TestTaskResponse.test_response_from_orm_model ____________________________________

self = <test_task_schemas.TestTaskResponse object at 0x000001AEB4397810>

    def test_response_from_orm_model(self):
        """Test creating response from ORM model."""
        from taskman_api.models.task import Task
    
        # Create mock ORM task
        task = Task(
            id="T-TEST-001",
            title="Test Task",
            summary="Summary",
            description="Description",
            status=TaskStatus.NEW,
            owner="owner",
            assignees=[],
            priority=Priority.P1,
            primary_project="P-TEST",
            primary_sprint="S-TEST",
            related_projects=[],
            related_sprints=[],
            parents=[],
            depends_on=[],
            blocks=[],
            blockers=[],
            acceptance_criteria=[],
            definition_of_done=[],
            quality_gates={},
            verification={},
            actions_taken=[],
            labels=[],
            related_links=[],
            risks=[],
            observability={},
        )
    
        # Set timestamps manually (normally set by TimestampMixin)
        task.created_at = datetime(2025, 1, 1, 12, 0, 0)
        task.updated_at = datetime(2025, 1, 1, 12, 0, 0)
    
        # Create response from ORM model
>       response = TaskResponse.model_validate(task)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E       automation_candidate
E         Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/bool_type

tests\unit\schemas\test_task_schemas.py:313: ValidationError
____________________________________ TestTaskResponse.test_response_serialization _____________________________________

self = <test_task_schemas.TestTaskResponse object at 0x000001AEB4397B90>

    def test_response_serialization(self):
        """Test response can be serialized to dict/JSON."""
        data = {
            "id": "T-TEST-001",
            "title": "Test",
            "summary": "Summary",
            "description": "Description",
            "status": TaskStatus.NEW,
            "owner": "owner",
            "assignees": [],
            "priority": Priority.P1,
            "severity": None,
            "primary_project": "P-TEST",
            "primary_sprint": "S-TEST",
            "related_projects": [],
            "related_sprints": [],
            "estimate_points": None,
            "actual_time_hours": None,
            "due_at": None,
            "parents": [],
            "depends_on": [],
            "blocks": [],
            "blockers": [],
            "acceptance_criteria": [],
            "definition_of_done": [],
            "quality_gates": {},
            "verification": {},
            "actions_taken": [],
            "labels": [],
            "related_links": [],
            "shape": None,
            "stage": None,
            "work_type": None,
            "work_stream": None,
            "business_value_score": None,
            "cost_of_delay_score": None,
            "automation_candidate": None,
            "cycle_time_days": None,
            "risks": [],
            "observability": {},
            "created_at": datetime(2025, 1, 1, 12, 0, 0),
            "updated_at": datetime(2025, 1, 1, 12, 0, 0),
        }
    
>       response = TaskResponse(**data)
                   ^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E       automation_candidate
E         Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.12/v/bool_type

tests\unit\schemas\test_task_schemas.py:364: ValidationError
______________________________________ TestBaseServiceCreate.test_create_success ______________________________________

self = <test_base_service.TestBaseServiceCreate object at 0x000001AEB43AB390>
mock_task_repository = <Mock id='1849889048976'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_create_success(self, mock_task_repository, sample_task):
        """Test successful entity creation."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        request = TaskCreateRequest(
            id="T-TEST-001",
            title="Test Task",
            summary="Summary",
            description="Description",
            owner="test.owner",
            priority=Priority.P1,
            primary_project="P-TEST-001",
            primary_sprint="S-TEST-001",
        )
    
        # Act
        result = await service.create(request)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5ACFA90>, Ok)

tests\unit\services\test_base_service.py:41: AssertionError
__________________________________ TestBaseServiceCreate.test_create_conflict_error ___________________________________

self = <test_base_service.TestBaseServiceCreate object at 0x000001AEB43ABCD0>
mock_task_repository = <Mock id='1849889566800'>

    @pytest.mark.asyncio
    async def test_create_conflict_error(self, mock_task_repository):
        """Test creation with duplicate ID returns ConflictError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        request = TaskCreateRequest(
            id="T-DUPLICATE",
            title="Task",
            summary="Summary",
            description="Description",
            owner="owner",
            priority=Priority.P1,
            primary_project="P-001",
            primary_sprint="S-001",
        )
    
        # Mock repository to return ConflictError
        mock_task_repository.create = AsyncMock(
            return_value=Err(
                ConflictError(
                    message="Entity already exists",
                    entity_type="Task",
                    entity_id="T-DUPLICATE",
                )
            )
        )
    
        # Act
        result = await service.create(request)
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, ConflictError)
E       assert False
E        +  where False = isinstance(AppError("9 validation errors for TaskResponse\nid\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ntitle\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nsummary\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ndescription\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nstatus\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nowner\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\npriority\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_project\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_sprint\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing"), ConflictError)

tests\unit\services\test_base_service.py:80: AssertionError
_________________________________________ TestBaseServiceGet.test_get_success _________________________________________

self = <test_base_service.TestBaseServiceGet object at 0x000001AEB4396E90>
mock_task_repository = <Mock id='1849889339600'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_success(self, mock_task_repository, sample_task):
        """Test successful entity retrieval."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.get("T-TEST-001")
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5FAE4D0>, Ok)

tests\unit\services\test_base_service.py:97: AssertionError
________________________________________ TestBaseServiceGet.test_get_not_found ________________________________________

self = <test_base_service.TestBaseServiceGet object at 0x000001AEB43B8610>
mock_task_repository = <Mock id='1849887752464'>

    @pytest.mark.asyncio
    async def test_get_not_found(self, mock_task_repository):
        """Test get with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return NotFoundError
        mock_task_repository.find_by_id = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.get("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:126: AssertionError
______________________________________ TestBaseServiceUpdate.test_update_success ______________________________________

self = <test_base_service.TestBaseServiceUpdate object at 0x000001AEB43B8CD0>
mock_task_repository = <Mock id='1849887786896'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_update_success(self, mock_task_repository, sample_task):
        """Test successful entity update."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        update_request = TaskUpdateRequest(title="Updated Title")
    
        # Act
        result = await service.update("T-TEST-001", update_request)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5835650>, Ok)

tests\unit\services\test_base_service.py:144: AssertionError
_____________________________________ TestBaseServiceUpdate.test_update_not_found _____________________________________

self = <test_base_service.TestBaseServiceUpdate object at 0x000001AEB43B9450>
mock_task_repository = <Mock id='1849889111056'>

    @pytest.mark.asyncio
    async def test_update_not_found(self, mock_task_repository):
        """Test update with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
        update_request = TaskUpdateRequest(title="Updated")
    
        # Mock repository to return NotFoundError
        mock_task_repository.find_by_id = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.update("T-NONEXISTENT", update_request)
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:174: AssertionError
______________________________________ TestBaseServiceDelete.test_delete_success ______________________________________

self = <test_base_service.TestBaseServiceDelete object at 0x000001AEB43BA090>
mock_task_repository = <Mock id='1849886880272'>

    @pytest.mark.asyncio
    async def test_delete_success(self, mock_task_repository):
        """Test successful entity deletion."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.delete("T-TEST-001")
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5E3E210>, Ok)

tests\unit\services\test_base_service.py:191: AssertionError
_____________________________________ TestBaseServiceDelete.test_delete_not_found _____________________________________

self = <test_base_service.TestBaseServiceDelete object at 0x000001AEB43BA890>
mock_task_repository = <Mock id='1849889022736'>

    @pytest.mark.asyncio
    async def test_delete_not_found(self, mock_task_repository):
        """Test delete with non-existent ID returns NotFoundError."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return NotFoundError
        mock_task_repository.delete = AsyncMock(
            return_value=Err(
                NotFoundError(
                    message="Task not found",
                    entity_type="Task",
                    entity_id="T-NONEXISTENT",
                )
            )
        )
    
        # Act
        result = await service.delete("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Err)
        error = result.err()
>       assert isinstance(error, NotFoundError)
E       assert False
E        +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_base_service.py:218: AssertionError
________________________________________ TestBaseServiceList.test_list_success ________________________________________

self = <test_base_service.TestBaseServiceList object at 0x000001AEB43BB4D0>
mock_task_repository = <Mock id='1849890662416'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_list_success(self, mock_task_repository, sample_task):
        """Test successful entity listing with pagination."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.list(limit=50, offset=0)
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DD3210>, Ok)

tests\unit\services\test_base_service.py:234: AssertionError
_____________________________________ TestBaseServiceList.test_list_empty_result ______________________________________

self = <test_base_service.TestBaseServiceList object at 0x000001AEB43BBCD0>
mock_task_repository = <Mock id='1849881738064'>

    @pytest.mark.asyncio
    async def test_list_empty_result(self, mock_task_repository):
        """Test list with no results returns empty list."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return empty list
        mock_task_repository.find_all = AsyncMock(return_value=Ok([]))
    
        # Act
        result = await service.list()
    
        # Assert
>       assert isinstance(result, Ok)
E       assert False
E        +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5E77AD0>, Ok)

tests\unit\services\test_base_service.py:254: AssertionError
_______________________________________ TestBaseServiceUtility.test_exists_true _______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000001AEB43C4990>
mock_task_repository = <Mock id='1849887775056'>

    @pytest.mark.asyncio
    async def test_exists_true(self, mock_task_repository):
        """Test exists returns True for existing entity."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Act
        result = await service.exists("T-TEST-001")
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() is True
E       assert <taskman_api.core.result.Ok object at 0x000001AEB616A150> is True
E        +  where <taskman_api.core.result.Ok object at 0x000001AEB616A150> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000001AEB5E1A090>.ok

tests\unit\services\test_base_service.py:274: AssertionError
______________________________________ TestBaseServiceUtility.test_exists_false _______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000001AEB43C52D0>
mock_task_repository = <Mock id='1849890538512'>

    @pytest.mark.asyncio
    async def test_exists_false(self, mock_task_repository):
        """Test exists returns False for non-existent entity."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return False
        mock_task_repository.exists = AsyncMock(return_value=Ok(False))
    
        # Act
        result = await service.exists("T-NONEXISTENT")
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() is False
E       assert <taskman_api.core.result.Ok object at 0x000001AEB5E61C90> is False
E        +  where <taskman_api.core.result.Ok object at 0x000001AEB5E61C90> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000001AEB5E63290>.ok

tests\unit\services\test_base_service.py:291: AssertionError
______________________________________ TestBaseServiceUtility.test_count_success ______________________________________

self = <test_base_service.TestBaseServiceUtility object at 0x000001AEB43C5BD0>
mock_task_repository = <Mock id='1849889856464'>

    @pytest.mark.asyncio
    async def test_count_success(self, mock_task_repository):
        """Test count returns total entity count."""
        # Arrange
        service = BaseService(mock_task_repository, Task, TaskResponse)
    
        # Mock repository to return count
        mock_task_repository.count = AsyncMock(return_value=Ok(42))
    
        # Act
        result = await service.count()
    
        # Assert
        assert isinstance(result, Ok)
>       assert result.ok() == 42
E       assert <taskman_api.core.result.Ok object at 0x000001AEB60E4810> == 42
E        +  where <taskman_api.core.result.Ok object at 0x000001AEB60E4810> = ok()
E        +    where ok = <taskman_api.core.result.Ok object at 0x000001AEB60E6110>.ok

tests\unit\services\test_base_service.py:307: AssertionError
________________________ TestTaskServiceStatusTransitions.test_change_status_valid_transition _________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000001AEB440D310>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB60ADCD0>
mock_task_repository = <Mock name='TaskRepository()' id='1849890104976'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_change_status_valid_transition(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid status transition (NEW  READY)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Create independent copies to avoid fixture mutation
            task_with_new_status = copy.deepcopy(sample_task)
            task_with_new_status.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_with_new_status))
    
            # Mock update with independent task copy
            task_with_ready_status = copy.deepcopy(sample_task)
            task_with_ready_status.status = TaskStatus.READY
            mock_task_repository.update = AsyncMock(return_value=Ok(task_with_ready_status))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5C95750>, Ok)

tests\unit\services\test_task_service.py:48: AssertionError
_______________________ TestTaskServiceStatusTransitions.test_change_status_invalid_transition ________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000001AEB440DB10>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5A14810>
mock_task_repository = <Mock name='TaskRepository()' id='1849883119440'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.DONE')>

    @pytest.mark.asyncio
    async def test_change_status_invalid_transition(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid status transition (DONE  IN_PROGRESS)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get() to return task with DONE status (terminal state)
            sample_task.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.IN_PROGRESS)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service.py:75: AssertionError
____________________________ TestTaskServiceStatusTransitions.test_change_status_not_found ____________________________

self = <test_task_service.TestTaskServiceStatusTransitions object at 0x000001AEB440E310>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB58B4A50>
mock_task_repository = <Mock name='TaskRepository()' id='1849881747408'>

    @pytest.mark.asyncio
    async def test_change_status_not_found(self, mocker, mock_task_repository):
        """Test change_status with non-existent task."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get() to return NotFoundError
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Err(
                    NotFoundError(
                        message="Task not found",
                        entity_type="Task",
                        entity_id="T-NONEXISTENT",
                    )
                )
            )
    
            # Act
            result = await service.change_status("T-NONEXISTENT", TaskStatus.READY)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service.py:106: AssertionError
___________________________________ TestTaskServiceAssignment.test_assign_to_sprint ___________________________________

self = <test_task_service.TestTaskServiceAssignment object at 0x000001AEB4418690>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5D9FB90>
mock_task_repository = <Mock name='TaskRepository()' id='1849886893392'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_sprint(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to sprint."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            updated_task = sample_task
            updated_task.primary_sprint = "S-2025-01"
            mock_task_repository.update = AsyncMock(return_value=Ok(updated_task))
    
            # Act
>           result = await service.assign_to_sprint("T-TEST-001", "S-2025-01")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:249: in assign_to_sprint
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:115: in update
    sprint = await self.sprint_repo.get_by_id(update_data.primary_sprint)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.sprint_repository.SprintRepository object at 0x000001AEB610D4D0>
entity_id = 'S-2025-01'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
__________________________________ TestTaskServiceAssignment.test_assign_to_project ___________________________________

self = <test_task_service.TestTaskServiceAssignment object at 0x000001AEB4418E90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5E62F90>
mock_task_repository = <Mock name='TaskRepository()' id='1849887696016'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_project(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to project."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            updated_task = sample_task
            updated_task.primary_project = "P-TASKMAN"
            mock_task_repository.update = AsyncMock(return_value=Ok(updated_task))
    
            # Act
>           result = await service.assign_to_project("T-TEST-001", "P-TASKMAN")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:274: in assign_to_project
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:103: in update
    project = await self.project_repo.get_by_id(update_data.primary_project)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.project_repository.ProjectRepository object at 0x000001AEB5F5DA10>
entity_id = 'P-TASKMAN'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
_______________________________ TestTaskServiceBulkOperations.test_bulk_update_success ________________________________

self = <test_task_service.TestTaskServiceBulkOperations object at 0x000001AEB4419AD0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5FB9050>
mock_task_repository = <Mock name='TaskRepository()' id='1849889098128'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_success(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test successful bulk update of multiple tasks."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Mock get and update for each task
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-002", "priority": "p1"},
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DC07D0>, Ok)

tests\unit\services\test_task_service.py:245: AssertionError
______________________________ TestTaskServiceBulkOperations.test_bulk_update_fails_fast ______________________________

self = <test_task_service.TestTaskServiceBulkOperations object at 0x000001AEB4403D90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5913A50>
mock_task_repository = <Mock name='TaskRepository()' id='1849886868048'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_fails_fast(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test bulk update fails on first error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # First task succeeds, second task fails
            mock_task_repository.find_by_id = AsyncMock(
                side_effect=[
                    Ok(sample_task),  # First call succeeds
                    Err(
                        NotFoundError(
                            message="Task not found",
                            entity_type="Task",
                            entity_id="T-002",
                        )
                    ),  # Second call fails
                ]
            )
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-002", "status": "done"},  # This will fail
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service.py:289: AssertionError
_____________________________________ TestTaskServiceSearch.test_search_by_status _____________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001AEB4419D10>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5915610>
mock_task_repository = <Mock name='TaskRepository()' id='1849882134992'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_search_by_status(self, mocker, mock_task_repository, sample_task):
        """Test search by status filter."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
            result = await service.search(status=TaskStatus.IN_PROGRESS, limit=50)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB60E4910>, Ok)

tests\unit\services\test_task_service.py:310: AssertionError
______________________________ TestTaskServiceSearch.test_search_by_status_and_priority _______________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001AEB441A150>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5916F90>
mock_task_repository = <Mock name='TaskRepository()' id='1849886867216'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_search_by_status_and_priority(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test search with status and priority filters."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
            result = await service.search(
                status=TaskStatus.IN_PROGRESS, priority=Priority.P1
            )
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DD9050>, Ok)

tests\unit\services\test_task_service.py:336: AssertionError
_________________________________ TestTaskServiceSearch.test_get_high_priority_tasks __________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001AEB441A590>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB600CC50>
mock_task_repository = <Mock name='TaskRepository()' id='1849889445712'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_high_priority_tasks(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test get high priority tasks (P0, P1)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
>           result = await service.get_high_priority_tasks(limit=20)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:413: in get_high_priority_tasks
    responses = [
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001AEB5D93430>

    responses = [
>       self.response_class.model_validate(self._deserialize_json_fields(task))
        for task in tasks
    ]
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E   acceptance_criteria.0
E     Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
E       For further information visit https://errors.pydantic.dev/2.12/v/dict_type

src\taskman_api\services\task_service.py:414: ValidationError
____________________________________ TestTaskServiceSearch.test_get_blocked_tasks _____________________________________

self = <test_task_service.TestTaskServiceSearch object at 0x000001AEB441AB50>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB60297D0>
mock_task_repository = <Mock name='TaskRepository()' id='1849889563856'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_get_blocked_tasks(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test get blocked tasks."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Act
>           result = await service.get_blocked_tasks()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service.py:379: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:448: in get_blocked_tasks
    responses = [
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000001AEB61323B0>

    responses = [
>       self.response_class.model_validate(task) for task in tasks
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ]
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
E   acceptance_criteria.0
E     Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
E       For further information visit https://errors.pydantic.dev/2.12/v/dict_type

src\taskman_api\services\task_service.py:449: ValidationError
_____________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_new_to_ready _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB4421850>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB6082D90>
mock_task_repository = <Mock name='TaskRepository()' id='1849889923344'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_new_to_ready(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from NEW to READY."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Create task in NEW status
            task_new = copy.deepcopy(sample_task)
            task_new.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_new))
    
            # Mock update to return task in READY status
            task_ready = copy.deepcopy(sample_task)
            task_ready.status = TaskStatus.READY
            mock_task_repository.update = AsyncMock(return_value=Ok(task_ready))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB6156150>, Ok)

tests\unit\services\test_task_service_edge_cases.py:47: AssertionError
________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_in_progress_to_blocked ________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB4422050>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5DDAF10>
mock_task_repository = <Mock name='TaskRepository()' id='1849887143312'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_in_progress_to_blocked(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from IN_PROGRESS to BLOCKED."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in IN_PROGRESS status
            task_in_progress = copy.deepcopy(sample_task)
            task_in_progress.status = TaskStatus.IN_PROGRESS
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Ok(task_in_progress)
            )
    
            # Mock update to return BLOCKED task
            task_blocked = copy.deepcopy(sample_task)
            task_blocked.status = TaskStatus.BLOCKED
            mock_task_repository.update = AsyncMock(return_value=Ok(task_blocked))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.BLOCKED)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DDB050>, Ok)

tests\unit\services\test_task_service_edge_cases.py:80: AssertionError
_________________ TestTaskServiceStatusTransitionEdgeCases.test_valid_transition_in_progress_to_done __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB4422850>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5F33290>
mock_task_repository = <Mock name='TaskRepository()' id='1849888554256'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_valid_transition_in_progress_to_done(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test valid transition from IN_PROGRESS to DONE."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in IN_PROGRESS status
            task_in_progress = copy.deepcopy(sample_task)
            task_in_progress.status = TaskStatus.IN_PROGRESS
            mock_task_repository.find_by_id = AsyncMock(
                return_value=Ok(task_in_progress)
            )
    
            # Mock update to return DONE task
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.update = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.DONE)
    
            # Assert
>           assert isinstance(result, Ok)
E           assert False
E            +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5F79190>, Ok)

tests\unit\services\test_task_service_edge_cases.py:113: AssertionError
____________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_done_to_new _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB4423090>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB60F5550>
mock_task_repository = <Mock name='TaskRepository()' id='1849890397968'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_done_to_new(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DONE (terminal state) to NEW.
    
        DONE is a terminal state - no transitions allowed.
        """
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DONE status (terminal state)
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.NEW)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:144: AssertionError
________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_done_to_in_progress _________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB4423890>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5B242D0>
mock_task_repository = <Mock name='TaskRepository()' id='1849884299728'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_done_to_in_progress(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DONE (terminal state) to IN_PROGRESS."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DONE status (terminal state)
            task_done = copy.deepcopy(sample_task)
            task_done.status = TaskStatus.DONE
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_done))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.IN_PROGRESS)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:172: AssertionError
__________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_dropped_to_ready __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB1F56790>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB6154890>
mock_task_repository = <Mock name='TaskRepository()' id='1849890795280'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_dropped_to_ready(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from DROPPED (terminal state) to READY."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in DROPPED status (terminal state)
            task_dropped = copy.deepcopy(sample_task)
            task_dropped.status = TaskStatus.DROPPED
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_dropped))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.READY)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:199: AssertionError
____________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_new_to_done _____________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB44234D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5C90F90>
mock_task_repository = <Mock name='TaskRepository()' id='1849885797200'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_new_to_done(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from NEW to DONE (skip intermediate states)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in NEW status
            task_new = copy.deepcopy(sample_task)
            task_new.status = TaskStatus.NEW
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_new))
    
            # Act - attempt to jump directly to DONE
            result = await service.change_status("T-TEST-001", TaskStatus.DONE)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:226: AssertionError
__________________ TestTaskServiceStatusTransitionEdgeCases.test_invalid_transition_ready_to_blocked __________________

self = <test_task_service_edge_cases.TestTaskServiceStatusTransitionEdgeCases object at 0x000001AEB4423050>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5E20ED0>
mock_task_repository = <Mock name='TaskRepository()' id='1849887437072'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_invalid_transition_ready_to_blocked(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test invalid transition from READY to BLOCKED (must be IN_PROGRESS first)."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task in READY status
            task_ready = copy.deepcopy(sample_task)
            task_ready.status = TaskStatus.READY
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(task_ready))
    
            # Act
            result = await service.change_status("T-TEST-001", TaskStatus.BLOCKED)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, ValidationError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)

tests\unit\services\test_task_service_edge_cases.py:253: AssertionError
__________________ TestTaskServiceBulkOperationEdgeCases.test_bulk_update_partial_failure_fails_fast __________________

self = <test_task_service_edge_cases.TestTaskServiceBulkOperationEdgeCases object at 0x000001AEB4421C90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB5DEAF10>
mock_task_repository = <Mock name='TaskRepository()' id='1849890765136'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_bulk_update_partial_failure_fails_fast(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test bulk update fails on first error and doesn't continue.
    
        Ensures fail-fast behavior: if task 2 fails, task 3 should not be processed.
        """
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # First task succeeds, second task fails (not found)
            mock_task_repository.find_by_id = AsyncMock(
                side_effect=[
                    Ok(sample_task),  # Task 1 found
                    Err(
                        NotFoundError(
                            message="Task not found",
                            entity_type="Task",
                            entity_id="T-NONEXISTENT",
                        )
                    ),  # Task 2 not found
                ]
            )
            mock_task_repository.update = AsyncMock(return_value=Ok(sample_task))
    
            updates = [
                {"id": "T-001", "status": "in_progress"},
                {"id": "T-NONEXISTENT", "status": "done"},  # This will fail
                {"id": "T-003", "status": "blocked"},  # This should not be processed
            ]
    
            # Act
            result = await service.bulk_update(updates)
    
            # Assert
            assert isinstance(result, Err)
            error = result.err()
>           assert isinstance(error, NotFoundError)
E           assert False
E            +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)

tests\unit\services\test_task_service_edge_cases.py:303: AssertionError
________________________ TestTaskServiceAssignmentEdgeCases.test_assign_to_nonexistent_sprint _________________________

self = <test_task_service_edge_cases.TestTaskServiceAssignmentEdgeCases object at 0x000001AEB4419D90>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB6187350>
mock_task_repository = <Mock name='TaskRepository()' id='1849890289232'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_nonexistent_sprint(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to non-existent sprint propagates error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task exists
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Update fails (foreign key constraint)
            mock_task_repository.update = AsyncMock(
                return_value=Err(
                    ValidationError(
                        message="Sprint not found",
                        field="primary_sprint",
                        value="S-NONEXISTENT",
                    )
                )
            )
    
            # Act
>           result = await service.assign_to_sprint("T-TEST-001", "S-NONEXISTENT")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service_edge_cases.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:249: in assign_to_sprint
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:115: in update
    sprint = await self.sprint_repo.get_by_id(update_data.primary_sprint)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.sprint_repository.SprintRepository object at 0x000001AEB6097550>
entity_id = 'S-NONEXISTENT'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
________________________ TestTaskServiceAssignmentEdgeCases.test_assign_to_nonexistent_project ________________________

self = <test_task_service_edge_cases.TestTaskServiceAssignmentEdgeCases object at 0x000001AEB43FB9D0>
mocker = <pytest_mock.plugin.MockerFixture object at 0x000001AEB6095E10>
mock_task_repository = <Mock name='TaskRepository()' id='1849891750416'>
sample_task = <Task(id=T-TEST-001, title='Test Task...', status='TaskStatus.NEW')>

    @pytest.mark.asyncio
    async def test_assign_to_nonexistent_project(
        self, mocker, mock_task_repository, sample_task
    ):
        """Test assigning task to non-existent project propagates error."""
        # Arrange
        with patch("taskman_api.services.task_service.TaskRepository") as MockRepo:
            MockRepo.return_value = mock_task_repository
    
            service = TaskService(mocker.Mock())
            service.repository = mock_task_repository
            service.task_repo = mock_task_repository
    
            # Task exists
            mock_task_repository.find_by_id = AsyncMock(return_value=Ok(sample_task))
    
            # Update fails (foreign key constraint)
            mock_task_repository.update = AsyncMock(
                return_value=Err(
                    ValidationError(
                        message="Project not found",
                        field="primary_project",
                        value="P-NONEXISTENT",
                    )
                )
            )
    
            # Act
>           result = await service.assign_to_project("T-TEST-001", "P-NONEXISTENT")
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\unit\services\test_task_service_edge_cases.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\services\task_service.py:274: in assign_to_project
    return await self.update(task_id, update_request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\taskman_api\services\task_service.py:103: in update
    project = await self.project_repo.get_by_id(update_data.primary_project)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <taskman_api.repositories.project_repository.ProjectRepository object at 0x000001AEB5DC0F50>
entity_id = 'P-NONEXISTENT'

    async def get_by_id(self, entity_id: str | UUID) -> T | None:
        """Get entity by ID."""
>       result = await self.session.execute(
            select(self.model_class).where(self.model_class.id == entity_id)
        )
E       TypeError: object Mock can't be used in 'await' expression

src\taskman_api\repositories\base.py:34: TypeError
____________________________________ TestSettings.test_valid_settings_development _____________________________________

self = <test_config.TestSettings object at 0x000001AEB44498D0>

    def test_valid_settings_development(self):
        """Test valid settings for development environment."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("dev_password"),
                database="taskman_dev",
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb5da3660>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...kman_dev'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_____________________________________ TestSettings.test_valid_settings_production _____________________________________

self = <test_config.TestSettings object at 0x000001AEB4449F50>

    def test_valid_settings_production(self):
        """Test valid settings for production environment."""
>       settings = Settings(
            environment="production",
            database=DatabaseConfig(
                host="db.example.com",
                port=5432,
                user="taskman_prod",
                password=SecretStr("prod_secure_password_123"),
                database="taskman_production",
            ),
            secret_key=SecretStr("production-secret-key-min-32-chars"),
            jwt_secret=SecretStr("production-jwt-secret-min-32-chars"),
        )

tests\unit\test_config.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61d2b20>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='db.example.com', port=5432, user='taskman_prod', password=SecretStr('**********'), d...roduction'), 'environment': 'production', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________ TestSettings.test_development_allows_insecure_secrets ________________________________

self = <test_config.TestSettings object at 0x000001AEB444B310>

    def test_development_allows_insecure_secrets(self):
        """Test that development environment allows test secrets."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            secret_key=SecretStr("INSECURE_DEV_KEY_32_CHARACTERS_MIN"),
            jwt_secret=SecretStr("test-key-for-development-32-chars"),
        )

tests\unit\test_config.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61f8460>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...skman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_______________________________________ TestSettings.test_optional_redis_config _______________________________________

self = <test_config.TestSettings object at 0x000001AEB4450050>

    def test_optional_redis_config(self):
        """Test that Redis configuration is optional."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            redis=None,  # Optional
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61fa3f0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...d@localhost:5432/taskman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'redis': None, ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
_________________________________________ TestSettings.test_with_redis_config _________________________________________

self = <test_config.TestSettings object at 0x000001AEB44506D0>

    def test_with_redis_config(self):
        """Test settings with Redis configuration provided."""
>       settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            redis=RedisConfig(
                url="redis://cache.example.com:6379",
                db=1,
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61fa5d0>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...jwt_secret': SecretStr('**********'), 'redis': RedisConfig(url='redis://cache.example.com:6379', timeout=5, db=1), ...}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________________ TestSettings.test_environment_helpers ________________________________________

self = <test_config.TestSettings object at 0x000001AEB4451A10>

    def test_environment_helpers(self):
        """Test environment helper properties."""
        # Development
>       dev_settings = Settings(
            environment="development",
            database=DatabaseConfig(
                host="localhost",
                port=5432,
                user="taskman",
                password=SecretStr("password"),
                database="taskman_db",
            ),
            secret_key=SecretStr("dev-secret-key-min-32-characters"),
            jwt_secret=SecretStr("dev-jwt-secret-min-32-characters"),
        )

tests\unit\test_config.py:348: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61fb660>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None
values = {'database': DatabaseConfig(host='localhost', port=5432, user='taskman', password=SecretStr('**********'), database='t...skman_db'), 'environment': 'development', 'jwt_secret': SecretStr('**********'), 'secret_key': SecretStr('**********')}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
________________________________________ TestGetSettings.test_settings_cached _________________________________________

self = <test_config.TestGetSettings object at 0x000001AEB4452590>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001AEB620DD10>

    def test_settings_cached(self, monkeypatch):
        """Test that settings are cached across calls."""
        # Set environment variables for this test
        monkeypatch.setenv("APP_ENVIRONMENT", "testing")
        monkeypatch.setenv("APP_DATABASE__HOST", "localhost")
        monkeypatch.setenv("APP_DATABASE__PORT", "5432")
        monkeypatch.setenv("APP_DATABASE__USER", "taskman")
        monkeypatch.setenv("APP_DATABASE__PASSWORD", "test_password")
        monkeypatch.setenv("APP_DATABASE__DATABASE", "taskman_test")
        monkeypatch.setenv("APP_SECRET_KEY", "test-secret-key-min-32-characters")
        monkeypatch.setenv("APP_JWT_SECRET", "test-jwt-secret-min-32-characters")
    
        # First call
>       settings1 = get_settings()
                    ^^^^^^^^^^^^^^

tests\unit\test_config.py:422: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\config.py:290: in get_settings
    return Settings()
           ^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb61fa850>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
__________________________________________ TestGetSettings.test_cache_clear ___________________________________________

self = <test_config.TestGetSettings object at 0x000001AEB4452C10>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001AEB6190B10>

    def test_cache_clear(self, monkeypatch):
        """Test that cache_clear forces reload."""
        # Set environment variables
        monkeypatch.setenv("APP_ENVIRONMENT", "testing")
        monkeypatch.setenv("APP_DATABASE__HOST", "localhost")
        monkeypatch.setenv("APP_DATABASE__PORT", "5432")
        monkeypatch.setenv("APP_DATABASE__USER", "taskman")
        monkeypatch.setenv("APP_DATABASE__PASSWORD", "test_password")
        monkeypatch.setenv("APP_DATABASE__DATABASE", "taskman_test")
        monkeypatch.setenv("APP_SECRET_KEY", "test-secret-key-min-32-characters")
        monkeypatch.setenv("APP_JWT_SECRET", "test-jwt-secret-min-32-characters")
    
        # First call
>       settings1 = get_settings()
                    ^^^^^^^^^^^^^^

tests\unit\test_config.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\taskman_api\config.py:290: in get_settings
    return Settings()
           ^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = <[AttributeError("'Settings' object has no attribute 'environment'") raised in repr()] Settings object at 0x1aeb6283f70>
_case_sensitive = None, _nested_model_default_partial_update = None, _env_prefix = None, _env_file = WindowsPath('.')
_env_file_encoding = None, _env_ignore_empty = None, _env_nested_delimiter = None, _env_nested_max_split = None
_env_parse_none_str = None, _env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None, _cli_hide_none_type = None, _cli_avoid_json = None
_cli_enforce_required = None, _cli_use_class_docs_for_groups = None, _cli_exit_on_error = None, _cli_prefix = None
_cli_flag_prefix_char = None, _cli_implicit_flags = None, _cli_ignore_unknown_args = None, _cli_kebab_case = None
_cli_shortcuts = None, _secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | Literal['all', 'no_enums'] | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -> None:
>       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E       database_url
E         Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_host
E         Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       api_port
E         Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
E       log_level
E         Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden

.venv\Lib\site-packages\pydantic_settings\main.py:194: ValidationError
=============================================== short test summary info ===============================================
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_create_conflict - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_by_id_not_found - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_find_all_validation_limit_exceeded - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_update_not_found - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_success - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_delete_not_found - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_true - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_exists_false - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_base_repository.py::TestBaseRepository::test_count - TypeError: Can't instantiate abstract class BaseRepository with abstract method exists
FAILED tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_by_status - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_repositories.py::TestProjectRepository::test_find_active_projects - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_by_status - TypeError: 'tasks' is an invalid keyword argument for Sprint
FAILED tests/unit/db/repositories/test_repositories.py::TestSprintRepository::test_find_active_sprints - TypeError: 'tasks' is an invalid keyword argument for Sprint
FAILED tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_by_owner - TypeError: 'title' is an invalid keyword argument for ActionList
FAILED tests/unit/db/repositories/test_repositories.py::TestActionListRepository::test_find_orphaned - TypeError: 'title' is an invalid keyword argument for ActionList
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status - AttributeError: 'TaskRepository' object has no attribute 'find_by_status'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_priority - AttributeError: 'TaskRepository' object has no attribute 'find_by_priority'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_owner - AttributeError: 'TaskRepository' object has no attribute 'find_by_owner'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project - TypeError: 'sprints' is an invalid keyword argument for Project
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_project_with_status_filter - AttributeError: 'TaskRepository' object has no attribute 'find_by_project'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_sprint - AttributeError: 'TaskRepository' object has no attribute 'find_by_sprint'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_by_status_and_priority - AttributeError: 'TaskRepository' object has no attribute 'find_by_status_and_priority'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_blocked_tasks - AttributeError: 'TaskRepository' object has no attribute 'find_blocked_tasks'
FAILED tests/unit/db/repositories/test_task_repository.py::TestTaskRepository::test_find_high_priority_tasks - AttributeError: 'TaskRepository' object has no attribute 'find_high_priority_tasks'
FAILED tests/unit/db/test_connection_manager.py::test_init_creates_engines - AssertionError: assert 0 == 2
 +  where 0 = <MagicMock name='create_async_engine' id='1849888343376'>.call_count
FAILED tests/unit/db/test_connection_manager.py::test_get_session_primary_success - AssertionError: assert <AsyncMock name='mock.__aenter__()' id='1849889862352'> is <AsyncMock spec='AsyncSession' id='1849889859472'>
FAILED tests/unit/schemas/test_schemas.py::TestProjectSchemas::test_project_create_request_valid - AssertionError: assert <ProjectStatu...G: 'planning'> == <ProjectStatu...: 'discovery'>
  
  - discovery
  + planning
FAILED tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_create_request_valid - AssertionError: assert <SprintStatus...G: 'planning'> == <SprintStatus...ED: 'planned'>
  
  - planned
  + planning
FAILED tests/unit/schemas/test_schemas.py::TestSprintSchemas::test_sprint_response_with_metrics - pydantic_core._pydantic_core.ValidationError: 1 validation error for SprintResponse
dependencies
  Input should be a valid list [type=list_type, input_value={}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.12/v/list_type
FAILED tests/unit/schemas/test_schemas.py::TestActionListSchemas::test_action_list_soft_delete_fields - pydantic_core._pydantic_core.ValidationError: 1 validation error for ActionListCreate
status
  Input should be 'active' or 'archived' [type=enum, input_value='deleted', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/enum
FAILED tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_strict_type_validation - ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)
FAILED tests/unit/schemas/test_schemas.py::TestBaseSchemaConfiguration::test_from_attributes_orm_mode - ImportError: cannot import name 'BaseSchema' from 'taskman_api.schemas.base' (C:\Users\James\Documents\Github\GHrepos\SCCMScripts\TaskMan-v2\backend-api\src\taskman_api\schemas\base.py)
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_task_id_pattern_validation_failure - assert False
 +  where False = any(<generator object TestTaskCreateRequest.test_task_id_pattern_validation_failure.<locals>.<genexpr> at 0x000001AEB5FC3E60>)
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_required_fields_validation - AssertionError: assert False
 +  where False = <built-in method issubset of set object at 0x000001AEB5FC2340>({'description', 'owner', 'primary_project', 'primary_sprint', 'summary', 'title'})
 +    where <built-in method issubset of set object at 0x000001AEB5FC2340> = {'description', 'owner', 'primary_project', 'primary_sprint', 'priority', 'summary', ...}.issubset
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_business_value_score_range - Failed: DID NOT RAISE <class 'pydantic_core._pydantic_core.ValidationError'>
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskCreateRequest::test_enum_field_validation - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskCreate
severity
  Input should be 'critical', 'high', 'medium' or 'low' [type=enum, input_value=<Severity.SEV2: 'sev2'>, input_type=Severity]
    For further information visit https://errors.pydantic.dev/2.12/v/enum
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_from_orm_model - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
automation_candidate
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.12/v/bool_type
FAILED tests/unit/schemas/test_task_schemas.py::TestTaskResponse::test_response_serialization - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
automation_candidate
  Input should be a valid boolean [type=bool_type, input_value=None, input_type=NoneType]
    For further information visit https://errors.pydantic.dev/2.12/v/bool_type
FAILED tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5ACFA90>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceCreate::test_create_conflict_error - assert False
 +  where False = isinstance(AppError("9 validation errors for TaskResponse\nid\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ntitle\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nsummary\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\ndescription\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nstatus\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nowner\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\npriority\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_project\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing\nprimary_sprint\n  Field required [type=missing, input_value={'error': ConflictError('Entity already exists')}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.12/v/missing"), ConflictError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5FAE4D0>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceGet::test_get_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5835650>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUpdate::test_update_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5E3E210>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceDelete::test_delete_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DD3210>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceList::test_list_empty_result - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5E77AD0>, Ok)
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_true - assert <taskman_api.core.result.Ok object at 0x000001AEB616A150> is True
 +  where <taskman_api.core.result.Ok object at 0x000001AEB616A150> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000001AEB5E1A090>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_exists_false - assert <taskman_api.core.result.Ok object at 0x000001AEB5E61C90> is False
 +  where <taskman_api.core.result.Ok object at 0x000001AEB5E61C90> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000001AEB5E63290>.ok
FAILED tests/unit/services/test_base_service.py::TestBaseServiceUtility::test_count_success - assert <taskman_api.core.result.Ok object at 0x000001AEB60E4810> == 42
 +  where <taskman_api.core.result.Ok object at 0x000001AEB60E4810> = ok()
 +    where ok = <taskman_api.core.result.Ok object at 0x000001AEB60E6110>.ok
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_valid_transition - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5C95750>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_invalid_transition - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceStatusTransitions::test_change_status_not_found - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_sprint - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service.py::TestTaskServiceAssignment::test_assign_to_project - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_success - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DC07D0>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceBulkOperations::test_bulk_update_fails_fast - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB60E4910>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_search_by_status_and_priority - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DD9050>, Ok)
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_high_priority_tasks - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
acceptance_criteria.0
  Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/dict_type
FAILED tests/unit/services/test_task_service.py::TestTaskServiceSearch::test_get_blocked_tasks - pydantic_core._pydantic_core.ValidationError: 1 validation error for TaskResponse
acceptance_criteria.0
  Input should be a valid dictionary [type=dict_type, input_value='Criterion 1', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/dict_type
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_new_to_ready - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB6156150>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_blocked - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5DDB050>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_valid_transition_in_progress_to_done - assert False
 +  where False = isinstance(<taskman_api.core.result.Err object at 0x000001AEB5F79190>, Ok)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_new - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_done_to_in_progress - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_dropped_to_ready - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_new_to_done - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceStatusTransitionEdgeCases::test_invalid_transition_ready_to_blocked - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), ValidationError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceBulkOperationEdgeCases::test_bulk_update_partial_failure_fails_fast - assert False
 +  where False = isinstance(AppError("object Mock can't be used in 'await' expression"), NotFoundError)
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_sprint - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/services/test_task_service_edge_cases.py::TestTaskServiceAssignmentEdgeCases::test_assign_to_nonexistent_project - TypeError: object Mock can't be used in 'await' expression
FAILED tests/unit/test_config.py::TestSettings::test_valid_settings_development - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_valid_settings_production - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_development_allows_insecure_secrets - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_optional_redis_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_with_redis_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestSettings::test_environment_helpers - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestGetSettings::test_settings_cached - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
FAILED tests/unit/test_config.py::TestGetSettings::test_cache_clear - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_minimum_fields - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_create_project_with_all_fields - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_partial_single_field - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceBoundaryConditions::test_update_project_empty_mission - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_success - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceStatusTransitions::test_change_status_project_not_found - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_sprint_to_project - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_add_duplicate_sprint_idempotent - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSprintManagement::test_remove_sprint_from_project - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_no_tasks - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceMetrics::test_get_metrics_project_not_found - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_status_no_results - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_project_service_edge_cases.py::TestProjectServiceSearchAndFiltering::test_get_by_owner_no_results - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_metrics_success - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_add_sprint - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_remove_sprint - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_change_status - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_by_status - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestProjectService::test_get_by_owner - TypeError: 'sprints' is an invalid keyword argument for Project
ERROR tests/unit/services/test_services.py::TestSprintService::test_calculate_velocity - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_burndown - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_change_status - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_current_sprints - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_get_by_project - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestSprintService::test_update_metrics - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_services.py::TestActionListService::test_reorder_items_success - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_reorder_items_invalid_length - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_mark_complete - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_add_item - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_remove_item - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_get_orphaned - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_services.py::TestActionListService::test_get_soft_deleted - TypeError: 'title' is an invalid keyword argument for ActionList
ERROR tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_calculate_velocity_mixed_tasks - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/services/test_sprint_service_edge_cases.py::TestSprintServiceMetrics::test_get_burndown_calculations - TypeError: 'tasks' is an invalid keyword argument for Sprint
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_provides_complete_settings - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_database - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestSettingsFixture::test_fixture_includes_redis - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestMinimalSettingsFixture::test_fixture_provides_minimal_config - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_simulates_production - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_database - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestProductionLikeFixture::test_fixture_has_production_redis - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
ERROR tests/unit/test_fixtures.py::TestEnvironmentIsolation::test_settings_default_to_testing - pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
database_url
  Extra inputs are not permitted [type=extra_forbidden, input_value='postgresql://contextforg...calhost:5434/taskman_v2', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_host
  Extra inputs are not permitted [type=extra_forbidden, input_value='0.0.0.0', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
api_port
  Extra inputs are not permitted [type=extra_forbidden, input_value='3001', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
log_level
  Extra inputs are not permitted [type=extra_forbidden, input_value='DEBUG', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/extra_forbidden
====================================== 85 failed, 81 passed, 42 errors in 8.30s =======================================
