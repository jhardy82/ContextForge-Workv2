/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * TaskMan-v2 Backend API
 * Production REST API for TaskMan-v2 task management system
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CompleteConversationApiV1ConversationsConversationIdCompletePostParams,
  ConversationSessionCreateRequest,
  ConversationSessionResponse,
  ConversationSessionUpdateRequest,
  ConversationTurnCreateRequest,
  ConversationTurnResponse,
  GetActiveConversationsApiV1ConversationsActiveGetParams,
  GetTurnsApiV1ConversationsConversationIdTurnsGetParams,
  HTTPValidationError,
  LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams,
  LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams,
  LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams,
  ListConversationsApiV1ConversationsGetParams,
  SearchConversationsApiV1ConversationsSearchGetParams
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Search conversations with filters.

Args:
    status: Filter by status
    project_id: Filter by project
    worktree: Filter by worktree
    agent_type: Filter by agent type
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Conversation service instance

Returns:
    Filtered list of conversations
 * @summary Search Conversations
 */
export const searchConversationsApiV1ConversationsSearchGet = (
    params?: SearchConversationsApiV1ConversationsSearchGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse[]>(
      {url: `/api/v1/conversations/search`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getSearchConversationsApiV1ConversationsSearchGetQueryKey = (params?: SearchConversationsApiV1ConversationsSearchGetParams,) => {
    return [
    `/api/v1/conversations/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchConversationsApiV1ConversationsSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError = HTTPValidationError>(params?: SearchConversationsApiV1ConversationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchConversationsApiV1ConversationsSearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>> = ({ signal }) => searchConversationsApiV1ConversationsSearchGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchConversationsApiV1ConversationsSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>>
export type SearchConversationsApiV1ConversationsSearchGetQueryError = HTTPValidationError


export function useSearchConversationsApiV1ConversationsSearchGet<TData = Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError = HTTPValidationError>(
 params: undefined |  SearchConversationsApiV1ConversationsSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchConversationsApiV1ConversationsSearchGet<TData = Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError = HTTPValidationError>(
 params?: SearchConversationsApiV1ConversationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchConversationsApiV1ConversationsSearchGet<TData = Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError = HTTPValidationError>(
 params?: SearchConversationsApiV1ConversationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Search Conversations
 */

export function useSearchConversationsApiV1ConversationsSearchGet<TData = Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError = HTTPValidationError>(
 params?: SearchConversationsApiV1ConversationsSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchConversationsApiV1ConversationsSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchConversationsApiV1ConversationsSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all active conversations.

Args:
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Conversation service instance

Returns:
    List of active conversations
 * @summary Get Active Conversations
 */
export const getActiveConversationsApiV1ConversationsActiveGet = (
    params?: GetActiveConversationsApiV1ConversationsActiveGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse[]>(
      {url: `/api/v1/conversations/active`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetActiveConversationsApiV1ConversationsActiveGetQueryKey = (params?: GetActiveConversationsApiV1ConversationsActiveGetParams,) => {
    return [
    `/api/v1/conversations/active`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetActiveConversationsApiV1ConversationsActiveGetQueryOptions = <TData = Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError = HTTPValidationError>(params?: GetActiveConversationsApiV1ConversationsActiveGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActiveConversationsApiV1ConversationsActiveGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>> = ({ signal }) => getActiveConversationsApiV1ConversationsActiveGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActiveConversationsApiV1ConversationsActiveGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>>
export type GetActiveConversationsApiV1ConversationsActiveGetQueryError = HTTPValidationError


export function useGetActiveConversationsApiV1ConversationsActiveGet<TData = Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError = HTTPValidationError>(
 params: undefined |  GetActiveConversationsApiV1ConversationsActiveGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActiveConversationsApiV1ConversationsActiveGet<TData = Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError = HTTPValidationError>(
 params?: GetActiveConversationsApiV1ConversationsActiveGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>,
          TError,
          Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActiveConversationsApiV1ConversationsActiveGet<TData = Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError = HTTPValidationError>(
 params?: GetActiveConversationsApiV1ConversationsActiveGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Active Conversations
 */

export function useGetActiveConversationsApiV1ConversationsActiveGet<TData = Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError = HTTPValidationError>(
 params?: GetActiveConversationsApiV1ConversationsActiveGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActiveConversationsApiV1ConversationsActiveGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActiveConversationsApiV1ConversationsActiveGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get conversation statistics.

Args:
    service: Conversation service instance

Returns:
    Statistics dict
 * @summary Get Conversation Stats
 */
export const getConversationStatsApiV1ConversationsStatsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/conversations/stats`, method: 'GET', signal
    },
      options);
    }
  



export const getGetConversationStatsApiV1ConversationsStatsGetQueryKey = () => {
    return [
    `/api/v1/conversations/stats`
    ] as const;
    }

    
export const getGetConversationStatsApiV1ConversationsStatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConversationStatsApiV1ConversationsStatsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>> = ({ signal }) => getConversationStatsApiV1ConversationsStatsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetConversationStatsApiV1ConversationsStatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>>
export type GetConversationStatsApiV1ConversationsStatsGetQueryError = unknown


export function useGetConversationStatsApiV1ConversationsStatsGet<TData = Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationStatsApiV1ConversationsStatsGet<TData = Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationStatsApiV1ConversationsStatsGet<TData = Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Conversation Stats
 */

export function useGetConversationStatsApiV1ConversationsStatsGet<TData = Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationStatsApiV1ConversationsStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetConversationStatsApiV1ConversationsStatsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new conversation session.

Args:
    request: Conversation creation request
    service: Conversation service instance

Returns:
    Created conversation

Raises:
    409: Conversation with ID already exists
    422: Validation error
 * @summary Create Conversation
 */
export const createConversationApiV1ConversationsPost = (
    conversationSessionCreateRequest: ConversationSessionCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: conversationSessionCreateRequest, signal
    },
      options);
    }
  


export const getCreateConversationApiV1ConversationsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationApiV1ConversationsPost>>, TError,{data: ConversationSessionCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createConversationApiV1ConversationsPost>>, TError,{data: ConversationSessionCreateRequest}, TContext> => {

const mutationKey = ['createConversationApiV1ConversationsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConversationApiV1ConversationsPost>>, {data: ConversationSessionCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createConversationApiV1ConversationsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConversationApiV1ConversationsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createConversationApiV1ConversationsPost>>>
    export type CreateConversationApiV1ConversationsPostMutationBody = ConversationSessionCreateRequest
    export type CreateConversationApiV1ConversationsPostMutationError = HTTPValidationError

    /**
 * @summary Create Conversation
 */
export const useCreateConversationApiV1ConversationsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationApiV1ConversationsPost>>, TError,{data: ConversationSessionCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createConversationApiV1ConversationsPost>>,
        TError,
        {data: ConversationSessionCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateConversationApiV1ConversationsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List conversations with pagination.

Args:
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Conversation service instance

Returns:
    List of conversations
 * @summary List Conversations
 */
export const listConversationsApiV1ConversationsGet = (
    params?: ListConversationsApiV1ConversationsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse[]>(
      {url: `/api/v1/conversations`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListConversationsApiV1ConversationsGetQueryKey = (params?: ListConversationsApiV1ConversationsGetParams,) => {
    return [
    `/api/v1/conversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConversationsApiV1ConversationsGetQueryOptions = <TData = Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError = HTTPValidationError>(params?: ListConversationsApiV1ConversationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConversationsApiV1ConversationsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>> = ({ signal }) => listConversationsApiV1ConversationsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListConversationsApiV1ConversationsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>>
export type ListConversationsApiV1ConversationsGetQueryError = HTTPValidationError


export function useListConversationsApiV1ConversationsGet<TData = Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListConversationsApiV1ConversationsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>,
          TError,
          Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListConversationsApiV1ConversationsGet<TData = Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError = HTTPValidationError>(
 params?: ListConversationsApiV1ConversationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>,
          TError,
          Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListConversationsApiV1ConversationsGet<TData = Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError = HTTPValidationError>(
 params?: ListConversationsApiV1ConversationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Conversations
 */

export function useListConversationsApiV1ConversationsGet<TData = Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError = HTTPValidationError>(
 params?: ListConversationsApiV1ConversationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listConversationsApiV1ConversationsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListConversationsApiV1ConversationsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get conversation by ID.

Args:
    conversation_id: Conversation identifier
    service: Conversation service instance

Returns:
    Conversation details

Raises:
    404: Conversation not found
 * @summary Get Conversation
 */
export const getConversationApiV1ConversationsConversationIdGet = (
    conversationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetConversationApiV1ConversationsConversationIdGetQueryKey = (conversationId?: string,) => {
    return [
    `/api/v1/conversations/${conversationId}`
    ] as const;
    }

    
export const getGetConversationApiV1ConversationsConversationIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError = HTTPValidationError>(conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConversationApiV1ConversationsConversationIdGetQueryKey(conversationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>> = ({ signal }) => getConversationApiV1ConversationsConversationIdGet(conversationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(conversationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetConversationApiV1ConversationsConversationIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>>
export type GetConversationApiV1ConversationsConversationIdGetQueryError = HTTPValidationError


export function useGetConversationApiV1ConversationsConversationIdGet<TData = Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError = HTTPValidationError>(
 conversationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>,
          TError,
          Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationApiV1ConversationsConversationIdGet<TData = Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError = HTTPValidationError>(
 conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>,
          TError,
          Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationApiV1ConversationsConversationIdGet<TData = Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError = HTTPValidationError>(
 conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Conversation
 */

export function useGetConversationApiV1ConversationsConversationIdGet<TData = Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError = HTTPValidationError>(
 conversationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConversationApiV1ConversationsConversationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetConversationApiV1ConversationsConversationIdGetQueryOptions(conversationId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update conversation with partial fields.

Args:
    conversation_id: Conversation identifier
    request: Update request with optional fields
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
    422: Validation error
 * @summary Update Conversation
 */
export const updateConversationApiV1ConversationsConversationIdPatch = (
    conversationId: string,
    conversationSessionUpdateRequest: ConversationSessionUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: conversationSessionUpdateRequest
    },
      options);
    }
  


export const getUpdateConversationApiV1ConversationsConversationIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationApiV1ConversationsConversationIdPatch>>, TError,{conversationId: string;data: ConversationSessionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateConversationApiV1ConversationsConversationIdPatch>>, TError,{conversationId: string;data: ConversationSessionUpdateRequest}, TContext> => {

const mutationKey = ['updateConversationApiV1ConversationsConversationIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConversationApiV1ConversationsConversationIdPatch>>, {conversationId: string;data: ConversationSessionUpdateRequest}> = (props) => {
          const {conversationId,data} = props ?? {};

          return  updateConversationApiV1ConversationsConversationIdPatch(conversationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConversationApiV1ConversationsConversationIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateConversationApiV1ConversationsConversationIdPatch>>>
    export type UpdateConversationApiV1ConversationsConversationIdPatchMutationBody = ConversationSessionUpdateRequest
    export type UpdateConversationApiV1ConversationsConversationIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Conversation
 */
export const useUpdateConversationApiV1ConversationsConversationIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationApiV1ConversationsConversationIdPatch>>, TError,{conversationId: string;data: ConversationSessionUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateConversationApiV1ConversationsConversationIdPatch>>,
        TError,
        {conversationId: string;data: ConversationSessionUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateConversationApiV1ConversationsConversationIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete conversation by ID.

Args:
    conversation_id: Conversation identifier
    service: Conversation service instance

Returns:
    No content

Raises:
    404: Conversation not found
 * @summary Delete Conversation
 */
export const deleteConversationApiV1ConversationsConversationIdDelete = (
    conversationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/conversations/${conversationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteConversationApiV1ConversationsConversationIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationApiV1ConversationsConversationIdDelete>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConversationApiV1ConversationsConversationIdDelete>>, TError,{conversationId: string}, TContext> => {

const mutationKey = ['deleteConversationApiV1ConversationsConversationIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConversationApiV1ConversationsConversationIdDelete>>, {conversationId: string}> = (props) => {
          const {conversationId} = props ?? {};

          return  deleteConversationApiV1ConversationsConversationIdDelete(conversationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConversationApiV1ConversationsConversationIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConversationApiV1ConversationsConversationIdDelete>>>
    
    export type DeleteConversationApiV1ConversationsConversationIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Conversation
 */
export const useDeleteConversationApiV1ConversationsConversationIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationApiV1ConversationsConversationIdDelete>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteConversationApiV1ConversationsConversationIdDelete>>,
        TError,
        {conversationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteConversationApiV1ConversationsConversationIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark conversation as completed.

Args:
    conversation_id: Conversation identifier
    summary: Optional final summary
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
 * @summary Complete Conversation
 */
export const completeConversationApiV1ConversationsConversationIdCompletePost = (
    conversationId: string,
    params?: CompleteConversationApiV1ConversationsConversationIdCompletePostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/complete`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getCompleteConversationApiV1ConversationsConversationIdCompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeConversationApiV1ConversationsConversationIdCompletePost>>, TError,{conversationId: string;params?: CompleteConversationApiV1ConversationsConversationIdCompletePostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof completeConversationApiV1ConversationsConversationIdCompletePost>>, TError,{conversationId: string;params?: CompleteConversationApiV1ConversationsConversationIdCompletePostParams}, TContext> => {

const mutationKey = ['completeConversationApiV1ConversationsConversationIdCompletePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeConversationApiV1ConversationsConversationIdCompletePost>>, {conversationId: string;params?: CompleteConversationApiV1ConversationsConversationIdCompletePostParams}> = (props) => {
          const {conversationId,params} = props ?? {};

          return  completeConversationApiV1ConversationsConversationIdCompletePost(conversationId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteConversationApiV1ConversationsConversationIdCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof completeConversationApiV1ConversationsConversationIdCompletePost>>>
    
    export type CompleteConversationApiV1ConversationsConversationIdCompletePostMutationError = HTTPValidationError

    /**
 * @summary Complete Conversation
 */
export const useCompleteConversationApiV1ConversationsConversationIdCompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeConversationApiV1ConversationsConversationIdCompletePost>>, TError,{conversationId: string;params?: CompleteConversationApiV1ConversationsConversationIdCompletePostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeConversationApiV1ConversationsConversationIdCompletePost>>,
        TError,
        {conversationId: string;params?: CompleteConversationApiV1ConversationsConversationIdCompletePostParams},
        TContext
      > => {

      const mutationOptions = getCompleteConversationApiV1ConversationsConversationIdCompletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Pause an active conversation.

Args:
    conversation_id: Conversation identifier
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
 * @summary Pause Conversation
 */
export const pauseConversationApiV1ConversationsConversationIdPausePost = (
    conversationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/pause`, method: 'POST', signal
    },
      options);
    }
  


export const getPauseConversationApiV1ConversationsConversationIdPausePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pauseConversationApiV1ConversationsConversationIdPausePost>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof pauseConversationApiV1ConversationsConversationIdPausePost>>, TError,{conversationId: string}, TContext> => {

const mutationKey = ['pauseConversationApiV1ConversationsConversationIdPausePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pauseConversationApiV1ConversationsConversationIdPausePost>>, {conversationId: string}> = (props) => {
          const {conversationId} = props ?? {};

          return  pauseConversationApiV1ConversationsConversationIdPausePost(conversationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PauseConversationApiV1ConversationsConversationIdPausePostMutationResult = NonNullable<Awaited<ReturnType<typeof pauseConversationApiV1ConversationsConversationIdPausePost>>>
    
    export type PauseConversationApiV1ConversationsConversationIdPausePostMutationError = HTTPValidationError

    /**
 * @summary Pause Conversation
 */
export const usePauseConversationApiV1ConversationsConversationIdPausePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pauseConversationApiV1ConversationsConversationIdPausePost>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pauseConversationApiV1ConversationsConversationIdPausePost>>,
        TError,
        {conversationId: string},
        TContext
      > => {

      const mutationOptions = getPauseConversationApiV1ConversationsConversationIdPausePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Resume a paused conversation.

Args:
    conversation_id: Conversation identifier
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
    422: Invalid status for resume
 * @summary Resume Conversation
 */
export const resumeConversationApiV1ConversationsConversationIdResumePost = (
    conversationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/resume`, method: 'POST', signal
    },
      options);
    }
  


export const getResumeConversationApiV1ConversationsConversationIdResumePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resumeConversationApiV1ConversationsConversationIdResumePost>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resumeConversationApiV1ConversationsConversationIdResumePost>>, TError,{conversationId: string}, TContext> => {

const mutationKey = ['resumeConversationApiV1ConversationsConversationIdResumePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resumeConversationApiV1ConversationsConversationIdResumePost>>, {conversationId: string}> = (props) => {
          const {conversationId} = props ?? {};

          return  resumeConversationApiV1ConversationsConversationIdResumePost(conversationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResumeConversationApiV1ConversationsConversationIdResumePostMutationResult = NonNullable<Awaited<ReturnType<typeof resumeConversationApiV1ConversationsConversationIdResumePost>>>
    
    export type ResumeConversationApiV1ConversationsConversationIdResumePostMutationError = HTTPValidationError

    /**
 * @summary Resume Conversation
 */
export const useResumeConversationApiV1ConversationsConversationIdResumePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resumeConversationApiV1ConversationsConversationIdResumePost>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resumeConversationApiV1ConversationsConversationIdResumePost>>,
        TError,
        {conversationId: string},
        TContext
      > => {

      const mutationOptions = getResumeConversationApiV1ConversationsConversationIdResumePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Archive a conversation.

Args:
    conversation_id: Conversation identifier
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
 * @summary Archive Conversation
 */
export const archiveConversationApiV1ConversationsConversationIdArchivePost = (
    conversationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/archive`, method: 'POST', signal
    },
      options);
    }
  


export const getArchiveConversationApiV1ConversationsConversationIdArchivePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof archiveConversationApiV1ConversationsConversationIdArchivePost>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof archiveConversationApiV1ConversationsConversationIdArchivePost>>, TError,{conversationId: string}, TContext> => {

const mutationKey = ['archiveConversationApiV1ConversationsConversationIdArchivePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof archiveConversationApiV1ConversationsConversationIdArchivePost>>, {conversationId: string}> = (props) => {
          const {conversationId} = props ?? {};

          return  archiveConversationApiV1ConversationsConversationIdArchivePost(conversationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ArchiveConversationApiV1ConversationsConversationIdArchivePostMutationResult = NonNullable<Awaited<ReturnType<typeof archiveConversationApiV1ConversationsConversationIdArchivePost>>>
    
    export type ArchiveConversationApiV1ConversationsConversationIdArchivePostMutationError = HTTPValidationError

    /**
 * @summary Archive Conversation
 */
export const useArchiveConversationApiV1ConversationsConversationIdArchivePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof archiveConversationApiV1ConversationsConversationIdArchivePost>>, TError,{conversationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof archiveConversationApiV1ConversationsConversationIdArchivePost>>,
        TError,
        {conversationId: string},
        TContext
      > => {

      const mutationOptions = getArchiveConversationApiV1ConversationsConversationIdArchivePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Add a turn to a conversation.

Args:
    conversation_id: Conversation identifier
    request: Turn creation request
    service: Conversation service instance

Returns:
    Created turn

Raises:
    404: Conversation not found
 * @summary Add Turn
 */
export const addTurnApiV1ConversationsConversationIdTurnsPost = (
    conversationId: string,
    conversationTurnCreateRequest: ConversationTurnCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationTurnResponse>(
      {url: `/api/v1/conversations/${conversationId}/turns`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: conversationTurnCreateRequest, signal
    },
      options);
    }
  


export const getAddTurnApiV1ConversationsConversationIdTurnsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTurnApiV1ConversationsConversationIdTurnsPost>>, TError,{conversationId: string;data: ConversationTurnCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addTurnApiV1ConversationsConversationIdTurnsPost>>, TError,{conversationId: string;data: ConversationTurnCreateRequest}, TContext> => {

const mutationKey = ['addTurnApiV1ConversationsConversationIdTurnsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTurnApiV1ConversationsConversationIdTurnsPost>>, {conversationId: string;data: ConversationTurnCreateRequest}> = (props) => {
          const {conversationId,data} = props ?? {};

          return  addTurnApiV1ConversationsConversationIdTurnsPost(conversationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddTurnApiV1ConversationsConversationIdTurnsPostMutationResult = NonNullable<Awaited<ReturnType<typeof addTurnApiV1ConversationsConversationIdTurnsPost>>>
    export type AddTurnApiV1ConversationsConversationIdTurnsPostMutationBody = ConversationTurnCreateRequest
    export type AddTurnApiV1ConversationsConversationIdTurnsPostMutationError = HTTPValidationError

    /**
 * @summary Add Turn
 */
export const useAddTurnApiV1ConversationsConversationIdTurnsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTurnApiV1ConversationsConversationIdTurnsPost>>, TError,{conversationId: string;data: ConversationTurnCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addTurnApiV1ConversationsConversationIdTurnsPost>>,
        TError,
        {conversationId: string;data: ConversationTurnCreateRequest},
        TContext
      > => {

      const mutationOptions = getAddTurnApiV1ConversationsConversationIdTurnsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get turns for a conversation.

Args:
    conversation_id: Conversation identifier
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Conversation service instance

Returns:
    List of turns

Raises:
    404: Conversation not found
 * @summary Get Turns
 */
export const getTurnsApiV1ConversationsConversationIdTurnsGet = (
    conversationId: string,
    params?: GetTurnsApiV1ConversationsConversationIdTurnsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationTurnResponse[]>(
      {url: `/api/v1/conversations/${conversationId}/turns`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetTurnsApiV1ConversationsConversationIdTurnsGetQueryKey = (conversationId?: string,
    params?: GetTurnsApiV1ConversationsConversationIdTurnsGetParams,) => {
    return [
    `/api/v1/conversations/${conversationId}/turns`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetTurnsApiV1ConversationsConversationIdTurnsGetQueryOptions = <TData = Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError = HTTPValidationError>(conversationId: string,
    params?: GetTurnsApiV1ConversationsConversationIdTurnsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTurnsApiV1ConversationsConversationIdTurnsGetQueryKey(conversationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>> = ({ signal }) => getTurnsApiV1ConversationsConversationIdTurnsGet(conversationId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(conversationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTurnsApiV1ConversationsConversationIdTurnsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>>
export type GetTurnsApiV1ConversationsConversationIdTurnsGetQueryError = HTTPValidationError


export function useGetTurnsApiV1ConversationsConversationIdTurnsGet<TData = Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError = HTTPValidationError>(
 conversationId: string,
    params: undefined |  GetTurnsApiV1ConversationsConversationIdTurnsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>,
          TError,
          Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTurnsApiV1ConversationsConversationIdTurnsGet<TData = Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError = HTTPValidationError>(
 conversationId: string,
    params?: GetTurnsApiV1ConversationsConversationIdTurnsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>,
          TError,
          Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTurnsApiV1ConversationsConversationIdTurnsGet<TData = Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError = HTTPValidationError>(
 conversationId: string,
    params?: GetTurnsApiV1ConversationsConversationIdTurnsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Turns
 */

export function useGetTurnsApiV1ConversationsConversationIdTurnsGet<TData = Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError = HTTPValidationError>(
 conversationId: string,
    params?: GetTurnsApiV1ConversationsConversationIdTurnsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTurnsApiV1ConversationsConversationIdTurnsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTurnsApiV1ConversationsConversationIdTurnsGetQueryOptions(conversationId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Link a plan to this conversation.

Args:
    conversation_id: Conversation identifier
    plan_id: Plan ID to link
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
 * @summary Link Plan
 */
export const linkPlanApiV1ConversationsConversationIdLinkPlanPost = (
    conversationId: string,
    params: LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/link-plan`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getLinkPlanApiV1ConversationsConversationIdLinkPlanPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkPlanApiV1ConversationsConversationIdLinkPlanPost>>, TError,{conversationId: string;params: LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof linkPlanApiV1ConversationsConversationIdLinkPlanPost>>, TError,{conversationId: string;params: LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams}, TContext> => {

const mutationKey = ['linkPlanApiV1ConversationsConversationIdLinkPlanPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof linkPlanApiV1ConversationsConversationIdLinkPlanPost>>, {conversationId: string;params: LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams}> = (props) => {
          const {conversationId,params} = props ?? {};

          return  linkPlanApiV1ConversationsConversationIdLinkPlanPost(conversationId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LinkPlanApiV1ConversationsConversationIdLinkPlanPostMutationResult = NonNullable<Awaited<ReturnType<typeof linkPlanApiV1ConversationsConversationIdLinkPlanPost>>>
    
    export type LinkPlanApiV1ConversationsConversationIdLinkPlanPostMutationError = HTTPValidationError

    /**
 * @summary Link Plan
 */
export const useLinkPlanApiV1ConversationsConversationIdLinkPlanPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkPlanApiV1ConversationsConversationIdLinkPlanPost>>, TError,{conversationId: string;params: LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof linkPlanApiV1ConversationsConversationIdLinkPlanPost>>,
        TError,
        {conversationId: string;params: LinkPlanApiV1ConversationsConversationIdLinkPlanPostParams},
        TContext
      > => {

      const mutationOptions = getLinkPlanApiV1ConversationsConversationIdLinkPlanPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Link a checklist to this conversation.

Args:
    conversation_id: Conversation identifier
    checklist_id: Checklist ID to link
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
 * @summary Link Checklist
 */
export const linkChecklistApiV1ConversationsConversationIdLinkChecklistPost = (
    conversationId: string,
    params: LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/link-checklist`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getLinkChecklistApiV1ConversationsConversationIdLinkChecklistPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkChecklistApiV1ConversationsConversationIdLinkChecklistPost>>, TError,{conversationId: string;params: LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof linkChecklistApiV1ConversationsConversationIdLinkChecklistPost>>, TError,{conversationId: string;params: LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams}, TContext> => {

const mutationKey = ['linkChecklistApiV1ConversationsConversationIdLinkChecklistPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof linkChecklistApiV1ConversationsConversationIdLinkChecklistPost>>, {conversationId: string;params: LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams}> = (props) => {
          const {conversationId,params} = props ?? {};

          return  linkChecklistApiV1ConversationsConversationIdLinkChecklistPost(conversationId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostMutationResult = NonNullable<Awaited<ReturnType<typeof linkChecklistApiV1ConversationsConversationIdLinkChecklistPost>>>
    
    export type LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostMutationError = HTTPValidationError

    /**
 * @summary Link Checklist
 */
export const useLinkChecklistApiV1ConversationsConversationIdLinkChecklistPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkChecklistApiV1ConversationsConversationIdLinkChecklistPost>>, TError,{conversationId: string;params: LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof linkChecklistApiV1ConversationsConversationIdLinkChecklistPost>>,
        TError,
        {conversationId: string;params: LinkChecklistApiV1ConversationsConversationIdLinkChecklistPostParams},
        TContext
      > => {

      const mutationOptions = getLinkChecklistApiV1ConversationsConversationIdLinkChecklistPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Link a task to this conversation.

Args:
    conversation_id: Conversation identifier
    task_id: Task ID to link
    service: Conversation service instance

Returns:
    Updated conversation

Raises:
    404: Conversation not found
 * @summary Link Task
 */
export const linkTaskApiV1ConversationsConversationIdLinkTaskPost = (
    conversationId: string,
    params: LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSessionResponse>(
      {url: `/api/v1/conversations/${conversationId}/link-task`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getLinkTaskApiV1ConversationsConversationIdLinkTaskPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkTaskApiV1ConversationsConversationIdLinkTaskPost>>, TError,{conversationId: string;params: LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof linkTaskApiV1ConversationsConversationIdLinkTaskPost>>, TError,{conversationId: string;params: LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams}, TContext> => {

const mutationKey = ['linkTaskApiV1ConversationsConversationIdLinkTaskPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof linkTaskApiV1ConversationsConversationIdLinkTaskPost>>, {conversationId: string;params: LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams}> = (props) => {
          const {conversationId,params} = props ?? {};

          return  linkTaskApiV1ConversationsConversationIdLinkTaskPost(conversationId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LinkTaskApiV1ConversationsConversationIdLinkTaskPostMutationResult = NonNullable<Awaited<ReturnType<typeof linkTaskApiV1ConversationsConversationIdLinkTaskPost>>>
    
    export type LinkTaskApiV1ConversationsConversationIdLinkTaskPostMutationError = HTTPValidationError

    /**
 * @summary Link Task
 */
export const useLinkTaskApiV1ConversationsConversationIdLinkTaskPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof linkTaskApiV1ConversationsConversationIdLinkTaskPost>>, TError,{conversationId: string;params: LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof linkTaskApiV1ConversationsConversationIdLinkTaskPost>>,
        TError,
        {conversationId: string;params: LinkTaskApiV1ConversationsConversationIdLinkTaskPostParams},
        TContext
      > => {

      const mutationOptions = getLinkTaskApiV1ConversationsConversationIdLinkTaskPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    