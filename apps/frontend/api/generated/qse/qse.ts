/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * TaskMan-v2 Backend API
 * Production REST API for TaskMan-v2 task management system
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  EvaluationCreate,
  EvaluationResponse,
  EvidenceCreate,
  EvidenceResponse,
  GateCreate,
  GateResponse,
  HTTPValidationError,
  ListEvaluationsApiV1QseEvaluationsGetParams,
  ListEvidenceApiV1QseEvidenceGetParams,
  ListGatesApiV1QseGatesGetParams
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List all available quality gates.
 * @summary List Gates
 */
export const listGatesApiV1QseGatesGet = (
    params?: ListGatesApiV1QseGatesGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GateResponse[]>(
      {url: `/api/v1/qse/gates`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListGatesApiV1QseGatesGetQueryKey = (params?: ListGatesApiV1QseGatesGetParams,) => {
    return [
    `/api/v1/qse/gates`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListGatesApiV1QseGatesGetQueryOptions = <TData = Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError = HTTPValidationError>(params?: ListGatesApiV1QseGatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListGatesApiV1QseGatesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>> = ({ signal }) => listGatesApiV1QseGatesGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListGatesApiV1QseGatesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>>
export type ListGatesApiV1QseGatesGetQueryError = HTTPValidationError


export function useListGatesApiV1QseGatesGet<TData = Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError = HTTPValidationError>(
 params: undefined |  ListGatesApiV1QseGatesGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>,
          TError,
          Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListGatesApiV1QseGatesGet<TData = Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError = HTTPValidationError>(
 params?: ListGatesApiV1QseGatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>,
          TError,
          Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListGatesApiV1QseGatesGet<TData = Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError = HTTPValidationError>(
 params?: ListGatesApiV1QseGatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Gates
 */

export function useListGatesApiV1QseGatesGet<TData = Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError = HTTPValidationError>(
 params?: ListGatesApiV1QseGatesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listGatesApiV1QseGatesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListGatesApiV1QseGatesGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new quality gate.
 * @summary Create Gate
 */
export const createGateApiV1QseGatesPost = (
    gateCreate: GateCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GateResponse>(
      {url: `/api/v1/qse/gates`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: gateCreate, signal
    },
      options);
    }
  


export const getCreateGateApiV1QseGatesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGateApiV1QseGatesPost>>, TError,{data: GateCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createGateApiV1QseGatesPost>>, TError,{data: GateCreate}, TContext> => {

const mutationKey = ['createGateApiV1QseGatesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGateApiV1QseGatesPost>>, {data: GateCreate}> = (props) => {
          const {data} = props ?? {};

          return  createGateApiV1QseGatesPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGateApiV1QseGatesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createGateApiV1QseGatesPost>>>
    export type CreateGateApiV1QseGatesPostMutationBody = GateCreate
    export type CreateGateApiV1QseGatesPostMutationError = HTTPValidationError

    /**
 * @summary Create Gate
 */
export const useCreateGateApiV1QseGatesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGateApiV1QseGatesPost>>, TError,{data: GateCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createGateApiV1QseGatesPost>>,
        TError,
        {data: GateCreate},
        TContext
      > => {

      const mutationOptions = getCreateGateApiV1QseGatesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Perform a gate evaluation.
 * @summary Evaluate Gate
 */
export const evaluateGateApiV1QseEvaluatePost = (
    evaluationCreate: EvaluationCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationResponse>(
      {url: `/api/v1/qse/evaluate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: evaluationCreate, signal
    },
      options);
    }
  


export const getEvaluateGateApiV1QseEvaluatePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateGateApiV1QseEvaluatePost>>, TError,{data: EvaluationCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluateGateApiV1QseEvaluatePost>>, TError,{data: EvaluationCreate}, TContext> => {

const mutationKey = ['evaluateGateApiV1QseEvaluatePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluateGateApiV1QseEvaluatePost>>, {data: EvaluationCreate}> = (props) => {
          const {data} = props ?? {};

          return  evaluateGateApiV1QseEvaluatePost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluateGateApiV1QseEvaluatePostMutationResult = NonNullable<Awaited<ReturnType<typeof evaluateGateApiV1QseEvaluatePost>>>
    export type EvaluateGateApiV1QseEvaluatePostMutationBody = EvaluationCreate
    export type EvaluateGateApiV1QseEvaluatePostMutationError = HTTPValidationError

    /**
 * @summary Evaluate Gate
 */
export const useEvaluateGateApiV1QseEvaluatePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateGateApiV1QseEvaluatePost>>, TError,{data: EvaluationCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluateGateApiV1QseEvaluatePost>>,
        TError,
        {data: EvaluationCreate},
        TContext
      > => {

      const mutationOptions = getEvaluateGateApiV1QseEvaluatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve evaluation details by ID.
 * @summary Get Evaluation
 */
export const getEvaluationApiV1QseEvaluationsEvaluationIdGet = (
    evaluationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationResponse>(
      {url: `/api/v1/qse/evaluations/${evaluationId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEvaluationApiV1QseEvaluationsEvaluationIdGetQueryKey = (evaluationId?: string,) => {
    return [
    `/api/v1/qse/evaluations/${evaluationId}`
    ] as const;
    }

    
export const getGetEvaluationApiV1QseEvaluationsEvaluationIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(evaluationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvaluationApiV1QseEvaluationsEvaluationIdGetQueryKey(evaluationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>> = ({ signal }) => getEvaluationApiV1QseEvaluationsEvaluationIdGet(evaluationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(evaluationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEvaluationApiV1QseEvaluationsEvaluationIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>>
export type GetEvaluationApiV1QseEvaluationsEvaluationIdGetQueryError = HTTPValidationError


export function useGetEvaluationApiV1QseEvaluationsEvaluationIdGet<TData = Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(
 evaluationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEvaluationApiV1QseEvaluationsEvaluationIdGet<TData = Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(
 evaluationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEvaluationApiV1QseEvaluationsEvaluationIdGet<TData = Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(
 evaluationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Evaluation
 */

export function useGetEvaluationApiV1QseEvaluationsEvaluationIdGet<TData = Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(
 evaluationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvaluationApiV1QseEvaluationsEvaluationIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEvaluationApiV1QseEvaluationsEvaluationIdGetQueryOptions(evaluationId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all gate evaluations with optional filters.
 * @summary List Evaluations
 */
export const listEvaluationsApiV1QseEvaluationsGet = (
    params?: ListEvaluationsApiV1QseEvaluationsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationResponse[]>(
      {url: `/api/v1/qse/evaluations`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListEvaluationsApiV1QseEvaluationsGetQueryKey = (params?: ListEvaluationsApiV1QseEvaluationsGetParams,) => {
    return [
    `/api/v1/qse/evaluations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListEvaluationsApiV1QseEvaluationsGetQueryOptions = <TData = Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError = HTTPValidationError>(params?: ListEvaluationsApiV1QseEvaluationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEvaluationsApiV1QseEvaluationsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>> = ({ signal }) => listEvaluationsApiV1QseEvaluationsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListEvaluationsApiV1QseEvaluationsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>>
export type ListEvaluationsApiV1QseEvaluationsGetQueryError = HTTPValidationError


export function useListEvaluationsApiV1QseEvaluationsGet<TData = Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError = HTTPValidationError>(
 params: undefined |  ListEvaluationsApiV1QseEvaluationsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>,
          TError,
          Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListEvaluationsApiV1QseEvaluationsGet<TData = Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError = HTTPValidationError>(
 params?: ListEvaluationsApiV1QseEvaluationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>,
          TError,
          Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListEvaluationsApiV1QseEvaluationsGet<TData = Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError = HTTPValidationError>(
 params?: ListEvaluationsApiV1QseEvaluationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Evaluations
 */

export function useListEvaluationsApiV1QseEvaluationsGet<TData = Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError = HTTPValidationError>(
 params?: ListEvaluationsApiV1QseEvaluationsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsApiV1QseEvaluationsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListEvaluationsApiV1QseEvaluationsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Record evidence for a task or session.
Typically called by the CLI or remote agents.
 * @summary Create Evidence
 */
export const createEvidenceApiV1QseEvidencePost = (
    evidenceCreate: EvidenceCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EvidenceResponse>(
      {url: `/api/v1/qse/evidence`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: evidenceCreate, signal
    },
      options);
    }
  


export const getCreateEvidenceApiV1QseEvidencePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEvidenceApiV1QseEvidencePost>>, TError,{data: EvidenceCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createEvidenceApiV1QseEvidencePost>>, TError,{data: EvidenceCreate}, TContext> => {

const mutationKey = ['createEvidenceApiV1QseEvidencePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEvidenceApiV1QseEvidencePost>>, {data: EvidenceCreate}> = (props) => {
          const {data} = props ?? {};

          return  createEvidenceApiV1QseEvidencePost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEvidenceApiV1QseEvidencePostMutationResult = NonNullable<Awaited<ReturnType<typeof createEvidenceApiV1QseEvidencePost>>>
    export type CreateEvidenceApiV1QseEvidencePostMutationBody = EvidenceCreate
    export type CreateEvidenceApiV1QseEvidencePostMutationError = HTTPValidationError

    /**
 * @summary Create Evidence
 */
export const useCreateEvidenceApiV1QseEvidencePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEvidenceApiV1QseEvidencePost>>, TError,{data: EvidenceCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEvidenceApiV1QseEvidencePost>>,
        TError,
        {data: EvidenceCreate},
        TContext
      > => {

      const mutationOptions = getCreateEvidenceApiV1QseEvidencePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List evidence with optional filters.
 * @summary List Evidence
 */
export const listEvidenceApiV1QseEvidenceGet = (
    params?: ListEvidenceApiV1QseEvidenceGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EvidenceResponse[]>(
      {url: `/api/v1/qse/evidence`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListEvidenceApiV1QseEvidenceGetQueryKey = (params?: ListEvidenceApiV1QseEvidenceGetParams,) => {
    return [
    `/api/v1/qse/evidence`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListEvidenceApiV1QseEvidenceGetQueryOptions = <TData = Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError = HTTPValidationError>(params?: ListEvidenceApiV1QseEvidenceGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEvidenceApiV1QseEvidenceGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>> = ({ signal }) => listEvidenceApiV1QseEvidenceGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListEvidenceApiV1QseEvidenceGetQueryResult = NonNullable<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>>
export type ListEvidenceApiV1QseEvidenceGetQueryError = HTTPValidationError


export function useListEvidenceApiV1QseEvidenceGet<TData = Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError = HTTPValidationError>(
 params: undefined |  ListEvidenceApiV1QseEvidenceGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>,
          TError,
          Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListEvidenceApiV1QseEvidenceGet<TData = Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError = HTTPValidationError>(
 params?: ListEvidenceApiV1QseEvidenceGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>,
          TError,
          Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListEvidenceApiV1QseEvidenceGet<TData = Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError = HTTPValidationError>(
 params?: ListEvidenceApiV1QseEvidenceGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Evidence
 */

export function useListEvidenceApiV1QseEvidenceGet<TData = Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError = HTTPValidationError>(
 params?: ListEvidenceApiV1QseEvidenceGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvidenceApiV1QseEvidenceGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListEvidenceApiV1QseEvidenceGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve evidence details by ID.
 * @summary Get Evidence
 */
export const getEvidenceApiV1QseEvidenceEvidenceIdGet = (
    evidenceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EvidenceResponse>(
      {url: `/api/v1/qse/evidence/${evidenceId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetEvidenceApiV1QseEvidenceEvidenceIdGetQueryKey = (evidenceId?: string,) => {
    return [
    `/api/v1/qse/evidence/${evidenceId}`
    ] as const;
    }

    
export const getGetEvidenceApiV1QseEvidenceEvidenceIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError = HTTPValidationError>(evidenceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvidenceApiV1QseEvidenceEvidenceIdGetQueryKey(evidenceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>> = ({ signal }) => getEvidenceApiV1QseEvidenceEvidenceIdGet(evidenceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(evidenceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetEvidenceApiV1QseEvidenceEvidenceIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>>
export type GetEvidenceApiV1QseEvidenceEvidenceIdGetQueryError = HTTPValidationError


export function useGetEvidenceApiV1QseEvidenceEvidenceIdGet<TData = Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError = HTTPValidationError>(
 evidenceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEvidenceApiV1QseEvidenceEvidenceIdGet<TData = Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError = HTTPValidationError>(
 evidenceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>,
          TError,
          Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetEvidenceApiV1QseEvidenceEvidenceIdGet<TData = Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError = HTTPValidationError>(
 evidenceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Evidence
 */

export function useGetEvidenceApiV1QseEvidenceEvidenceIdGet<TData = Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError = HTTPValidationError>(
 evidenceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvidenceApiV1QseEvidenceEvidenceIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetEvidenceApiV1QseEvidenceEvidenceIdGetQueryOptions(evidenceId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




