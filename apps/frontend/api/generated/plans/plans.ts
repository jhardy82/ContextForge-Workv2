/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * TaskMan-v2 Backend API
 * Production REST API for TaskMan-v2 task management system
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AbandonPlanApiV1PlansPlanIdAbandonPostParams,
  AddStepApiV1PlansPlanIdStepsPostParams,
  CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams,
  GetDraftPlansApiV1PlansDraftsGetParams,
  GetInProgressPlansApiV1PlansInProgressGetParams,
  GetStalledPlansApiV1PlansStalledGetParams,
  HTTPValidationError,
  ListPlansApiV1PlansGetParams,
  PlanCreateRequest,
  PlanResponse,
  PlanStepInput,
  PlanUpdateRequest,
  SearchPlansApiV1PlansSearchGetParams,
  SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Search plans with filters.

Args:
    status: Filter by status
    project_id: Filter by project
    sprint_id: Filter by sprint
    conversation_id: Filter by conversation
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Plan service instance

Returns:
    Filtered list of plans
 * @summary Search Plans
 */
export const searchPlansApiV1PlansSearchGet = (
    params?: SearchPlansApiV1PlansSearchGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse[]>(
      {url: `/api/v1/plans/search`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getSearchPlansApiV1PlansSearchGetQueryKey = (params?: SearchPlansApiV1PlansSearchGetParams,) => {
    return [
    `/api/v1/plans/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchPlansApiV1PlansSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError = HTTPValidationError>(params?: SearchPlansApiV1PlansSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchPlansApiV1PlansSearchGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>> = ({ signal }) => searchPlansApiV1PlansSearchGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type SearchPlansApiV1PlansSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>>
export type SearchPlansApiV1PlansSearchGetQueryError = HTTPValidationError


export function useSearchPlansApiV1PlansSearchGet<TData = Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError = HTTPValidationError>(
 params: undefined |  SearchPlansApiV1PlansSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchPlansApiV1PlansSearchGet<TData = Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError = HTTPValidationError>(
 params?: SearchPlansApiV1PlansSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useSearchPlansApiV1PlansSearchGet<TData = Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError = HTTPValidationError>(
 params?: SearchPlansApiV1PlansSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Search Plans
 */

export function useSearchPlansApiV1PlansSearchGet<TData = Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError = HTTPValidationError>(
 params?: SearchPlansApiV1PlansSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchPlansApiV1PlansSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getSearchPlansApiV1PlansSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all draft plans awaiting approval.

Args:
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Plan service instance

Returns:
    List of draft plans
 * @summary Get Draft Plans
 */
export const getDraftPlansApiV1PlansDraftsGet = (
    params?: GetDraftPlansApiV1PlansDraftsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse[]>(
      {url: `/api/v1/plans/drafts`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetDraftPlansApiV1PlansDraftsGetQueryKey = (params?: GetDraftPlansApiV1PlansDraftsGetParams,) => {
    return [
    `/api/v1/plans/drafts`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetDraftPlansApiV1PlansDraftsGetQueryOptions = <TData = Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError = HTTPValidationError>(params?: GetDraftPlansApiV1PlansDraftsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDraftPlansApiV1PlansDraftsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>> = ({ signal }) => getDraftPlansApiV1PlansDraftsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDraftPlansApiV1PlansDraftsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>>
export type GetDraftPlansApiV1PlansDraftsGetQueryError = HTTPValidationError


export function useGetDraftPlansApiV1PlansDraftsGet<TData = Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetDraftPlansApiV1PlansDraftsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>,
          TError,
          Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDraftPlansApiV1PlansDraftsGet<TData = Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError = HTTPValidationError>(
 params?: GetDraftPlansApiV1PlansDraftsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>,
          TError,
          Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDraftPlansApiV1PlansDraftsGet<TData = Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError = HTTPValidationError>(
 params?: GetDraftPlansApiV1PlansDraftsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Draft Plans
 */

export function useGetDraftPlansApiV1PlansDraftsGet<TData = Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError = HTTPValidationError>(
 params?: GetDraftPlansApiV1PlansDraftsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDraftPlansApiV1PlansDraftsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDraftPlansApiV1PlansDraftsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all in-progress plans.

Args:
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Plan service instance

Returns:
    List of in-progress plans
 * @summary Get In Progress Plans
 */
export const getInProgressPlansApiV1PlansInProgressGet = (
    params?: GetInProgressPlansApiV1PlansInProgressGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse[]>(
      {url: `/api/v1/plans/in-progress`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetInProgressPlansApiV1PlansInProgressGetQueryKey = (params?: GetInProgressPlansApiV1PlansInProgressGetParams,) => {
    return [
    `/api/v1/plans/in-progress`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetInProgressPlansApiV1PlansInProgressGetQueryOptions = <TData = Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError = HTTPValidationError>(params?: GetInProgressPlansApiV1PlansInProgressGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInProgressPlansApiV1PlansInProgressGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>> = ({ signal }) => getInProgressPlansApiV1PlansInProgressGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetInProgressPlansApiV1PlansInProgressGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>>
export type GetInProgressPlansApiV1PlansInProgressGetQueryError = HTTPValidationError


export function useGetInProgressPlansApiV1PlansInProgressGet<TData = Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError = HTTPValidationError>(
 params: undefined |  GetInProgressPlansApiV1PlansInProgressGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>,
          TError,
          Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInProgressPlansApiV1PlansInProgressGet<TData = Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError = HTTPValidationError>(
 params?: GetInProgressPlansApiV1PlansInProgressGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>,
          TError,
          Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetInProgressPlansApiV1PlansInProgressGet<TData = Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError = HTTPValidationError>(
 params?: GetInProgressPlansApiV1PlansInProgressGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get In Progress Plans
 */

export function useGetInProgressPlansApiV1PlansInProgressGet<TData = Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError = HTTPValidationError>(
 params?: GetInProgressPlansApiV1PlansInProgressGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInProgressPlansApiV1PlansInProgressGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetInProgressPlansApiV1PlansInProgressGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get stalled plans (in_progress but not updated recently).

Args:
    days_inactive: Days without update to consider stalled
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Plan service instance

Returns:
    List of stalled plans
 * @summary Get Stalled Plans
 */
export const getStalledPlansApiV1PlansStalledGet = (
    params?: GetStalledPlansApiV1PlansStalledGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse[]>(
      {url: `/api/v1/plans/stalled`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetStalledPlansApiV1PlansStalledGetQueryKey = (params?: GetStalledPlansApiV1PlansStalledGetParams,) => {
    return [
    `/api/v1/plans/stalled`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetStalledPlansApiV1PlansStalledGetQueryOptions = <TData = Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError = HTTPValidationError>(params?: GetStalledPlansApiV1PlansStalledGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStalledPlansApiV1PlansStalledGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>> = ({ signal }) => getStalledPlansApiV1PlansStalledGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetStalledPlansApiV1PlansStalledGetQueryResult = NonNullable<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>>
export type GetStalledPlansApiV1PlansStalledGetQueryError = HTTPValidationError


export function useGetStalledPlansApiV1PlansStalledGet<TData = Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError = HTTPValidationError>(
 params: undefined |  GetStalledPlansApiV1PlansStalledGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>,
          TError,
          Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStalledPlansApiV1PlansStalledGet<TData = Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError = HTTPValidationError>(
 params?: GetStalledPlansApiV1PlansStalledGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>,
          TError,
          Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStalledPlansApiV1PlansStalledGet<TData = Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError = HTTPValidationError>(
 params?: GetStalledPlansApiV1PlansStalledGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Stalled Plans
 */

export function useGetStalledPlansApiV1PlansStalledGet<TData = Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError = HTTPValidationError>(
 params?: GetStalledPlansApiV1PlansStalledGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStalledPlansApiV1PlansStalledGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetStalledPlansApiV1PlansStalledGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get plan statistics.

Args:
    service: Plan service instance

Returns:
    Statistics dict
 * @summary Get Plan Stats
 */
export const getPlanStatsApiV1PlansStatsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/plans/stats`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPlanStatsApiV1PlansStatsGetQueryKey = () => {
    return [
    `/api/v1/plans/stats`
    ] as const;
    }

    
export const getGetPlanStatsApiV1PlansStatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPlanStatsApiV1PlansStatsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>> = ({ signal }) => getPlanStatsApiV1PlansStatsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPlanStatsApiV1PlansStatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>>
export type GetPlanStatsApiV1PlansStatsGetQueryError = unknown


export function useGetPlanStatsApiV1PlansStatsGet<TData = Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPlanStatsApiV1PlansStatsGet<TData = Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPlanStatsApiV1PlansStatsGet<TData = Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Plan Stats
 */

export function useGetPlanStatsApiV1PlansStatsGet<TData = Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanStatsApiV1PlansStatsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPlanStatsApiV1PlansStatsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new plan.

Args:
    request: Plan creation request
    service: Plan service instance

Returns:
    Created plan

Raises:
    409: Plan with ID already exists
    422: Validation error
 * @summary Create Plan
 */
export const createPlanApiV1PlansPost = (
    planCreateRequest: PlanCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: planCreateRequest, signal
    },
      options);
    }
  


export const getCreatePlanApiV1PlansPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPlanApiV1PlansPost>>, TError,{data: PlanCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createPlanApiV1PlansPost>>, TError,{data: PlanCreateRequest}, TContext> => {

const mutationKey = ['createPlanApiV1PlansPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPlanApiV1PlansPost>>, {data: PlanCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createPlanApiV1PlansPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePlanApiV1PlansPostMutationResult = NonNullable<Awaited<ReturnType<typeof createPlanApiV1PlansPost>>>
    export type CreatePlanApiV1PlansPostMutationBody = PlanCreateRequest
    export type CreatePlanApiV1PlansPostMutationError = HTTPValidationError

    /**
 * @summary Create Plan
 */
export const useCreatePlanApiV1PlansPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPlanApiV1PlansPost>>, TError,{data: PlanCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPlanApiV1PlansPost>>,
        TError,
        {data: PlanCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreatePlanApiV1PlansPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List plans with pagination.

Args:
    limit: Maximum results (1-1000, default: 100)
    offset: Results to skip (default: 0)
    service: Plan service instance

Returns:
    List of plans
 * @summary List Plans
 */
export const listPlansApiV1PlansGet = (
    params?: ListPlansApiV1PlansGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse[]>(
      {url: `/api/v1/plans`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getListPlansApiV1PlansGetQueryKey = (params?: ListPlansApiV1PlansGetParams,) => {
    return [
    `/api/v1/plans`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPlansApiV1PlansGetQueryOptions = <TData = Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError = HTTPValidationError>(params?: ListPlansApiV1PlansGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPlansApiV1PlansGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>> = ({ signal }) => listPlansApiV1PlansGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListPlansApiV1PlansGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>>
export type ListPlansApiV1PlansGetQueryError = HTTPValidationError


export function useListPlansApiV1PlansGet<TData = Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError = HTTPValidationError>(
 params: undefined |  ListPlansApiV1PlansGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlansApiV1PlansGet>>,
          TError,
          Awaited<ReturnType<typeof listPlansApiV1PlansGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPlansApiV1PlansGet<TData = Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError = HTTPValidationError>(
 params?: ListPlansApiV1PlansGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPlansApiV1PlansGet>>,
          TError,
          Awaited<ReturnType<typeof listPlansApiV1PlansGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListPlansApiV1PlansGet<TData = Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError = HTTPValidationError>(
 params?: ListPlansApiV1PlansGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List Plans
 */

export function useListPlansApiV1PlansGet<TData = Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError = HTTPValidationError>(
 params?: ListPlansApiV1PlansGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPlansApiV1PlansGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListPlansApiV1PlansGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get plan by ID.

Args:
    plan_id: Plan identifier
    service: Plan service instance

Returns:
    Plan details

Raises:
    404: Plan not found
 * @summary Get Plan
 */
export const getPlanApiV1PlansPlanIdGet = (
    planId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPlanApiV1PlansPlanIdGetQueryKey = (planId?: string,) => {
    return [
    `/api/v1/plans/${planId}`
    ] as const;
    }

    
export const getGetPlanApiV1PlansPlanIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError = HTTPValidationError>(planId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPlanApiV1PlansPlanIdGetQueryKey(planId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>> = ({ signal }) => getPlanApiV1PlansPlanIdGet(planId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(planId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPlanApiV1PlansPlanIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>>
export type GetPlanApiV1PlansPlanIdGetQueryError = HTTPValidationError


export function useGetPlanApiV1PlansPlanIdGet<TData = Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError = HTTPValidationError>(
 planId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPlanApiV1PlansPlanIdGet<TData = Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError = HTTPValidationError>(
 planId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPlanApiV1PlansPlanIdGet<TData = Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError = HTTPValidationError>(
 planId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Plan
 */

export function useGetPlanApiV1PlansPlanIdGet<TData = Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError = HTTPValidationError>(
 planId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPlanApiV1PlansPlanIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPlanApiV1PlansPlanIdGetQueryOptions(planId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update plan with partial fields.

Args:
    plan_id: Plan identifier
    request: Update request with optional fields
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan not found
    422: Validation error
 * @summary Update Plan
 */
export const updatePlanApiV1PlansPlanIdPatch = (
    planId: string,
    planUpdateRequest: PlanUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: planUpdateRequest
    },
      options);
    }
  


export const getUpdatePlanApiV1PlansPlanIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePlanApiV1PlansPlanIdPatch>>, TError,{planId: string;data: PlanUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePlanApiV1PlansPlanIdPatch>>, TError,{planId: string;data: PlanUpdateRequest}, TContext> => {

const mutationKey = ['updatePlanApiV1PlansPlanIdPatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePlanApiV1PlansPlanIdPatch>>, {planId: string;data: PlanUpdateRequest}> = (props) => {
          const {planId,data} = props ?? {};

          return  updatePlanApiV1PlansPlanIdPatch(planId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePlanApiV1PlansPlanIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updatePlanApiV1PlansPlanIdPatch>>>
    export type UpdatePlanApiV1PlansPlanIdPatchMutationBody = PlanUpdateRequest
    export type UpdatePlanApiV1PlansPlanIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Plan
 */
export const useUpdatePlanApiV1PlansPlanIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePlanApiV1PlansPlanIdPatch>>, TError,{planId: string;data: PlanUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePlanApiV1PlansPlanIdPatch>>,
        TError,
        {planId: string;data: PlanUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdatePlanApiV1PlansPlanIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete plan by ID.

Args:
    plan_id: Plan identifier
    service: Plan service instance

Returns:
    No content

Raises:
    404: Plan not found
 * @summary Delete Plan
 */
export const deletePlanApiV1PlansPlanIdDelete = (
    planId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/plans/${planId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeletePlanApiV1PlansPlanIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePlanApiV1PlansPlanIdDelete>>, TError,{planId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deletePlanApiV1PlansPlanIdDelete>>, TError,{planId: string}, TContext> => {

const mutationKey = ['deletePlanApiV1PlansPlanIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePlanApiV1PlansPlanIdDelete>>, {planId: string}> = (props) => {
          const {planId} = props ?? {};

          return  deletePlanApiV1PlansPlanIdDelete(planId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePlanApiV1PlansPlanIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePlanApiV1PlansPlanIdDelete>>>
    
    export type DeletePlanApiV1PlansPlanIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Plan
 */
export const useDeletePlanApiV1PlansPlanIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePlanApiV1PlansPlanIdDelete>>, TError,{planId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePlanApiV1PlansPlanIdDelete>>,
        TError,
        {planId: string},
        TContext
      > => {

      const mutationOptions = getDeletePlanApiV1PlansPlanIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Approve a draft plan for execution.

Args:
    plan_id: Plan identifier
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan not found
    422: Plan is not in draft status
 * @summary Approve Plan
 */
export const approvePlanApiV1PlansPlanIdApprovePost = (
    planId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}/approve`, method: 'POST', signal
    },
      options);
    }
  


export const getApprovePlanApiV1PlansPlanIdApprovePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approvePlanApiV1PlansPlanIdApprovePost>>, TError,{planId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof approvePlanApiV1PlansPlanIdApprovePost>>, TError,{planId: string}, TContext> => {

const mutationKey = ['approvePlanApiV1PlansPlanIdApprovePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof approvePlanApiV1PlansPlanIdApprovePost>>, {planId: string}> = (props) => {
          const {planId} = props ?? {};

          return  approvePlanApiV1PlansPlanIdApprovePost(planId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApprovePlanApiV1PlansPlanIdApprovePostMutationResult = NonNullable<Awaited<ReturnType<typeof approvePlanApiV1PlansPlanIdApprovePost>>>
    
    export type ApprovePlanApiV1PlansPlanIdApprovePostMutationError = HTTPValidationError

    /**
 * @summary Approve Plan
 */
export const useApprovePlanApiV1PlansPlanIdApprovePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof approvePlanApiV1PlansPlanIdApprovePost>>, TError,{planId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof approvePlanApiV1PlansPlanIdApprovePost>>,
        TError,
        {planId: string},
        TContext
      > => {

      const mutationOptions = getApprovePlanApiV1PlansPlanIdApprovePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Start executing an approved plan.

Args:
    plan_id: Plan identifier
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan not found
    422: Plan is not approved
 * @summary Start Plan
 */
export const startPlanApiV1PlansPlanIdStartPost = (
    planId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}/start`, method: 'POST', signal
    },
      options);
    }
  


export const getStartPlanApiV1PlansPlanIdStartPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startPlanApiV1PlansPlanIdStartPost>>, TError,{planId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof startPlanApiV1PlansPlanIdStartPost>>, TError,{planId: string}, TContext> => {

const mutationKey = ['startPlanApiV1PlansPlanIdStartPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startPlanApiV1PlansPlanIdStartPost>>, {planId: string}> = (props) => {
          const {planId} = props ?? {};

          return  startPlanApiV1PlansPlanIdStartPost(planId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartPlanApiV1PlansPlanIdStartPostMutationResult = NonNullable<Awaited<ReturnType<typeof startPlanApiV1PlansPlanIdStartPost>>>
    
    export type StartPlanApiV1PlansPlanIdStartPostMutationError = HTTPValidationError

    /**
 * @summary Start Plan
 */
export const useStartPlanApiV1PlansPlanIdStartPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startPlanApiV1PlansPlanIdStartPost>>, TError,{planId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startPlanApiV1PlansPlanIdStartPost>>,
        TError,
        {planId: string},
        TContext
      > => {

      const mutationOptions = getStartPlanApiV1PlansPlanIdStartPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Abandon a plan.

Args:
    plan_id: Plan identifier
    reason: Optional reason for abandoning
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan not found
 * @summary Abandon Plan
 */
export const abandonPlanApiV1PlansPlanIdAbandonPost = (
    planId: string,
    params?: AbandonPlanApiV1PlansPlanIdAbandonPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}/abandon`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getAbandonPlanApiV1PlansPlanIdAbandonPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonPlanApiV1PlansPlanIdAbandonPost>>, TError,{planId: string;params?: AbandonPlanApiV1PlansPlanIdAbandonPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof abandonPlanApiV1PlansPlanIdAbandonPost>>, TError,{planId: string;params?: AbandonPlanApiV1PlansPlanIdAbandonPostParams}, TContext> => {

const mutationKey = ['abandonPlanApiV1PlansPlanIdAbandonPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof abandonPlanApiV1PlansPlanIdAbandonPost>>, {planId: string;params?: AbandonPlanApiV1PlansPlanIdAbandonPostParams}> = (props) => {
          const {planId,params} = props ?? {};

          return  abandonPlanApiV1PlansPlanIdAbandonPost(planId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AbandonPlanApiV1PlansPlanIdAbandonPostMutationResult = NonNullable<Awaited<ReturnType<typeof abandonPlanApiV1PlansPlanIdAbandonPost>>>
    
    export type AbandonPlanApiV1PlansPlanIdAbandonPostMutationError = HTTPValidationError

    /**
 * @summary Abandon Plan
 */
export const useAbandonPlanApiV1PlansPlanIdAbandonPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof abandonPlanApiV1PlansPlanIdAbandonPost>>, TError,{planId: string;params?: AbandonPlanApiV1PlansPlanIdAbandonPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof abandonPlanApiV1PlansPlanIdAbandonPost>>,
        TError,
        {planId: string;params?: AbandonPlanApiV1PlansPlanIdAbandonPostParams},
        TContext
      > => {

      const mutationOptions = getAbandonPlanApiV1PlansPlanIdAbandonPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark a step as completed.

Args:
    plan_id: Plan identifier
    step_id: Step identifier
    notes: Optional completion notes
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan or step not found
    422: Step is already completed/skipped
 * @summary Complete Step
 */
export const completeStepApiV1PlansPlanIdStepsStepIdCompletePost = (
    planId: string,
    stepId: string,
    params?: CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}/steps/${stepId}/complete`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getCompleteStepApiV1PlansPlanIdStepsStepIdCompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeStepApiV1PlansPlanIdStepsStepIdCompletePost>>, TError,{planId: string;stepId: string;params?: CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof completeStepApiV1PlansPlanIdStepsStepIdCompletePost>>, TError,{planId: string;stepId: string;params?: CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams}, TContext> => {

const mutationKey = ['completeStepApiV1PlansPlanIdStepsStepIdCompletePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeStepApiV1PlansPlanIdStepsStepIdCompletePost>>, {planId: string;stepId: string;params?: CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams}> = (props) => {
          const {planId,stepId,params} = props ?? {};

          return  completeStepApiV1PlansPlanIdStepsStepIdCompletePost(planId,stepId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof completeStepApiV1PlansPlanIdStepsStepIdCompletePost>>>
    
    export type CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostMutationError = HTTPValidationError

    /**
 * @summary Complete Step
 */
export const useCompleteStepApiV1PlansPlanIdStepsStepIdCompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeStepApiV1PlansPlanIdStepsStepIdCompletePost>>, TError,{planId: string;stepId: string;params?: CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeStepApiV1PlansPlanIdStepsStepIdCompletePost>>,
        TError,
        {planId: string;stepId: string;params?: CompleteStepApiV1PlansPlanIdStepsStepIdCompletePostParams},
        TContext
      > => {

      const mutationOptions = getCompleteStepApiV1PlansPlanIdStepsStepIdCompletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Skip a step.

Args:
    plan_id: Plan identifier
    step_id: Step identifier
    reason: Optional reason for skipping
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan or step not found
    422: Step is already completed/skipped
 * @summary Skip Step
 */
export const skipStepApiV1PlansPlanIdStepsStepIdSkipPost = (
    planId: string,
    stepId: string,
    params?: SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}/steps/${stepId}/skip`, method: 'POST',
        params, signal
    },
      options);
    }
  


export const getSkipStepApiV1PlansPlanIdStepsStepIdSkipPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skipStepApiV1PlansPlanIdStepsStepIdSkipPost>>, TError,{planId: string;stepId: string;params?: SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof skipStepApiV1PlansPlanIdStepsStepIdSkipPost>>, TError,{planId: string;stepId: string;params?: SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams}, TContext> => {

const mutationKey = ['skipStepApiV1PlansPlanIdStepsStepIdSkipPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skipStepApiV1PlansPlanIdStepsStepIdSkipPost>>, {planId: string;stepId: string;params?: SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams}> = (props) => {
          const {planId,stepId,params} = props ?? {};

          return  skipStepApiV1PlansPlanIdStepsStepIdSkipPost(planId,stepId,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkipStepApiV1PlansPlanIdStepsStepIdSkipPostMutationResult = NonNullable<Awaited<ReturnType<typeof skipStepApiV1PlansPlanIdStepsStepIdSkipPost>>>
    
    export type SkipStepApiV1PlansPlanIdStepsStepIdSkipPostMutationError = HTTPValidationError

    /**
 * @summary Skip Step
 */
export const useSkipStepApiV1PlansPlanIdStepsStepIdSkipPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skipStepApiV1PlansPlanIdStepsStepIdSkipPost>>, TError,{planId: string;stepId: string;params?: SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skipStepApiV1PlansPlanIdStepsStepIdSkipPost>>,
        TError,
        {planId: string;stepId: string;params?: SkipStepApiV1PlansPlanIdStepsStepIdSkipPostParams},
        TContext
      > => {

      const mutationOptions = getSkipStepApiV1PlansPlanIdStepsStepIdSkipPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Add a step to a plan.

Args:
    plan_id: Plan identifier
    step: Step to add
    after_step_id: Insert after this step (or at end if None)
    service: Plan service instance

Returns:
    Updated plan

Raises:
    404: Plan not found
 * @summary Add Step
 */
export const addStepApiV1PlansPlanIdStepsPost = (
    planId: string,
    planStepInput: PlanStepInput,
    params?: AddStepApiV1PlansPlanIdStepsPostParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PlanResponse>(
      {url: `/api/v1/plans/${planId}/steps`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: planStepInput,
        params, signal
    },
      options);
    }
  


export const getAddStepApiV1PlansPlanIdStepsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addStepApiV1PlansPlanIdStepsPost>>, TError,{planId: string;data: PlanStepInput;params?: AddStepApiV1PlansPlanIdStepsPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addStepApiV1PlansPlanIdStepsPost>>, TError,{planId: string;data: PlanStepInput;params?: AddStepApiV1PlansPlanIdStepsPostParams}, TContext> => {

const mutationKey = ['addStepApiV1PlansPlanIdStepsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addStepApiV1PlansPlanIdStepsPost>>, {planId: string;data: PlanStepInput;params?: AddStepApiV1PlansPlanIdStepsPostParams}> = (props) => {
          const {planId,data,params} = props ?? {};

          return  addStepApiV1PlansPlanIdStepsPost(planId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddStepApiV1PlansPlanIdStepsPostMutationResult = NonNullable<Awaited<ReturnType<typeof addStepApiV1PlansPlanIdStepsPost>>>
    export type AddStepApiV1PlansPlanIdStepsPostMutationBody = PlanStepInput
    export type AddStepApiV1PlansPlanIdStepsPostMutationError = HTTPValidationError

    /**
 * @summary Add Step
 */
export const useAddStepApiV1PlansPlanIdStepsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addStepApiV1PlansPlanIdStepsPost>>, TError,{planId: string;data: PlanStepInput;params?: AddStepApiV1PlansPlanIdStepsPostParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addStepApiV1PlansPlanIdStepsPost>>,
        TError,
        {planId: string;data: PlanStepInput;params?: AddStepApiV1PlansPlanIdStepsPostParams},
        TContext
      > => {

      const mutationOptions = getAddStepApiV1PlansPlanIdStepsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    