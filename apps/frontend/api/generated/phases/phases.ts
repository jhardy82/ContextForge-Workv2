/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * TaskMan-v2 Backend API
 * Production REST API for TaskMan-v2 task management system
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost200,
  BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody,
  BlockedEntityResponse,
  CompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost200,
  EntityInPhaseResponse,
  FindBlockedEntitiesApiV1PhasesBlockedGetParams,
  FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams,
  GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams,
  HTTPValidationError,
  PhaseAnalyticsResponse,
  PhaseSummaryResponse,
  PhaseUpdateRequest,
  PhasesResponse,
  SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost200,
  SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody,
  StartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost200,
  UnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost200,
  UpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch200
} from '.././model';

import { customInstance } from '../../../lib/axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get all phases for an entity.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    service: Phase service instance

Returns:
    All phases with their current data

Raises:
    404: Entity not found
 * @summary Get Phases
 */
export const getPhasesApiV1PhasesEntityTypeEntityIdGet = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PhasesResponse>(
      {url: `/api/v1/phases/${entityType}/${entityId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPhasesApiV1PhasesEntityTypeEntityIdGetQueryKey = (entityType?: 'task' | 'sprint' | 'project',
    entityId?: string,) => {
    return [
    `/api/v1/phases/${entityType}/${entityId}`
    ] as const;
    }

    
export const getGetPhasesApiV1PhasesEntityTypeEntityIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError = HTTPValidationError>(entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhasesApiV1PhasesEntityTypeEntityIdGetQueryKey(entityType,entityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>> = ({ signal }) => getPhasesApiV1PhasesEntityTypeEntityIdGet(entityType,entityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(entityType && entityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPhasesApiV1PhasesEntityTypeEntityIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>>
export type GetPhasesApiV1PhasesEntityTypeEntityIdGetQueryError = HTTPValidationError


export function useGetPhasesApiV1PhasesEntityTypeEntityIdGet<TData = Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhasesApiV1PhasesEntityTypeEntityIdGet<TData = Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>,
          TError,
          Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhasesApiV1PhasesEntityTypeEntityIdGet<TData = Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Phases
 */

export function useGetPhasesApiV1PhasesEntityTypeEntityIdGet<TData = Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhasesApiV1PhasesEntityTypeEntityIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPhasesApiV1PhasesEntityTypeEntityIdGetQueryOptions(entityType,entityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get phase summary with progress metrics.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    service: Phase service instance

Returns:
    Phase summary including completion percentage and current phase

Raises:
    404: Entity not found
 * @summary Get Phase Summary
 */
export const getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PhaseSummaryResponse>(
      {url: `/api/v1/phases/${entityType}/${entityId}/summary`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGetQueryKey = (entityType?: 'task' | 'sprint' | 'project',
    entityId?: string,) => {
    return [
    `/api/v1/phases/${entityType}/${entityId}/summary`
    ] as const;
    }

    
export const getGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGetQueryOptions = <TData = Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError = HTTPValidationError>(entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGetQueryKey(entityType,entityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>> = ({ signal }) => getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet(entityType,entityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(entityType && entityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>>
export type GetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGetQueryError = HTTPValidationError


export function useGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet<TData = Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>,
          TError,
          Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet<TData = Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>,
          TError,
          Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet<TData = Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Phase Summary
 */

export function useGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet<TData = Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    entityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPhaseSummaryApiV1PhasesEntityTypeEntityIdSummaryGetQueryOptions(entityType,entityId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a specific phase.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    phase_name: Name of the phase to update
    request: Update request with optional fields
    service: Phase service instance

Returns:
    Updated phase data

Raises:
    404: Entity not found
    422: Invalid phase name or status transition
 * @summary Update Phase
 */
export const updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
    phaseName: string,
    phaseUpdateRequest: PhaseUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch200>(
      {url: `/api/v1/phases/${entityType}/${entityId}/${phaseName}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: phaseUpdateRequest
    },
      options);
    }
  


export const getUpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: PhaseUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: PhaseUpdateRequest}, TContext> => {

const mutationKey = ['updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch>>, {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: PhaseUpdateRequest}> = (props) => {
          const {entityType,entityId,phaseName,data} = props ?? {};

          return  updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch(entityType,entityId,phaseName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch>>>
    export type UpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatchMutationBody = PhaseUpdateRequest
    export type UpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatchMutationError = HTTPValidationError

    /**
 * @summary Update Phase
 */
export const useUpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: PhaseUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatch>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: PhaseUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdatePhaseApiV1PhasesEntityTypeEntityIdPhaseNamePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Advance entity to the next phase.

Completes the current in_progress phase and starts the next one.
If no phase is in_progress, starts the first not_started phase.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    service: Phase service instance

Returns:
    Updated phases

Raises:
    404: Entity not found
    422: No phases available to advance
 * @summary Advance Phase
 */
export const advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PhasesResponse>(
      {url: `/api/v1/phases/${entityType}/${entityId}/advance`, method: 'POST', signal
    },
      options);
    }
  


export const getAdvancePhaseApiV1PhasesEntityTypeEntityIdAdvancePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string}, TContext> => {

const mutationKey = ['advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost>>, {entityType: 'task' | 'sprint' | 'project';entityId: string}> = (props) => {
          const {entityType,entityId} = props ?? {};

          return  advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost(entityType,entityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdvancePhaseApiV1PhasesEntityTypeEntityIdAdvancePostMutationResult = NonNullable<Awaited<ReturnType<typeof advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost>>>
    
    export type AdvancePhaseApiV1PhasesEntityTypeEntityIdAdvancePostMutationError = HTTPValidationError

    /**
 * @summary Advance Phase
 */
export const useAdvancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof advancePhaseApiV1PhasesEntityTypeEntityIdAdvancePost>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string},
        TContext
      > => {

      const mutationOptions = getAdvancePhaseApiV1PhasesEntityTypeEntityIdAdvancePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Block a phase with optional reason.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    phase_name: Name of the phase to block
    request: Optional block reason
    service: Phase service instance

Returns:
    Updated phase data

Raises:
    404: Entity not found
    422: Invalid phase name or transition
 * @summary Block Phase
 */
export const blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
    phaseName: string,
    blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody: BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost200>(
      {url: `/api/v1/phases/${entityType}/${entityId}/${phaseName}/block`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody, signal
    },
      options);
    }
  


export const getBlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody}, TContext> => {

const mutationKey = ['blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost>>, {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody}> = (props) => {
          const {entityType,entityId,phaseName,data} = props ?? {};

          return  blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost(entityType,entityId,phaseName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostMutationResult = NonNullable<Awaited<ReturnType<typeof blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost>>>
    export type BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostMutationBody = BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody
    export type BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostMutationError = HTTPValidationError

    /**
 * @summary Block Phase
 */
export const useBlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof blockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPost>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: BlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostBody},
        TContext
      > => {

      const mutationOptions = getBlockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameBlockPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Unblock a phase and resume work.

Sets the phase status back to in_progress.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    phase_name: Name of the phase to unblock
    service: Phase service instance

Returns:
    Updated phase data

Raises:
    404: Entity not found
    422: Invalid phase name or transition
 * @summary Unblock Phase
 */
export const unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
    phaseName: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost200>(
      {url: `/api/v1/phases/${entityType}/${entityId}/${phaseName}/unblock`, method: 'POST', signal
    },
      options);
    }
  


export const getUnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext> => {

const mutationKey = ['unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost>>, {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}> = (props) => {
          const {entityType,entityId,phaseName} = props ?? {};

          return  unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost(entityType,entityId,phaseName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPostMutationResult = NonNullable<Awaited<ReturnType<typeof unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost>>>
    
    export type UnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPostMutationError = HTTPValidationError

    /**
 * @summary Unblock Phase
 */
export const useUnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPost>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string},
        TContext
      > => {

      const mutationOptions = getUnblockPhaseApiV1PhasesEntityTypeEntityIdPhaseNameUnblockPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Skip a phase with optional reason.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    phase_name: Name of the phase to skip
    request: Optional skip reason
    service: Phase service instance

Returns:
    Updated phase data

Raises:
    404: Entity not found
    422: Invalid phase name or transition
 * @summary Skip Phase
 */
export const skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
    phaseName: string,
    skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody: SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost200>(
      {url: `/api/v1/phases/${entityType}/${entityId}/${phaseName}/skip`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody, signal
    },
      options);
    }
  


export const getSkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody}, TContext> => {

const mutationKey = ['skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost>>, {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody}> = (props) => {
          const {entityType,entityId,phaseName,data} = props ?? {};

          return  skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost(entityType,entityId,phaseName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostMutationResult = NonNullable<Awaited<ReturnType<typeof skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost>>>
    export type SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostMutationBody = SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody
    export type SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostMutationError = HTTPValidationError

    /**
 * @summary Skip Phase
 */
export const useSkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof skipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPost>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string;data: SkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostBody},
        TContext
      > => {

      const mutationOptions = getSkipPhaseApiV1PhasesEntityTypeEntityIdPhaseNameSkipPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark a phase as completed.

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    phase_name: Name of the phase to complete
    service: Phase service instance

Returns:
    Updated phase data

Raises:
    404: Entity not found
    422: Invalid phase name or transition
 * @summary Complete Phase
 */
export const completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
    phaseName: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost200>(
      {url: `/api/v1/phases/${entityType}/${entityId}/${phaseName}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getCompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext> => {

const mutationKey = ['completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost>>, {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}> = (props) => {
          const {entityType,entityId,phaseName} = props ?? {};

          return  completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost(entityType,entityId,phaseName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost>>>
    
    export type CompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePostMutationError = HTTPValidationError

    /**
 * @summary Complete Phase
 */
export const useCompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePost>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string},
        TContext
      > => {

      const mutationOptions = getCompletePhaseApiV1PhasesEntityTypeEntityIdPhaseNameCompletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Start a phase (set to in_progress).

Args:
    entity_type: Type of entity (task, sprint, project)
    entity_id: Entity identifier
    phase_name: Name of the phase to start
    service: Phase service instance

Returns:
    Updated phase data

Raises:
    404: Entity not found
    422: Invalid phase name or transition
 * @summary Start Phase
 */
export const startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost = (
    entityType: 'task' | 'sprint' | 'project',
    entityId: string,
    phaseName: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost200>(
      {url: `/api/v1/phases/${entityType}/${entityId}/${phaseName}/start`, method: 'POST', signal
    },
      options);
    }
  


export const getStartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext> => {

const mutationKey = ['startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost>>, {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}> = (props) => {
          const {entityType,entityId,phaseName} = props ?? {};

          return  startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost(entityType,entityId,phaseName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPostMutationResult = NonNullable<Awaited<ReturnType<typeof startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost>>>
    
    export type StartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPostMutationError = HTTPValidationError

    /**
 * @summary Start Phase
 */
export const useStartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost>>, TError,{entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPost>>,
        TError,
        {entityType: 'task' | 'sprint' | 'project';entityId: string;phaseName: string},
        TContext
      > => {

      const mutationOptions = getStartPhaseApiV1PhasesEntityTypeEntityIdPhaseNameStartPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Find entities in a specific phase.

Args:
    entity_type: Type of entity to search (task, sprint, project)
    phase_name: Phase name to filter by
    phase_status: Optional status filter
    limit: Maximum results
    offset: Results to skip
    service: Phase service instance

Returns:
    List of entities in the specified phase

Raises:
    422: Invalid phase name
 * @summary Find Entities In Phase
 */
export const findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet = (
    entityType: 'task' | 'sprint' | 'project',
    params: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EntityInPhaseResponse[]>(
      {url: `/api/v1/phases/${entityType}/search`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetQueryKey = (entityType?: 'task' | 'sprint' | 'project',
    params?: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams,) => {
    return [
    `/api/v1/phases/${entityType}/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError = HTTPValidationError>(entityType: 'task' | 'sprint' | 'project',
    params: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetQueryKey(entityType,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>> = ({ signal }) => findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet(entityType,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(entityType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>>
export type FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetQueryError = HTTPValidationError


export function useFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGet<TData = Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>,
          TError,
          Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGet<TData = Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>,
          TError,
          Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGet<TData = Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Find Entities In Phase
 */

export function useFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGet<TData = Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params: FindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findEntitiesInPhaseApiV1PhasesEntityTypeSearchGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getFindEntitiesInPhaseApiV1PhasesEntityTypeSearchGetQueryOptions(entityType,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Find all entities with blocked phases.

Args:
    entity_type: Optional filter by entity type
    limit: Maximum results
    offset: Results to skip
    service: Phase service instance

Returns:
    List of blocked entity summaries
 * @summary Find Blocked Entities
 */
export const findBlockedEntitiesApiV1PhasesBlockedGet = (
    params?: FindBlockedEntitiesApiV1PhasesBlockedGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BlockedEntityResponse[]>(
      {url: `/api/v1/phases/blocked`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getFindBlockedEntitiesApiV1PhasesBlockedGetQueryKey = (params?: FindBlockedEntitiesApiV1PhasesBlockedGetParams,) => {
    return [
    `/api/v1/phases/blocked`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFindBlockedEntitiesApiV1PhasesBlockedGetQueryOptions = <TData = Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError = HTTPValidationError>(params?: FindBlockedEntitiesApiV1PhasesBlockedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindBlockedEntitiesApiV1PhasesBlockedGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>> = ({ signal }) => findBlockedEntitiesApiV1PhasesBlockedGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type FindBlockedEntitiesApiV1PhasesBlockedGetQueryResult = NonNullable<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>>
export type FindBlockedEntitiesApiV1PhasesBlockedGetQueryError = HTTPValidationError


export function useFindBlockedEntitiesApiV1PhasesBlockedGet<TData = Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError = HTTPValidationError>(
 params: undefined |  FindBlockedEntitiesApiV1PhasesBlockedGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>,
          TError,
          Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindBlockedEntitiesApiV1PhasesBlockedGet<TData = Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError = HTTPValidationError>(
 params?: FindBlockedEntitiesApiV1PhasesBlockedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>,
          TError,
          Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useFindBlockedEntitiesApiV1PhasesBlockedGet<TData = Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError = HTTPValidationError>(
 params?: FindBlockedEntitiesApiV1PhasesBlockedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Find Blocked Entities
 */

export function useFindBlockedEntitiesApiV1PhasesBlockedGet<TData = Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError = HTTPValidationError>(
 params?: FindBlockedEntitiesApiV1PhasesBlockedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findBlockedEntitiesApiV1PhasesBlockedGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getFindBlockedEntitiesApiV1PhasesBlockedGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get phase analytics for an entity type.

Analyzes phase distribution and completion across entities.

Args:
    entity_type: Type of entity to analyze
    limit: Maximum entities to analyze
    offset: Entities to skip
    service: Phase service instance

Returns:
    Phase analytics with counts and percentages
 * @summary Get Phase Analytics
 */
export const getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet = (
    entityType: 'task' | 'sprint' | 'project',
    params?: GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PhaseAnalyticsResponse>(
      {url: `/api/v1/phases/${entityType}/analytics`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetQueryKey = (entityType?: 'task' | 'sprint' | 'project',
    params?: GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams,) => {
    return [
    `/api/v1/phases/${entityType}/analytics`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetQueryOptions = <TData = Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError = HTTPValidationError>(entityType: 'task' | 'sprint' | 'project',
    params?: GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetQueryKey(entityType,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>> = ({ signal }) => getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet(entityType,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(entityType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>>
export type GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetQueryError = HTTPValidationError


export function useGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet<TData = Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params: undefined |  GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>,
          TError,
          Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet<TData = Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params?: GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>,
          TError,
          Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet<TData = Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params?: GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Phase Analytics
 */

export function useGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet<TData = Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError = HTTPValidationError>(
 entityType: 'task' | 'sprint' | 'project',
    params?: GetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetPhaseAnalyticsApiV1PhasesEntityTypeAnalyticsGetQueryOptions(entityType,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




